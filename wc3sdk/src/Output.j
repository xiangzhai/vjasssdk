globals
//globals from ALibraryCoreStringPool:
		constant string ALibraryCoreStringPool___ALPHABETICAL_CHARS = "abcdefghijklmnopqrstuvwxyz"
		constant string ALibraryCoreStringPool___NUMERAL_CHARS = "0123456789"
		constant string ALibraryCoreStringPool___SPECIAL_CHARS = "!§$%&/()=?+-/*,.-;:_~#'|<>"
		constant string ALibraryCoreStringPool___LANGUAGE_SPECIAL_CHARS = "äöüß" /// @todo Use localized string function.
		constant string ALibraryCoreStringPool___SIGNATURE_CHARS = "+-" //Not a random pool. Is used for checking integers.
		constant string ALibraryCoreStringPool___BINARY_CHARS = "01" //Here it's the same.
		constant string ALibraryCoreStringPool___OCTAL_CHARS = "01234567"
		constant string ALibraryCoreStringPool___HEXADECIMAL_CHARS = "0123456789ABCDEF"
//endglobals from ALibraryCoreStringPool
//globals from ALibraryCoreInterfaceMisc:
		//Keys
		constant integer KEY_ESCAPE = 0
		constant integer KEY_UP = 1
		constant integer KEY_DOWN = 2
		constant integer KEY_RIGHT = 3
		constant integer KEY_LEFT = 4
		//Hotkeys für Dialoge nach dem ASCII
		constant integer SHORTCUT_BACKSPACE = 8
		constant integer SHORTCUT_TAB = 9
		constant integer SHORTCUT_ESCAPE = 27
		constant integer SHORTCUT_SPACE = 32
		constant integer SHORTCUT_0 = 48
		constant integer SHORTCUT_1 = 49
		constant integer SHORTCUT_2 = 50
		constant integer SHORTCUT_3 = 51
		constant integer SHORTCUT_4 = 52
		constant integer SHORTCUT_5 = 53
		constant integer SHORTCUT_6 = 54
		constant integer SHORTCUT_7 = 55
		constant integer SHORTCUT_8 = 56
		constant integer SHORTCUT_9 = 57
		//Kürzel der Kleinbuchstaben
		constant integer SHORTCUT_A = 65 
		constant integer SHORTCUT_B = 66 
		constant integer SHORTCUT_C = 67
		constant integer SHORTCUT_D = 68
		constant integer SHORTCUT_E = 69
		constant integer SHORTCUT_F = 70
		constant integer SHORTCUT_G = 71
		constant integer SHORTCUT_H = 72
		constant integer SHORTCUT_I = 73
		constant integer SHORTCUT_J = 74
		constant integer SHORTCUT_K = 75
		constant integer SHORTCUT_L = 76
		constant integer SHORTCUT_M = 77
		constant integer SHORTCUT_N = 78
		constant integer SHORTCUT_O = 79
		constant integer SHORTCUT_P = 80
		constant integer SHORTCUT_Q = 81
		constant integer SHORTCUT_R = 82
		constant integer SHORTCUT_S = 83
		constant integer SHORTCUT_T = 84
		constant integer SHORTCUT_U = 85
		constant integer SHORTCUT_V = 86
		constant integer SHORTCUT_W = 87
		constant integer SHORTCUT_X = 88
		constant integer SHORTCUT_Y = 89
		constant integer SHORTCUT_Z = 90
//endglobals from ALibraryCoreInterfaceMisc
//globals from ALibraryCoreDebugInterface:
		multiboard array ALibraryCoreDebugInterface__usedMultiboard
//endglobals from ALibraryCoreDebugInterface
//globals from ALibrarySystemsDebugUtilities:
		constant string ALibrarySystemsDebugUtilities___clearCheat = "clear"
		constant string ALibrarySystemsDebugUtilities___infoCheat = "info"
		constant string ALibrarySystemsDebugUtilities___levelCheat = "setlevel"
		constant string ALibrarySystemsDebugUtilities___killCheat = "kill"
		constant string ALibrarySystemsDebugUtilities___containerCheat = "container"
		constant string ALibrarySystemsDebugUtilities___stringCheat = "string"
		constant string ALibrarySystemsDebugUtilities___interfaceCheat = "interface"
		trigger ALibrarySystemsDebugUtilities___cheatTrigger
//endglobals from ALibrarySystemsDebugUtilities
//globals from ALibrarySystemsDebugCharacter:
		boolean ALibrarySystemsDebugCharacter__hasToInit = true
		unit ALibrarySystemsDebugCharacter__talkUnit
		destructable ALibrarySystemsDebugCharacter__shrineDestructable
//endglobals from ALibrarySystemsDebugCharacter
//globals from ALibrarySystemsDebugGui:
		boolean ALibrarySystemsDebugGui__hasToInit = true
integer array ALibrarySystemsDebugGui__questLog
//endglobals from ALibrarySystemsDebugGui
    // Generated

trigger l__library_init

//JASSHelper struct globals:
constant integer si__ASlkTableEntry=1
integer si__ASlkTableEntry_F=0
integer si__ASlkTableEntry_I=0
integer array si__ASlkTableEntry_V
integer array s__ASlkTableEntry_entry
constant integer si__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface=2
integer si__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_F=0
integer si__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_I=0
integer array si__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_V
integer array si__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_type
trigger array st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_onDestroy
trigger array st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_enable
trigger array st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_disable
constant integer si__AAbstractCharacterSystem=3
integer array s__AAbstractCharacterSystem_character
constant integer si__AClass=4
integer si__AClass_F=0
integer si__AClass_I=0
integer array si__AClass_V
constant integer s__AClass_maxAbilities= 12 //For class selection
constant integer s__AClass_maxDescriptionLines= 5 //For class selection
integer s__AClass_startLevel
integer s__AClass_startSkillPoints
string array s___AClass_abilityIconPath
constant integer s___AClass_abilityIconPath_size=12
integer array s__AClass_abilityIconPath
integer array s___AClass_usedAbility
constant integer s___AClass_usedAbility_size=12
integer array s__AClass_usedAbility
string array s___AClass_descriptionLine
constant integer s___AClass_descriptionLine_size=5
integer array s__AClass_descriptionLine
integer array s__AClass_unitType
string array s__AClass_animation
string array s__AClass_soundPath
constant integer si__APoint=8
integer si__APoint_F=0
integer si__APoint_I=0
integer array si__APoint_V
real array s__APoint_x
real array s__APoint_y
constant integer si__AHashTable=9
integer si__AHashTable_F=0
integer si__AHashTable_I=0
integer array si__AHashTable_V
integer s__AHashTable_hashTables= 0 //There is a limit of 256 game caches
gamecache array s__AHashTable_gameCache
string array s__AHashTable_name
constant integer si__AStructCoreGeneralStack__AIntegerDataNode=10
integer si__AStructCoreGeneralStack__AIntegerDataNode_F=0
integer si__AStructCoreGeneralStack__AIntegerDataNode_I=0
integer array si__AStructCoreGeneralStack__AIntegerDataNode_V
integer array s__AStructCoreGeneralStack__AIntegerDataNode_data
integer array s__AStructCoreGeneralStack__AIntegerDataNode_next
constant integer si__AIntegerStack=11
integer si__AIntegerStack_F=0
integer si__AIntegerStack_I=0
integer array si__AIntegerStack_V
integer array s__AIntegerStack_maxSize
integer array s__AIntegerStack_dataNode
integer array s__AIntegerStack_objects
constant integer si__ACircle=12
real array s__ACircle_radius
constant integer si__AVector=13
integer si__AVector_F=0
integer si__AVector_I=0
integer array si__AVector_V
real array s__AVector_x
real array s__AVector_y
real array s__AVector_z
constant integer si__AStructCoreDebugDebugHashTable__ADebugHashTable=14
integer si__AStructCoreDebugDebugHashTable__ADebugHashTable_F=0
integer si__AStructCoreDebugDebugHashTable__ADebugHashTable_I=0
integer array si__AStructCoreDebugDebugHashTable__ADebugHashTable_V
integer s__AStructCoreDebugDebugHashTable__ADebugHashTable_instance
constant integer si__AMissileContainer=20
integer si__AMissileContainer_F=0
integer si__AMissileContainer_I=0
integer array si__AMissileContainer_V
integer array s___AMissileContainer_element
constant integer s___AMissileContainer_element_size=100
integer array s__AMissileContainer_element
integer array s__AMissileContainer_m
integer array s__AMissileContainer_j
constant integer si__AMissile=24
integer si__AMissile_F=0
integer si__AMissile_I=0
integer array si__AMissile_V
real s__AMissile_refreshTime
boolean s__AMissile_enableCollisions
trigger s__AMissile_refreshTrigger
integer s__AMissile_missileCount
player array s__AMissile_m_owner
integer array s__AMissile_m_unitType
real array s__AMissile_m_speed
real array s__AMissile_m_damage
real array s__AMissile_m_damageRange
real array s__AMissile_m_targetX
real array s__AMissile_m_targetY
widget array s__AMissile_m_targetWidget
boolean array s__AMissile_m_collides
string array s__AMissile_m_deathEffectPath
string array s__AMissile_m_deathSoundPath
integer array s__AMissile_m_onCollisionFunction
integer array s__AMissile_m_onDeathFunction
unit array s__AMissile_usedUnit
real array s__AMissile_cos
real array s__AMissile_sin
boolean array s__AMissile_paused
constant integer si__AStructCoreInterfaceInterfaceHashTable___AInterfaceHashTable=25
integer si__AStructCoreInterfaceInterfaceHashTable___AInterfaceHashTable_F=0
integer si__AStructCoreInterfaceInterfaceHashTable___AInterfaceHashTable_I=0
integer array si__AStructCoreInterfaceInterfaceHashTable___AInterfaceHashTable_V
integer s__AStructCoreInterfaceInterfaceHashTable___AInterfaceHashTable_instance= 0
constant integer si__AStructSystemsCharacterCharacterHashTable___ACharacterHashTable=26
integer si__AStructSystemsCharacterCharacterHashTable___ACharacterHashTable_F=0
integer si__AStructSystemsCharacterCharacterHashTable___ACharacterHashTable_I=0
integer array si__AStructSystemsCharacterCharacterHashTable___ACharacterHashTable_V
integer s__AStructSystemsCharacterCharacterHashTable___ACharacterHashTable_instance= 0
constant integer si__AStructSystemsWorldWorldHashTable__AWorldHashTable=27
integer si__AStructSystemsWorldWorldHashTable__AWorldHashTable_F=0
integer si__AStructSystemsWorldWorldHashTable__AWorldHashTable_I=0
integer array si__AStructSystemsWorldWorldHashTable__AWorldHashTable_V
integer s__AStructSystemsWorldWorldHashTable__AWorldHashTable_instance= 0
constant integer si__AIntegerContainer=33
integer si__AIntegerContainer_F=0
integer si__AIntegerContainer_I=0
integer array si__AIntegerContainer_V
integer array s___AIntegerContainer_element
constant integer s___AIntegerContainer_element_size=1000
integer array s__AIntegerContainer_element
integer array s__AIntegerContainer_m
integer array s__AIntegerContainer_j
constant integer si__ACheat=36
integer si__ACheat_F=0
integer si__ACheat_I=0
integer array si__ACheat_V
string array s__ACheat_m_cheat
integer array s__ACheat_m_action
trigger array s__ACheat_cheatTrigger
constant integer si__AIndicator=37
integer si__AIndicator_F=0
integer si__AIndicator_I=0
integer array si__AIndicator_V
constant integer s__AIndicator_objectTypeImage= 0
constant integer s__AIndicator_objectTypeTextTag= 1
constant integer s__AIndicator_objectTypeUnit= 2
handle array s__AIndicator_object
integer array s__AIndicator_objectType
real array s__AIndicator_rate
real array s__AIndicator_time
real array s__AIndicator_red
real array s__AIndicator_green
real array s__AIndicator_blue
real array s__AIndicator_transparency
trigger array s__AIndicator_refreshTrigger
real array s__AIndicator_elapsedTime
boolean array s__AIndicator_firstTime
constant integer si__AMultiboardBar=39
integer si__AMultiboardBar_F=0
integer si__AMultiboardBar_I=0
integer array si__AMultiboardBar_V
constant integer s__AMultiboardBar_maxLength= 20
multiboard array s__AMultiboardBar_usedMultiboard
integer array s__AMultiboardBar_column
integer array s__AMultiboardBar_row
integer array s__AMultiboardBar_length
real array s__AMultiboardBar_refreshRate
boolean array s__AMultiboardBar_horizontal
real array s__AMultiboardBar_value
real array s__AMultiboardBar_maxValue
string array s___AMultiboardBar_valueIcon
constant integer s___AMultiboardBar_valueIcon_size=20
integer array s__AMultiboardBar_valueIcon
string array s___AMultiboardBar_emptyIcon
constant integer s___AMultiboardBar_emptyIcon_size=20
integer array s__AMultiboardBar_emptyIcon
integer array s__AMultiboardBar_valueFunction
integer array s__AMultiboardBar_maxValueFunction
integer array s__AMultiboardBar_colouredPart
trigger array s__AMultiboardBar_refreshTrigger
constant integer si__ACharacter=42
integer si__ACharacter_F=0
integer si__ACharacter_I=0
integer array si__ACharacter_V
constant integer s__ACharacter_messageTypeInfo= 0
constant integer s__ACharacter_messageTypeError= 1
boolean s__ACharacter_removeUnitOnDestruction
boolean s__ACharacter_destroyOnPlayerLeaves
boolean s__ACharacter_destroyOnDeath
boolean s__ACharacter_useViewSystem
boolean s__ACharacter_useFocusSystem
boolean s__ACharacter_useMovementSystem
boolean s__ACharacter_useFightSystem
boolean s__ACharacter_useRevivalSystem
boolean s__ACharacter_useInventorySystem
integer array s__ACharacter_playerCharacter
boolean array s__ACharacter_movable
integer array s__ACharacter_class
integer array s__ACharacter_talk
integer array s__ACharacter_shrine
player array s__ACharacter_user
unit array s__ACharacter_usedUnit
trigger array s__ACharacter_leaveTrigger
trigger array s__ACharacter_deathTrigger
integer array s__ACharacter_view
integer array s__ACharacter_focus
integer array s__ACharacter_movement
integer array s__ACharacter_fight
integer array s__ACharacter_revival
integer array s__ACharacter_inventory
constant integer si__AFight=43
boolean s__AFight_useFps
string s__AFight_order
real s__AFight_time
string s__AFight_hitAnimation
real s__AFight_angle
trigger array s__AFight_fightTrigger
timer array s__AFight_usedTimer
boolean array s__AFight_hasOrdered
boolean array s__AFight_canOrder
constant integer si__ASpell=45
integer array s__ASpell_usedAbility
integer array s__ASpell_castAction
trigger array s__ASpell_castTrigger
constant integer si__AView=46
camerasetup s__AView_cameraSetup
real s__AView_viewRefreshRate
trigger array s__AView_viewTrigger
constant integer si__AMainWindowContainer=52
integer si__AMainWindowContainer_F=0
integer si__AMainWindowContainer_I=0
integer array si__AMainWindowContainer_V
integer array s___AMainWindowContainer_element
constant integer s___AMainWindowContainer_element_size=4
integer array s__AMainWindowContainer_element
integer array s__AMainWindowContainer_m
integer array s__AMainWindowContainer_j
constant integer si__AGui=57
integer si__AGui_F=0
integer si__AGui_I=0
integer array si__AGui_V
constant integer s__AGui_shortcutArrowUpDown= 0 //these are the special shortcuts
constant integer s__AGui_shortcutArrowDownDown= 1
constant integer s__AGui_shortcutArrowLeftDown= 2
constant integer s__AGui_shortcutArrowRightDown= 3
constant integer s__AGui_shortcutArrowUpUp= 4
constant integer s__AGui_shortcutArrowDownUp= 5
constant integer s__AGui_shortcutArrowLeftUp= 6
constant integer s__AGui_shortcutArrowRightUp= 7
constant integer s__AGui_shortcutEscape= 8 //last value has to be lesser than 'a'
constant integer s__AGui_maxSpecialShortcuts= 9
constant integer s__AGui_maxMainWindows= 4 //public see above in the text macro
constant integer s__AGui_maxShortcuts= 91 //'Z' + 1
constant integer s__AGui_maxDialogButtons= 12 //16?
integer s__AGui_shortcutHandlerUnitType
real s__AGui_shortcutHandlerX
real s__AGui_shortcutHandlerY
string s__AGui_textOk
integer array s__AGui_playerGui
integer array s___AGui_onPressShortcutAction
constant integer s___AGui_onPressShortcutAction_size=91
integer array s__AGui_onPressShortcutAction
integer array s___AGui_onPressShortcutActionId
constant integer s___AGui_onPressShortcutActionId_size=91
integer array s__AGui_onPressShortcutActionId
player array s__AGui_user
integer array s__AGui_container
integer array s__AGui_shownMainWindow
trigger array s__AGui_leaveTrigger
unit array s__AGui_shortcutHandler
trigger array s__AGui_shortcutHandleTrigger
trigger array s___AGui_specialShortcutHandleTrigger
constant integer s___AGui_specialShortcutHandleTrigger_size=9
integer array s__AGui_specialShortcutHandleTrigger
real array s__AGui_playerDataCameraX
real array s__AGui_playerDataCameraY
group array s__AGui_playerDataSelection
dialog array s__AGui_usedDialog
button array s___AGui_dialogButton
constant integer s___AGui_dialogButton_size=12
integer array s__AGui_dialogButton
integer array s__AGui_dialogButtons
trigger array s___AGui_dialogButtonTrigger
constant integer s___AGui_dialogButtonTrigger_size=12
integer array s__AGui_dialogButtonTrigger
integer array s___AGui_dialogButtonAction
constant integer s___AGui_dialogButtonAction_size=12
integer array s__AGui_dialogButtonAction
constant integer si__ARoutine=65
integer si__ARoutine_F=0
integer si__ARoutine_I=0
integer array si__ARoutine_V
unit array s__ARoutine_usedUnit
real array s__ARoutine_startTimeOfDay
real array s__ARoutine_endTimeOfDay
real array s__ARoutine_runRate
integer array s__ARoutine_routineAction
trigger array s__ARoutine_runTrigger
trigger array s__ARoutine_enableTrigger
trigger array s__ARoutine_disableTrigger
constant integer si__ASpawnPoint=66
integer si__ASpawnPoint_F=0
integer si__ASpawnPoint_I=0
integer array si__ASpawnPoint_V
real s__ASpawnPoint_time
string s__ASpawnPoint_effectPath
integer s__ASpawnPoint_dropChance
unitpool array s__ASpawnPoint_unitPool
itempool array s__ASpawnPoint_itemPool
real array s__ASpawnPoint_x
real array s__ASpawnPoint_y
real array s__ASpawnPoint_range
trigger array s__ASpawnPoint_deathTrigger
timer array s__ASpawnPoint_spawnTimer
unit array s__ASpawnPoint_spawnedUnit
effect array s__ASpawnPoint_usedEffect
constant integer si__AAbstractQuest=70
integer si__AAbstractQuest_F=0
integer si__AAbstractQuest_I=0
integer array si__AAbstractQuest_V
constant integer s__AAbstractQuest_stateNotUsed= -1 /// do not set this state by the setState() method
constant integer s__AAbstractQuest_stateNew= 0
constant integer s__AAbstractQuest_stateCompleted= 1
constant integer s__AAbstractQuest_stateFailed= 2
constant integer s__AAbstractQuest_rewardLevel= 0
constant integer s__AAbstractQuest_rewardSkillPoints= 1
constant integer s__AAbstractQuest_rewardExperience= 2
constant integer s__AAbstractQuest_rewardStrength= 3
constant integer s__AAbstractQuest_rewardAgility= 4
constant integer s__AAbstractQuest_rewardIntelligence= 5
constant integer s__AAbstractQuest_rewardGold= 6
constant integer s__AAbstractQuest_rewardLumber= 7
constant integer s__AAbstractQuest_maxStates= 3
constant integer s__AAbstractQuest_maxRewards= 8
string s__AAbstractQuest_stateNewSoundPath= "Sound\\Interface\\QuestNew.wav"
string s__AAbstractQuest_stateCompletedSoundPath= "Sound\\Interface\\QuestCompleted.wav"
string s__AAbstractQuest_stateFailedSoundPath= "Sound\\Interface\\QuestFailed.wav"
string s__AAbstractQuest_textStateNew= "%s Neu"
string s__AAbstractQuest_textStateCompleted= "%s Abgeschlossen"
string s__AAbstractQuest_textStateFailed= "%s Fehlgeschlagen"
string s__AAbstractQuest_textRewardLevels= "+%i Stufe(n)"
string s__AAbstractQuest_textRewardSkillPoints= "%i Heldenfähigkeiten-Punkt(e)"
string s__AAbstractQuest_textRewardExperience= "+%i Erfahrung"
string s__AAbstractQuest_textRewardStrength= "+%i Kraft"
string s__AAbstractQuest_textRewardAgility= "+%i Beweglichkeit"
string s__AAbstractQuest_textRewardIntelligence= "+%i Intelligenz"
string s__AAbstractQuest_textRewardGold= "+%i Gold"
string s__AAbstractQuest_textRewardLumber= "+%i Holz"
integer array s__AAbstractQuest_state
integer array s___AAbstractQuest_stateCondition
constant integer s___AAbstractQuest_stateCondition_size=3
integer array s__AAbstractQuest_stateCondition
integer array s___AAbstractQuest_stateAction
constant integer s___AAbstractQuest_stateAction_size=3
integer array s__AAbstractQuest_stateAction
integer array s___AAbstractQuest_reward
constant integer s___AAbstractQuest_reward_size=8
integer array s__AAbstractQuest_reward
real array s__AAbstractQuest_pingX
real array s__AAbstractQuest_pingY
real array s__AAbstractQuest_pingDuration
real array s__AAbstractQuest_pingRed
real array s__AAbstractQuest_pingGreen
real array s__AAbstractQuest_pingBlue
integer array s__AAbstractQuest_character
string array s__AAbstractQuest_title
real array s__AAbstractQuest_pingRate
trigger array s___AAbstractQuest_stateTrigger
constant integer s___AAbstractQuest_stateTrigger_size=3
integer array s__AAbstractQuest_stateTrigger
trigger array s__AAbstractQuest_pingTrigger
trigger array st__AAbstractQuest_setState
constant integer si__ACharactersScheme=75
integer si__ACharactersScheme_F=0
integer si__ACharactersScheme_I=0
integer array si__ACharactersScheme_V
real s__ACharactersScheme_refreshRate
integer s__ACharactersScheme_barLength
string s__ACharactersScheme_textTitle
string s__ACharactersScheme_textLevel
string s__ACharactersScheme_textLeftGame
trigger s__ACharactersScheme_refreshTrigger
multiboard s__ACharactersScheme_usedMultiboard
integer s__ACharactersScheme_maxPlayers
constant integer si__AClassSelection=78
integer si__AClassSelection_F=0
integer si__AClassSelection_I=0
integer array si__AClassSelection_V
constant integer s__AClassSelection_maxInfoSheetItems= 4 + 12 + 1 + 5 //4 + AClass.maxAbilities + 1 + AClass.maxDescriptionLines
constant integer s__AClassSelection_maxInfoSheetIconItems= 4 + 12 //4 + AClass.maxAbilities
camerasetup s__AClassSelection_cameraSetup
real s__AClassSelection_x
real s__AClassSelection_y
real s__AClassSelection_facing
real s__AClassSelection_refreshRate
real s__AClassSelection_rotationAngle
integer s__AClassSelection_firstClass
integer s__AClassSelection_lastClass
integer s__AClassSelection_startGameAction
string s__AClassSelection_strengthIconPath
string s__AClassSelection_agilityIconPath
string s__AClassSelection_intelligenceIconPath
string s__AClassSelection_textStrength
string s__AClassSelection_textAgility
string s__AClassSelection_textIntelligence
string s__AClassSelection_textAbilities
string s__AClassSelection_textDescription
integer s__AClassSelection_stack
player array s__AClassSelection_user
real array s__AClassSelection_startX
real array s__AClassSelection_startY
real array s__AClassSelection_startFacing
integer array s__AClassSelection_selectClassAction
unit array s__AClassSelection_classUnit
trigger array s__AClassSelection_refreshTrigger
trigger array s__AClassSelection_changePreviousTrigger
trigger array s__AClassSelection_changeNextTrigger
trigger array s__AClassSelection_selectTrigger
multiboard array s__AClassSelection_infoSheet
integer array s__AClassSelection_class
constant integer si__AFocus=79
real s__AFocus_refreshRate
real s__AFocus_range
real s__AFocus_angle
integer s__AFocus_workerUnitType
boolean s__AFocus_showText
boolean s__AFocus_indicateTarget
string s__AFocus_textLevel
trigger array s__AFocus_focusTrigger
texttag array s__AFocus_textTag
trigger array s__AFocus_workerTrigger
unit array s__AFocus_worker
unit array s__AFocus_target
boolean array s__AFocus_fixedTarget
constant integer si__AItemType=80
integer si__AItemType_F=0
integer si__AItemType_I=0
integer array si__AItemType_V
constant integer s__AItemType_equipmentTypeHeaddress= 0
constant integer s__AItemType_equipmentTypeArmour= 1
constant integer s__AItemType_equipmentTypePrimaryWeapon= 2
constant integer s__AItemType_equipmentTypeSecondaryWeapon= 3
constant integer s__AItemType_maxEquipmentTypes= 4
string s__AItemType_textLevel
string s__AItemType_textStrength
string s__AItemType_textAgility
string s__AItemType_textIntelligence
string s__AItemType_textClass
integer array s__AItemType_itemType
integer array s__AItemType_equipmentType
integer array s__AItemType_requiredLevel
integer array s__AItemType_requiredStrength
integer array s__AItemType_requiredAgility
integer array s__AItemType_requiredIntelligence
integer array s__AItemType_requiredClass
constant integer si__AMovement=81
constant integer s__AMovement_stateMoveForward= 0
constant integer s__AMovement_stateMoveBackward= 1
constant integer s__AMovement_stateTurnRight= 2
constant integer s__AMovement_stateTurnLeft= 3
constant integer s__AMovement_maxStates= 4
constant integer s__AMovement_maxMovementTriggers= 8
boolean s__AMovement_useFps
integer s__AMovement_fpsKeyMoveForward
integer s__AMovement_fpsKeyMoveBackward
integer s__AMovement_fpsKeyTurnRight
integer s__AMovement_fpsKeyTurnLeft
real s__AMovement_refreshRate
real s__AMovement_speed
real s__AMovement_angle
boolean s__AMovement_stopWhileStanding
trigger array s__AMovement_movementTrigger
trigger array s___AMovement_startMovementTrigger
constant integer s___AMovement_startMovementTrigger_size=8
integer array s__AMovement_startMovementTrigger
integer si__AMovement_arrI=0
integer si__AMovement_arrN=0
integer array si__AMovement_arr
integer array si__AMovement_arrV
trigger array s__AMovement_fpsTriggerUp
trigger array s__AMovement_fpsTriggerDown
boolean array s___AMovement_state
constant integer s___AMovement_state_size=4
integer array s__AMovement_state
constant integer si__ARevival=84
boolean s__ARevival_showDialog
real array s__ARevival_time
real array s__ARevival_x
real array s__ARevival_y
real array s__ARevival_facing
trigger array s__ARevival_revivalTrigger
timer array s__ARevival_usedTimer
timerdialog array s__ARevival_timerDialog
constant integer si__AStructSystemsCharacterTalk___AInfo=85
integer si__AStructSystemsCharacterTalk___AInfo_F=0
integer si__AStructSystemsCharacterTalk___AInfo_I=0
integer array si__AStructSystemsCharacterTalk___AInfo_V
integer array s__AStructSystemsCharacterTalk___AInfo_talk
string array s__AStructSystemsCharacterTalk___AInfo_text
sound array s__AStructSystemsCharacterTalk___AInfo_usedSound
boolean array s__AStructSystemsCharacterTalk___AInfo_toCharacter
boolean array s__AStructSystemsCharacterTalk___AInfo_permanent
boolean array s__AStructSystemsCharacterTalk___AInfo_important
integer array s__AStructSystemsCharacterTalk___AInfo_condition
integer array s__AStructSystemsCharacterTalk___AInfo_buttonAction
boolean array s___AStructSystemsCharacterTalk___AInfo_wasPressed
constant integer s___AStructSystemsCharacterTalk___AInfo_wasPressed_size=12
integer array s__AStructSystemsCharacterTalk___AInfo_wasPressed
constant integer si__ATalk=90
integer si__ATalk_F=0
integer si__ATalk_I=0
integer array si__ATalk_V
constant integer s__ATalk_maxButtons= 12
constant integer s__ATalk_maxInfos= 50
camerasetup s__ATalk_cameraSetup
real s__ATalk_noSoundTime
integer s__ATalk_skipKey
real s__ATalk_skipCheckRate
string s__ATalk_order
real s__ATalk_maxDistance
string s__ATalk_effectPath
string s__ATalk_speechAnimation
string s__ATalk_listenAnimation
string s__ATalk_textErrorMessage
string s__ATalk_textExit
string s__ATalk_textBack
trigger s__ATalk_skipTrigger
unit array s__ATalk_usedUnit
integer array s__ATalk_startAction
trigger array s__ATalk_orderTrigger
effect array s__ATalk_usedEffect
integer array s___ATalk_buttonAction
constant integer s___ATalk_buttonAction_size=12
integer array s__ATalk_buttonAction
integer array s___ATalk_buttonInfo
constant integer s___ATalk_buttonInfo_size=12
integer array s__ATalk_buttonInfo
integer array s__ATalk_buttons
integer array s___ATalk_info
constant integer s___ATalk_info_size=50
integer array s__ATalk_info
integer array s__ATalk_infos
integer array s__ATalk_character
constant integer si__AVideo=95
integer si__AVideo_F=0
integer si__AVideo_I=0
integer array si__AVideo_V
integer s__AVideo_divident
real s__AVideo_filterDuration
real s__AVideo_waitInterval
string s__AVideo_textPlayerSkips
string s__AVideo_textSkip
integer s__AVideo_runningVideo
boolean s__AVideo_skipped
integer s__AVideo_skippingPlayers
trigger s__AVideo_skipTrigger
integer array s__AVideo_playAction
constant integer si__AWidget=98
integer si__AWidget_F=0
integer si__AWidget_I=0
integer array si__AWidget_V
string s__AWidget_onHitSoundPath= null
string s__AWidget_onTrackSoundPath= null
boolean array s__AWidget_m_shown
integer array s__AWidget_shortcut
string array s__AWidget_tooltip
real array s__AWidget_tooltipSize
integer array s__AWidget_mainWindow
real array s__AWidget_x
real array s__AWidget_y
real array s__AWidget_sizeX
real array s__AWidget_sizeY
integer array s__AWidget_onHitAction
integer array s__AWidget_onTrackAction
trackable array s__AWidget_usedTrackable
trigger array s__AWidget_onHitTrigger
trigger array s__AWidget_onTrackTrigger
trigger array st__AWidget_show
trigger array st__AWidget_hide
constant integer si__AInventory=99
constant integer s__AInventory_maxEquipmentTypes= 4//AItemType.maxEuqipmentTypes /// @todo vJass bug //AClassCharacterItemType
constant integer s__AInventory_maxRucksackItems= 16
constant integer s__AInventory_maxRucksackPages= 4 //16 / 4
constant integer s__AInventory_maxRucksackItemsPerPage= 4
integer s__AInventory_leftArrowItemType
integer s__AInventory_rightArrowItemType
integer s__AInventory_openRucksackAbilityId
string s__AInventory_textUnableToEquipItem
string s__AInventory_textUnableToAddRucksackItem
string s__AInventory_textUnableToMoveRucksackItem
integer array s___AInventory_equipmentItemType
constant integer s___AInventory_equipmentItemType_size=4
integer array s__AInventory_equipmentItemType
integer si__AInventory_arrI=0
integer si__AInventory_arrN=0
integer array si__AInventory_arr
integer array si__AInventory_arrV
integer array s___AInventory_rucksackItemType
constant integer s___AInventory_rucksackItemType_size=16
integer array s__AInventory_rucksackItemType
integer array s___AInventory_rucksackItemCharges
constant integer s___AInventory_rucksackItemCharges_size=16
integer array s__AInventory_rucksackItemCharges
trigger array s__AInventory_openTrigger
trigger array s__AInventory_orderTrigger
trigger array s__AInventory_useTrigger
trigger array s__AInventory_pickupTrigger
trigger array s__AInventory_dropTrigger
integer array s__AInventory_rucksackPage
boolean array s__AInventory_rucksackIsEnabled
constant integer si__AQuest=103
constant integer s__AQuest_maxQuestItems= 5
boolean s__AQuest_useQuestLog= true //test
string s__AQuest_updateSoundPath= "Sound\\Interface\\QuestLog.wav" //test
integer array s___AQuest_questItem
constant integer s___AQuest_questItem_size=5
integer array s__AQuest_questItem
integer si__AQuest_arrI=0
integer si__AQuest_arrN=0
integer array si__AQuest_arr
integer array si__AQuest_arrV
string array s__AQuest_iconPath
string array s__AQuest_description
integer array s__AQuest_questItems
quest array s__AQuest_questLogQuest
trigger array st__AQuest_setState
constant integer si__AShrine=105
integer si__AShrine_F=0
integer si__AShrine_I=0
integer array si__AShrine_V
string s__AShrine_effectPath
string s__AShrine_soundPath
string s__AShrine_textMessage
destructable array s__AShrine_usedDestructable
rect array s__AShrine_discoverRect
rect array s__AShrine_revivalRect
trigger array s__AShrine_shrineTrigger
region array s__AShrine_discoverRegion
effect array s__AShrine_discoverEffect
constant integer si__AButton=106
constant integer si__AImage=107
integer array s__AImage_red
integer array s__AImage_green
integer array s__AImage_blue
integer array s__AImage_alpha
string array s__AImage_file
image array s__AImage_usedImage
trigger array st__AImage_show
trigger array st__AImage_hide
constant integer si__AWidgetContainer=113
integer si__AWidgetContainer_F=0
integer si__AWidgetContainer_I=0
integer array si__AWidgetContainer_V
integer array s___AWidgetContainer_element
constant integer s___AWidgetContainer_element_size=100
integer array s__AWidgetContainer_element
integer array s__AWidgetContainer_m
integer array s__AWidgetContainer_j
constant integer si__AMainWindow=115
integer si__AMainWindow_F=0
integer si__AMainWindow_I=0
integer array si__AMainWindow_V
constant integer s__AMainWindow_maxWidgets= 100 //public, see above (text macro)
camerasetup s__AMainWindow_cameraSetup
string s__AMainWindow_tooltipSoundPath
integer array s__AMainWindow_gui
real array s__AMainWindow_x
real array s__AMainWindow_y
real array s__AMainWindow_sizeX
real array s__AMainWindow_sizeY
boolean array s__AMainWindow_useShortcuts
integer array s__AMainWindow_shortcut
integer array s__AMainWindow_container
texttag array s__AMainWindow_tooltip
boolean array s__AMainWindow_isShown
trigger array s__AMainWindow_shortcutTrigger
constant integer si__AText=116
real array s__AText_heightOffset
string array s__AText_text
real array s__AText_size
integer array s__AText_red
integer array s__AText_green
integer array s__AText_blue
integer array s__AText_alpha
real array s__AText_speed
real array s__AText_angle
real array s__AText_fadepoint
boolean array s__AText_suspended
texttag array s__AText_textTag
trigger array st__AText_show
trigger array st__AText_hide
constant integer si__AQuestItem=117
integer array s__AQuestItem_usedQuest
questitem array s__AQuestItem_questLogQuestItem
trigger array st__AQuestItem_setState
constant integer si__ACheckBox=118
string s__ACheckBox_checkedImageFilePath
string s__ACheckBox_uncheckedImageFilePath
boolean array s__ACheckBox_m_checked
integer array s__ACheckBox_checkedImage
integer array s__ACheckBox_uncheckedImage
trigger array st__ACheckBox_show
trigger array st__ACheckBox_hide
constant integer si__ASystemDebugger=119
integer si__ASystemDebugger_F=0
integer si__ASystemDebugger_I=0
integer array si__ASystemDebugger_V
integer s__ASystemDebugger_menuKey
player array s__ASystemDebugger_user
trigger array s__ASystemDebugger_menuTrigger
integer array s__ASystemDebugger_mainWindow
integer array s__ASystemDebugger_headLineText
integer array s__ASystemDebugger_guiSystemsButton
integer array s__ASystemDebugger_characterSystemsButton
integer array s__ASystemDebugger_worldSystemsButton
integer array s__ASystemDebugger_guiSystemWindow
integer array s__ASystemDebugger_guiSystemHeadLineText
integer array s__ASystemDebugger_characterSystemWindow
integer array s__ASystemDebugger_characterSystemHeadLineText
integer array s__ASystemDebugger_initCharacterSystemButton
integer array s__ASystemDebugger_createCharactersButton
integer array s__ASystemDebugger_removeUnitOnDestructionCheckBox
integer array s__ASystemDebugger_destroyOnPlayerLeavesCheckBox
integer array s__ASystemDebugger_destroyOnDeathCheckBox
integer array s__ASystemDebugger_useViewSystemCheckBox
integer array s__ASystemDebugger_useFocusSystemCheckBox
integer array s__ASystemDebugger_useMovementSystemCheckBox
integer array s__ASystemDebugger_useFightSystemCheckBox
integer array s__ASystemDebugger_useRevivalSystemCheckBox
integer array s__ASystemDebugger_useInventorySystemCheckBox
integer array s__ASystemDebugger_worldSystemWindow
integer array s__ASystemDebugger_worldSystemHeadLineText
string array s__s__AHashTable_hashTableNames
integer array s__s__AMissile_missiles
integer array s__s__AGui_shortcutAbility
integer array s__s__ACharactersScheme_hitPointsBar
integer array s__s__ACharactersScheme_manaBar
boolean array s__s__ATalk_playerHasSkipped
integer array si__APoint_type
trigger array st__APoint_onDestroy
integer array si__AAbstractQuest_type
trigger array st__AAbstractQuest_onDestroy
integer array si__AWidget_type
trigger array st__AWidget_onDestroy
trigger st__AAbstractCharacterSystem_create
trigger st__APoint_create
trigger st__AHashTable_onDestroy
trigger st__AVector_getLength
trigger st__AVector_scale
trigger st__AVector_create
trigger st__AStructCoreDebugDebugHashTable__ADebugHashTable_onDestroy
trigger st__AMissileContainer_debugCheckIndex
trigger st__AMissile_start
trigger st__AMissile_causeDamage
trigger st__AMissile_showDeathEffect
trigger st__AMissile_playDeathSound
trigger st__AMissile_onDestroy
trigger st__AStructCoreInterfaceInterfaceHashTable___AInterfaceHashTable_onDestroy
trigger st__AStructSystemsCharacterCharacterHashTable___ACharacterHashTable_onDestroy
trigger st__AStructSystemsWorldWorldHashTable__AWorldHashTable_onDestroy
trigger st__AIntegerContainer_debugCheckIndex
trigger st__ACheat_onDestroy
trigger st__AIndicator_reset
trigger st__AIndicator_onDestroy
trigger st__AMultiboardBar_onDestroy
trigger st__ACharacter_destroy
trigger st__ACharacter_getUser
trigger st__ACharacter_getUsedUnit
trigger st__ACharacter_onDestroy
trigger st__ACharacter_getPlayerCharacter
trigger st__AFight_destroy
trigger st__AFight_create
trigger st__AView_destroy
trigger st__AView_create
trigger st__AMainWindowContainer_debugCheckIndex
trigger st__AGui_destroy
trigger st__AGui_enableSpecialShortcutTriggers
trigger st__AGui_disableSpecialShortcutTriggers
trigger st__AGui_createSpecialShortcutTrigger
trigger st__AGui_createDialogButtonTrigger
trigger st__AGui_onDestroy
trigger st__ARoutine_onDestroy
trigger st__ASpawnPoint_onDestroy
trigger st__AAbstractQuest_enable
trigger st__AAbstractQuest_disable
trigger st__AAbstractQuest_enableStateTriggers
trigger st__AAbstractQuest_enablePingTrigger
trigger st__AAbstractQuest_disableStateTriggers
trigger st__AAbstractQuest_disablePingTrigger
trigger st__AAbstractQuest_displayMessage
trigger st__AAbstractQuest_distributeRewards
trigger st__AAbstractQuest_triggerConditionRunQuestState
trigger st__AAbstractQuest_triggerActionRunQuestState
trigger st__AAbstractQuest_create
trigger st__ACharactersScheme_onDestroy
trigger st__ACharactersScheme_createMultiboard
trigger st__ACharactersScheme_createRefreshTrigger
trigger st__AClassSelection_destroy
trigger st__AClassSelection_createUnit
trigger st__AClassSelection_onDestroy
trigger st__AFocus_destroy
trigger st__AFocus_create
trigger st__AItemType_onDestroy
trigger st__AMovement_destroy
trigger st__AMovement_create
trigger st__ARevival_destroy
trigger st__ARevival_end
trigger st__ARevival_create
trigger st__AStructSystemsCharacterTalk___AInfo_onDestroy
trigger st__ATalk_getCharacter
trigger st__ATalk_speech
trigger st__ATalk_showFirstPage
trigger st__ATalk_hide
trigger st__ATalk_disable
trigger st__ATalk_addButton
trigger st__ATalk_runButtonAction
trigger st__ATalk_wait
trigger st__ATalk_refreshView
trigger st__ATalk_refreshFacings
trigger st__ATalk_resetFacings
trigger st__ATalk_resetAnimations
trigger st__ATalk_onDestroy
trigger st__ATalk_createSkipTrigger
trigger st__ATalk_getTime
trigger st__AVideo_createSkipTrigger
trigger st__AWidget_getMainWindow
trigger st__AWidget_enableOnHitTrigger
trigger st__AWidget_enableOnTrackTrigger
trigger st__AWidget_disableOnHitTrigger
trigger st__AWidget_disableOnTrackTrigger
trigger st__AWidget_create
trigger st__AWidget_getTrackablePathBySize
trigger st__AInventory_destroy
trigger st__AInventory_enableEquipment
trigger st__AInventory_disableEquipment
trigger st__AInventory_enableRucksack
trigger st__AInventory_disableRucksack
trigger st__AInventory_addItemToRucksack
trigger st__AInventory_getItemRucksackPage
trigger st__AInventory_setEquipmentItem
trigger st__AInventory_showEquipmentItem
trigger st__AInventory_hideEquipmentItem
trigger st__AInventory_checkEquipment
trigger st__AInventory_setRucksackItem
trigger st__AInventory_showRucksackPage
trigger st__AInventory_hideCurrentRucksackPage
trigger st__AInventory_create
trigger st__AShrine_onDestroy
trigger st__AWidgetContainer_debugCheckIndex
trigger st__AMainWindow_destroy
trigger st__AMainWindow_getGui
trigger st__AMainWindow_getX
trigger st__AMainWindow_getY
trigger st__AMainWindow_getUser
trigger st__AMainWindow_showTooltip
trigger st__AMainWindow_dockWidget
trigger st__AMainWindow_undockWidget
trigger st__AMainWindow_show
trigger st__AMainWindow_hide
trigger st__AMainWindow_onDestroy
trigger st__AQuestItem_destroy
trigger st__ACheckBox_setChecked
trigger st__ACheckBox_isChecked
trigger st__ASystemDebugger_onDestroy
trigger array st___prototype731
integer f__result_integer
trigger array st___prototype765
trigger array st___prototype789
trigger array st___prototype819
trigger array st___prototype820
boolean f__result_boolean
trigger array st___prototype821
trigger array st___prototype822
trigger array st___prototype823
trigger array st___prototype824
trigger array st___prototype825
trigger array st___prototype826
trigger array st___prototype830
real f__result_real
trigger array st___prototype831
trigger array st___prototype832
trigger array st___prototype833
trigger array st___prototype834
trigger array st___prototype835
trigger array st___prototype836
trigger array st___prototype837
trigger array st___prototype838
trigger array st___prototype839
trigger array st___prototype840
trigger array st___prototype841
trigger array st___prototype842
trigger array st___prototype843
trigger array st___prototype844
trigger array st___prototype845
trigger array st___prototype846
trigger array st___prototype847
trigger array st___prototype848
trigger array st___prototype849
trigger array st___prototype850
integer f__arg_integer1
integer f__arg_integer2
integer f__arg_integer3
real f__arg_real1
real f__arg_real2
real f__arg_real3
real f__arg_real4
player f__arg_player1
string f__arg_string1
sound f__arg_sound1
boolean f__arg_boolean1
item f__arg_item1
trigger f__arg_trigger1
integer f__arg_this
player f__result_player
unit f__result_unit
string f__result_string

endglobals
function sc___prototype731_execute takes integer i returns nothing

    call TriggerExecute(st___prototype731[i])
endfunction
function sc___prototype731_evaluate takes integer i returns integer

    call TriggerEvaluate(st___prototype731[i])
 return f__result_integer
endfunction
function sc___prototype765_execute takes integer i returns nothing

    call TriggerExecute(st___prototype765[i])
endfunction
function sc___prototype765_evaluate takes integer i returns nothing

    call TriggerEvaluate(st___prototype765[i])

endfunction
function sc___prototype789_execute takes integer i,integer a1 returns nothing
    set f__arg_integer1=a1

    call TriggerExecute(st___prototype789[i])
endfunction
function sc___prototype789_evaluate takes integer i,integer a1 returns nothing
    set f__arg_integer1=a1

    call TriggerEvaluate(st___prototype789[i])

endfunction
function sc___prototype819_execute takes integer i,integer a1,integer a2 returns nothing
    set f__arg_integer1=a1
    set f__arg_integer2=a2

    call TriggerExecute(st___prototype819[i])
endfunction
function sc___prototype819_evaluate takes integer i,integer a1,integer a2 returns integer
    set f__arg_integer1=a1
    set f__arg_integer2=a2

    call TriggerEvaluate(st___prototype819[i])
 return f__result_integer
endfunction
function sc___prototype820_execute takes integer i,integer a1 returns nothing
    set f__arg_integer1=a1

    call TriggerExecute(st___prototype820[i])
endfunction
function sc___prototype820_evaluate takes integer i,integer a1 returns boolean
    set f__arg_integer1=a1

    call TriggerEvaluate(st___prototype820[i])
 return f__result_boolean
endfunction
function sc___prototype821_execute takes integer i,integer a1,integer a2 returns nothing
    set f__arg_integer1=a1
    set f__arg_integer2=a2

    call TriggerExecute(st___prototype821[i])
endfunction
function sc___prototype821_evaluate takes integer i,integer a1,integer a2 returns boolean
    set f__arg_integer1=a1
    set f__arg_integer2=a2

    call TriggerEvaluate(st___prototype821[i])
 return f__result_boolean
endfunction
function sc___prototype822_execute takes integer i,integer a1 returns nothing
    set f__arg_integer1=a1

    call TriggerExecute(st___prototype822[i])
endfunction
function sc___prototype822_evaluate takes integer i,integer a1 returns nothing
    set f__arg_integer1=a1

    call TriggerEvaluate(st___prototype822[i])

endfunction
function sc___prototype823_execute takes integer i returns nothing

    call TriggerExecute(st___prototype823[i])
endfunction
function sc___prototype823_evaluate takes integer i returns integer

    call TriggerEvaluate(st___prototype823[i])
 return f__result_integer
endfunction
function sc___prototype824_execute takes integer i,integer a1,integer a2 returns nothing
    set f__arg_integer1=a1
    set f__arg_integer2=a2

    call TriggerExecute(st___prototype824[i])
endfunction
function sc___prototype824_evaluate takes integer i,integer a1,integer a2 returns integer
    set f__arg_integer1=a1
    set f__arg_integer2=a2

    call TriggerEvaluate(st___prototype824[i])
 return f__result_integer
endfunction
function sc___prototype825_execute takes integer i,integer a1 returns nothing
    set f__arg_integer1=a1

    call TriggerExecute(st___prototype825[i])
endfunction
function sc___prototype825_evaluate takes integer i,integer a1 returns boolean
    set f__arg_integer1=a1

    call TriggerEvaluate(st___prototype825[i])
 return f__result_boolean
endfunction
function sc___prototype826_execute takes integer i,integer a1,integer a2 returns nothing
    set f__arg_integer1=a1
    set f__arg_integer2=a2

    call TriggerExecute(st___prototype826[i])
endfunction
function sc___prototype826_evaluate takes integer i,integer a1,integer a2 returns boolean
    set f__arg_integer1=a1
    set f__arg_integer2=a2

    call TriggerEvaluate(st___prototype826[i])
 return f__result_boolean
endfunction
function sc___prototype830_execute takes integer i,integer a1 returns nothing
    set f__arg_integer1=a1

    call TriggerExecute(st___prototype830[i])
endfunction
function sc___prototype830_evaluate takes integer i,integer a1 returns real
    set f__arg_integer1=a1

    call TriggerEvaluate(st___prototype830[i])
 return f__result_real
endfunction
function sc___prototype831_execute takes integer i,integer a1 returns nothing
    set f__arg_integer1=a1

    call TriggerExecute(st___prototype831[i])
endfunction
function sc___prototype831_evaluate takes integer i,integer a1 returns nothing
    set f__arg_integer1=a1

    call TriggerEvaluate(st___prototype831[i])

endfunction
function sc___prototype832_execute takes integer i,integer a1,integer a2 returns nothing
    set f__arg_integer1=a1
    set f__arg_integer2=a2

    call TriggerExecute(st___prototype832[i])
endfunction
function sc___prototype832_evaluate takes integer i,integer a1,integer a2 returns integer
    set f__arg_integer1=a1
    set f__arg_integer2=a2

    call TriggerEvaluate(st___prototype832[i])
 return f__result_integer
endfunction
function sc___prototype833_execute takes integer i,integer a1 returns nothing
    set f__arg_integer1=a1

    call TriggerExecute(st___prototype833[i])
endfunction
function sc___prototype833_evaluate takes integer i,integer a1 returns boolean
    set f__arg_integer1=a1

    call TriggerEvaluate(st___prototype833[i])
 return f__result_boolean
endfunction
function sc___prototype834_execute takes integer i,integer a1,integer a2 returns nothing
    set f__arg_integer1=a1
    set f__arg_integer2=a2

    call TriggerExecute(st___prototype834[i])
endfunction
function sc___prototype834_evaluate takes integer i,integer a1,integer a2 returns boolean
    set f__arg_integer1=a1
    set f__arg_integer2=a2

    call TriggerEvaluate(st___prototype834[i])
 return f__result_boolean
endfunction
function sc___prototype835_execute takes integer i,integer a1 returns nothing
    set f__arg_integer1=a1

    call TriggerExecute(st___prototype835[i])
endfunction
function sc___prototype835_evaluate takes integer i,integer a1 returns nothing
    set f__arg_integer1=a1

    call TriggerEvaluate(st___prototype835[i])

endfunction
function sc___prototype836_execute takes integer i returns nothing

    call TriggerExecute(st___prototype836[i])
endfunction
function sc___prototype836_evaluate takes integer i returns integer

    call TriggerEvaluate(st___prototype836[i])
 return f__result_integer
endfunction
function sc___prototype837_execute takes integer i,integer a1 returns nothing
    set f__arg_integer1=a1

    call TriggerExecute(st___prototype837[i])
endfunction
function sc___prototype837_evaluate takes integer i,integer a1 returns nothing
    set f__arg_integer1=a1

    call TriggerEvaluate(st___prototype837[i])

endfunction
function sc___prototype838_execute takes integer i,integer a1,integer a2 returns nothing
    set f__arg_integer1=a1
    set f__arg_integer2=a2

    call TriggerExecute(st___prototype838[i])
endfunction
function sc___prototype838_evaluate takes integer i,integer a1,integer a2 returns nothing
    set f__arg_integer1=a1
    set f__arg_integer2=a2

    call TriggerEvaluate(st___prototype838[i])

endfunction
function sc___prototype839_execute takes integer i,integer a1 returns nothing
    set f__arg_integer1=a1

    call TriggerExecute(st___prototype839[i])
endfunction
function sc___prototype839_evaluate takes integer i,integer a1 returns nothing
    set f__arg_integer1=a1

    call TriggerEvaluate(st___prototype839[i])

endfunction
function sc___prototype840_execute takes integer i,integer a1,trigger a2 returns nothing
    set f__arg_integer1=a1
    set f__arg_trigger1=a2

    call TriggerExecute(st___prototype840[i])
endfunction
function sc___prototype840_evaluate takes integer i,integer a1,trigger a2 returns nothing
    set f__arg_integer1=a1
    set f__arg_trigger1=a2

    call TriggerEvaluate(st___prototype840[i])

endfunction
function sc___prototype841_execute takes integer i,integer a1 returns nothing
    set f__arg_integer1=a1

    call TriggerExecute(st___prototype841[i])
endfunction
function sc___prototype841_evaluate takes integer i,integer a1 returns boolean
    set f__arg_integer1=a1

    call TriggerEvaluate(st___prototype841[i])
 return f__result_boolean
endfunction
function sc___prototype842_execute takes integer i,integer a1 returns nothing
    set f__arg_integer1=a1

    call TriggerExecute(st___prototype842[i])
endfunction
function sc___prototype842_evaluate takes integer i,integer a1 returns nothing
    set f__arg_integer1=a1

    call TriggerEvaluate(st___prototype842[i])

endfunction
function sc___prototype843_execute takes integer i,integer a1 returns nothing
    set f__arg_integer1=a1

    call TriggerExecute(st___prototype843[i])
endfunction
function sc___prototype843_evaluate takes integer i,integer a1 returns nothing
    set f__arg_integer1=a1

    call TriggerEvaluate(st___prototype843[i])

endfunction
function sc___prototype844_execute takes integer i,integer a1 returns nothing
    set f__arg_integer1=a1

    call TriggerExecute(st___prototype844[i])
endfunction
function sc___prototype844_evaluate takes integer i,integer a1 returns boolean
    set f__arg_integer1=a1

    call TriggerEvaluate(st___prototype844[i])
 return f__result_boolean
endfunction
function sc___prototype845_execute takes integer i,integer a1 returns nothing
    set f__arg_integer1=a1

    call TriggerExecute(st___prototype845[i])
endfunction
function sc___prototype845_evaluate takes integer i,integer a1 returns nothing
    set f__arg_integer1=a1

    call TriggerEvaluate(st___prototype845[i])

endfunction
function sc___prototype846_execute takes integer i,integer a1 returns nothing
    set f__arg_integer1=a1

    call TriggerExecute(st___prototype846[i])
endfunction
function sc___prototype846_evaluate takes integer i,integer a1 returns nothing
    set f__arg_integer1=a1

    call TriggerEvaluate(st___prototype846[i])

endfunction
function sc___prototype847_execute takes integer i,integer a1,integer a2 returns nothing
    set f__arg_integer1=a1
    set f__arg_integer2=a2

    call TriggerExecute(st___prototype847[i])
endfunction
function sc___prototype847_evaluate takes integer i,integer a1,integer a2 returns integer
    set f__arg_integer1=a1
    set f__arg_integer2=a2

    call TriggerEvaluate(st___prototype847[i])
 return f__result_integer
endfunction
function sc___prototype848_execute takes integer i,integer a1 returns nothing
    set f__arg_integer1=a1

    call TriggerExecute(st___prototype848[i])
endfunction
function sc___prototype848_evaluate takes integer i,integer a1 returns boolean
    set f__arg_integer1=a1

    call TriggerEvaluate(st___prototype848[i])
 return f__result_boolean
endfunction
function sc___prototype849_execute takes integer i,integer a1,integer a2 returns nothing
    set f__arg_integer1=a1
    set f__arg_integer2=a2

    call TriggerExecute(st___prototype849[i])
endfunction
function sc___prototype849_evaluate takes integer i,integer a1,integer a2 returns boolean
    set f__arg_integer1=a1
    set f__arg_integer2=a2

    call TriggerEvaluate(st___prototype849[i])
 return f__result_boolean
endfunction
function sc___prototype850_execute takes integer i returns nothing

    call TriggerExecute(st___prototype850[i])
endfunction
function sc___prototype850_evaluate takes integer i returns integer

    call TriggerEvaluate(st___prototype850[i])
 return f__result_integer
endfunction

//Generated allocator of ASlkTableEntry
function s__ASlkTableEntry__allocate takes nothing returns integer
 local integer this=si__ASlkTableEntry_F
    if (this!=0) then
        set si__ASlkTableEntry_F=si__ASlkTableEntry_V[this]
    else
        set si__ASlkTableEntry_I=si__ASlkTableEntry_I+1
        set this=si__ASlkTableEntry_I
    endif
    if (this>8190) then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: ASlkTableEntry")
        return 0
    endif

    set si__ASlkTableEntry_V[this]=-1
 return this
endfunction

//Generated destructor of ASlkTableEntry
function s__ASlkTableEntry_destroy takes integer this returns nothing
    if this==null then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: ASlkTableEntry")
        return
    elseif (si__ASlkTableEntry_V[this]!=-1) then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: ASlkTableEntry")
        return
    endif
    set si__ASlkTableEntry_V[this]=si__ASlkTableEntry_F
    set si__ASlkTableEntry_F=this
endfunction

//Generated method caller for ASystemDebugger.onDestroy
function sc__ASystemDebugger_onDestroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__ASystemDebugger_onDestroy)
endfunction

//Generated allocator of ASystemDebugger
function s__ASystemDebugger__allocate takes nothing returns integer
 local integer this=si__ASystemDebugger_F
    if (this!=0) then
        set si__ASystemDebugger_F=si__ASystemDebugger_V[this]
    else
        set si__ASystemDebugger_I=si__ASystemDebugger_I+1
        set this=si__ASystemDebugger_I
    endif
    if (this>8190) then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: ASystemDebugger")
        return 0
    endif

    set si__ASystemDebugger_V[this]=-1
 return this
endfunction

//Generated destructor of ASystemDebugger
function sc__ASystemDebugger_destroy takes integer this returns nothing
    if this==null then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: ASystemDebugger")
        return
    elseif (si__ASystemDebugger_V[this]!=-1) then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: ASystemDebugger")
        return
    endif
    set f__arg_this=this
    call TriggerEvaluate(st__ASystemDebugger_onDestroy)
    set si__ASystemDebugger_V[this]=si__ASystemDebugger_F
    set si__ASystemDebugger_F=this
endfunction

//Generated method caller for AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface.enable
function sc__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_enable takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_enable[si__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_type[this]])
endfunction

//Generated method executor for AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface.enable
function sx__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_enable takes integer this returns nothing
    set f__arg_this=this
    call TriggerExecute(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_enable[si__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_type[this]])
endfunction

//Generated method caller for AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface.disable
function sc__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_disable takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_disable[si__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_type[this]])
endfunction

//Generated method executor for AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface.disable
function sx__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_disable takes integer this returns nothing
    set f__arg_this=this
    call TriggerExecute(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_disable[si__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_type[this]])
endfunction
//Generated destructor of AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface
function sc__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_destroy takes integer this returns nothing
    if this==null then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface")
        return
    elseif (si__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_V[this]!=-1) then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface")
        return
    endif
    set f__arg_this=this
    call TriggerEvaluate(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_onDestroy[si__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_type[this]])
    set si__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_V[this]=si__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_F
    set si__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_F=this
endfunction

//Generated method caller for AAbstractCharacterSystem.enable
function sc__AAbstractCharacterSystem_enable takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_enable[3])
endfunction

//Generated method caller for AAbstractCharacterSystem.disable
function sc__AAbstractCharacterSystem_disable takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_disable[3])
endfunction

//Generated method caller for AAbstractCharacterSystem.create
function sc__AAbstractCharacterSystem_create takes integer character returns integer
    set f__arg_integer1=character
    call TriggerEvaluate(st__AAbstractCharacterSystem_create)
 return f__result_integer
endfunction

//Generated allocator of AAbstractCharacterSystem
function s__AAbstractCharacterSystem__allocate takes nothing returns integer
 local integer kthis
 local integer this=si__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_F
    if (this!=0) then
        set si__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_F=si__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_V[this]
    else
        set si__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_I=si__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_I+1
        set this=si__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_I
    endif
    if (this>8190) then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: AAbstractCharacterSystem")
        return 0
    endif

    set si__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_type[this]=3
    set kthis=this

    set si__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_V[this]=-1
 return this
endfunction


//Generated allocator of AClass
function s__AClass__allocate takes nothing returns integer
 local integer this=si__AClass_F
    if (this!=0) then
        set si__AClass_F=si__AClass_V[this]
    else
        set si__AClass_I=si__AClass_I+1
        set this=si__AClass_I
    endif
    if (this>681) then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: AClass")
        return 0
    endif
    set s__AClass_abilityIconPath[this]=(this-1)*12
    set s__AClass_usedAbility[this]=(this-1)*12
    set s__AClass_descriptionLine[this]=(this-1)*5
    set si__AClass_V[this]=-1
 return this
endfunction

//Generated destructor of AClass
function s__AClass_destroy takes integer this returns nothing
    if this==null then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: AClass")
        return
    elseif (si__AClass_V[this]!=-1) then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: AClass")
        return
    endif
    set si__AClass_V[this]=si__AClass_F
    set si__AClass_F=this
endfunction

//Generated method caller for AMainWindow.getGui
function sc__AMainWindow_getGui takes integer this returns integer
    set f__arg_this=this
    call TriggerEvaluate(st__AMainWindow_getGui)
 return f__result_integer
endfunction

//Generated method caller for AMainWindow.getX
function sc__AMainWindow_getX takes integer this,real x returns real
    set f__arg_this=this
    set f__arg_real1=x
    call TriggerEvaluate(st__AMainWindow_getX)
 return f__result_real
endfunction

//Generated method caller for AMainWindow.getY
function sc__AMainWindow_getY takes integer this,real y returns real
    set f__arg_this=this
    set f__arg_real1=y
    call TriggerEvaluate(st__AMainWindow_getY)
 return f__result_real
endfunction

//Generated method caller for AMainWindow.getUser
function sc__AMainWindow_getUser takes integer this returns player
    set f__arg_this=this
    call TriggerEvaluate(st__AMainWindow_getUser)
 return f__result_player
endfunction

//Generated method caller for AMainWindow.showTooltip
function sc__AMainWindow_showTooltip takes integer this,integer usedWidget returns nothing
    set f__arg_this=this
    set f__arg_integer1=usedWidget
    call TriggerEvaluate(st__AMainWindow_showTooltip)
endfunction

//Generated method caller for AMainWindow.dockWidget
function sc__AMainWindow_dockWidget takes integer this,integer usedWidget returns integer
    set f__arg_this=this
    set f__arg_integer1=usedWidget
    call TriggerEvaluate(st__AMainWindow_dockWidget)
 return f__result_integer
endfunction

//Generated method caller for AMainWindow.undockWidget
function sc__AMainWindow_undockWidget takes integer this,integer usedWidget returns nothing
    set f__arg_this=this
    set f__arg_integer1=usedWidget
    call TriggerEvaluate(st__AMainWindow_undockWidget)
endfunction

//Generated method caller for AMainWindow.show
function sc__AMainWindow_show takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AMainWindow_show)
endfunction

//Generated method caller for AMainWindow.hide
function sc__AMainWindow_hide takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AMainWindow_hide)
endfunction

//Generated method caller for AMainWindow.onDestroy
function sc__AMainWindow_onDestroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AMainWindow_onDestroy)
endfunction

//Generated allocator of AMainWindow
function s__AMainWindow__allocate takes nothing returns integer
 local integer this=si__AMainWindow_F
    if (this!=0) then
        set si__AMainWindow_F=si__AMainWindow_V[this]
    else
        set si__AMainWindow_I=si__AMainWindow_I+1
        set this=si__AMainWindow_I
    endif
    if (this>8190) then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: AMainWindow")
        return 0
    endif

    set si__AMainWindow_V[this]=-1
 return this
endfunction

//Generated destructor of AMainWindow
function sc__AMainWindow_destroy takes integer this returns nothing
    if this==null then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: AMainWindow")
        return
    elseif (si__AMainWindow_V[this]!=-1) then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: AMainWindow")
        return
    endif
    set f__arg_this=this
    call TriggerEvaluate(st__AMainWindow_onDestroy)
    set si__AMainWindow_V[this]=si__AMainWindow_F
    set si__AMainWindow_F=this
endfunction

//Generated method caller for AWidgetContainer.debugCheckIndex
function sc__AWidgetContainer_debugCheckIndex takes integer this,integer index returns nothing
    set f__arg_this=this
    set f__arg_integer1=index
    call TriggerEvaluate(st__AWidgetContainer_debugCheckIndex)
endfunction

//Generated allocator of AWidgetContainer
function s__AWidgetContainer__allocate takes nothing returns integer
 local integer this=si__AWidgetContainer_F
    if (this!=0) then
        set si__AWidgetContainer_F=si__AWidgetContainer_V[this]
    else
        set si__AWidgetContainer_I=si__AWidgetContainer_I+1
        set this=si__AWidgetContainer_I
    endif
    if (this>80) then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: AWidgetContainer")
        return 0
    endif
    set s__AWidgetContainer_element[this]=(this-1)*100
    set si__AWidgetContainer_V[this]=-1
 return this
endfunction

//Generated destructor of AWidgetContainer
function s__AWidgetContainer_destroy takes integer this returns nothing
    if this==null then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: AWidgetContainer")
        return
    elseif (si__AWidgetContainer_V[this]!=-1) then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: AWidgetContainer")
        return
    endif
    set si__AWidgetContainer_V[this]=si__AWidgetContainer_F
    set si__AWidgetContainer_F=this
endfunction

//Generated method caller for AShrine.onDestroy
function sc__AShrine_onDestroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AShrine_onDestroy)
endfunction

//Generated allocator of AShrine
function s__AShrine__allocate takes nothing returns integer
 local integer this=si__AShrine_F
    if (this!=0) then
        set si__AShrine_F=si__AShrine_V[this]
    else
        set si__AShrine_I=si__AShrine_I+1
        set this=si__AShrine_I
    endif
    if (this>8190) then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: AShrine")
        return 0
    endif

    set si__AShrine_V[this]=-1
 return this
endfunction

//Generated destructor of AShrine
function sc__AShrine_destroy takes integer this returns nothing
    if this==null then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: AShrine")
        return
    elseif (si__AShrine_V[this]!=-1) then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: AShrine")
        return
    endif
    set f__arg_this=this
    call TriggerEvaluate(st__AShrine_onDestroy)
    set si__AShrine_V[this]=si__AShrine_F
    set si__AShrine_F=this
endfunction

//Generated method caller for AInventory.enable
function sc__AInventory_enable takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_enable[99])
endfunction

//Generated method caller for AInventory.disable
function sc__AInventory_disable takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_disable[99])
endfunction

//Generated method caller for AInventory.enableEquipment
function sc__AInventory_enableEquipment takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AInventory_enableEquipment)
endfunction

//Generated method caller for AInventory.disableEquipment
function sc__AInventory_disableEquipment takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AInventory_disableEquipment)
endfunction

//Generated method caller for AInventory.enableRucksack
function sc__AInventory_enableRucksack takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AInventory_enableRucksack)
endfunction

//Generated method caller for AInventory.disableRucksack
function sc__AInventory_disableRucksack takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AInventory_disableRucksack)
endfunction

//Generated method caller for AInventory.addItemToRucksack
function sc__AInventory_addItemToRucksack takes integer this,item usedItem,boolean fromEquipment returns nothing
    set f__arg_this=this
    set f__arg_item1=usedItem
    set f__arg_boolean1=fromEquipment
    call TriggerEvaluate(st__AInventory_addItemToRucksack)
endfunction

//Generated method caller for AInventory.getItemRucksackPage
function sc__AInventory_getItemRucksackPage takes integer this,integer index returns integer
    set f__arg_this=this
    set f__arg_integer1=index
    call TriggerEvaluate(st__AInventory_getItemRucksackPage)
 return f__result_integer
endfunction

//Generated method caller for AInventory.setEquipmentItem
function sc__AInventory_setEquipmentItem takes integer this,item usedItem,integer equipmentType,boolean add returns nothing
    set f__arg_this=this
    set f__arg_item1=usedItem
    set f__arg_integer1=equipmentType
    set f__arg_boolean1=add
    call TriggerEvaluate(st__AInventory_setEquipmentItem)
endfunction

//Generated method caller for AInventory.showEquipmentItem
function sc__AInventory_showEquipmentItem takes integer this,integer equipmentType returns nothing
    set f__arg_this=this
    set f__arg_integer1=equipmentType
    call TriggerEvaluate(st__AInventory_showEquipmentItem)
endfunction

//Generated method caller for AInventory.hideEquipmentItem
function sc__AInventory_hideEquipmentItem takes integer this,integer equipmentType returns nothing
    set f__arg_this=this
    set f__arg_integer1=equipmentType
    call TriggerEvaluate(st__AInventory_hideEquipmentItem)
endfunction

//Generated method caller for AInventory.checkEquipment
function sc__AInventory_checkEquipment takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AInventory_checkEquipment)
endfunction

//Generated method caller for AInventory.setRucksackItem
function sc__AInventory_setRucksackItem takes integer this,item usedItem,integer index,boolean add returns nothing
    set f__arg_this=this
    set f__arg_item1=usedItem
    set f__arg_integer1=index
    set f__arg_boolean1=add
    call TriggerEvaluate(st__AInventory_setRucksackItem)
endfunction

//Generated method caller for AInventory.showRucksackPage
function sc__AInventory_showRucksackPage takes integer this,integer page,boolean firstCall returns nothing
    set f__arg_this=this
    set f__arg_integer1=page
    set f__arg_boolean1=firstCall
    call TriggerEvaluate(st__AInventory_showRucksackPage)
endfunction

//Generated method caller for AInventory.hideCurrentRucksackPage
function sc__AInventory_hideCurrentRucksackPage takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AInventory_hideCurrentRucksackPage)
endfunction

//Generated method caller for AInventory.create
function sc__AInventory_create takes integer character returns integer
    set f__arg_integer1=character
    call TriggerEvaluate(st__AInventory_create)
 return f__result_integer
endfunction

//Generated method caller for AInventory.onDestroy
function sc__AInventory_onDestroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_onDestroy[99])
endfunction

//Generated allocator of AInventory
function s__AInventory__allocate takes integer character returns integer
 local integer this=sc__AAbstractCharacterSystem_create(character)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_type[this]=99
    if (si__AInventory_arrN==0) then
        set si__AInventory_arrI=si__AInventory_arrI+1
        set kthis=si__AInventory_arrI
        if (kthis>510) then
            set si__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_type[this]=2
            call sc__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_destroy(this)
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: AInventory")
            return 0
        endif
    else
        set kthis=si__AInventory_arrV[si__AInventory_arrN]
        set si__AInventory_arrN=si__AInventory_arrN-1
    endif
    set si__AInventory_arr[this]=kthis
    set s__AInventory_equipmentItemType[this]=(kthis-1)*4
    set s__AInventory_rucksackItemType[this]=(kthis-1)*16
    set s__AInventory_rucksackItemCharges[this]=(kthis-1)*16
 return this
endfunction


//Generated method caller for AWidget.getMainWindow
function sc__AWidget_getMainWindow takes integer this returns integer
    set f__arg_this=this
    call TriggerEvaluate(st__AWidget_getMainWindow)
 return f__result_integer
endfunction

//Generated method caller for AWidget.show
function sc__AWidget_show takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AWidget_show[si__AWidget_type[this]])
endfunction

//Generated method caller for AWidget.hide
function sc__AWidget_hide takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AWidget_hide[si__AWidget_type[this]])
endfunction

//Generated method caller for AWidget.enableOnHitTrigger
function sc__AWidget_enableOnHitTrigger takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AWidget_enableOnHitTrigger)
endfunction

//Generated method caller for AWidget.enableOnTrackTrigger
function sc__AWidget_enableOnTrackTrigger takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AWidget_enableOnTrackTrigger)
endfunction

//Generated method caller for AWidget.disableOnHitTrigger
function sc__AWidget_disableOnHitTrigger takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AWidget_disableOnHitTrigger)
endfunction

//Generated method caller for AWidget.disableOnTrackTrigger
function sc__AWidget_disableOnTrackTrigger takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AWidget_disableOnTrackTrigger)
endfunction

//Generated method caller for AWidget.create
function sc__AWidget_create takes integer mainWindow,real x,real y,real sizeX,real sizeY,integer onHitAction,integer onTrackAction returns integer
    set f__arg_integer1=mainWindow
    set f__arg_real1=x
    set f__arg_real2=y
    set f__arg_real3=sizeX
    set f__arg_real4=sizeY
    set f__arg_integer2=onHitAction
    set f__arg_integer3=onTrackAction
    call TriggerEvaluate(st__AWidget_create)
 return f__result_integer
endfunction

//Generated method caller for AWidget.onDestroy
function sc__AWidget_onDestroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AWidget_onDestroy[98])
endfunction

//Generated method caller for AWidget.getTrackablePathBySize
function sc__AWidget_getTrackablePathBySize takes real sizeX,real sizeY returns string
    set f__arg_real1=sizeX
    set f__arg_real2=sizeY
    call TriggerEvaluate(st__AWidget_getTrackablePathBySize)
 return f__result_string
endfunction

//Generated allocator of AWidget
function s__AWidget__allocate takes nothing returns integer
 local integer this=si__AWidget_F
    if (this!=0) then
        set si__AWidget_F=si__AWidget_V[this]
    else
        set si__AWidget_I=si__AWidget_I+1
        set this=si__AWidget_I
    endif
    if (this>8190) then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: AWidget")
        return 0
    endif

    set si__AWidget_type[this]=98
    set si__AWidget_V[this]=-1
 return this
endfunction

//Generated destructor of AWidget
function sc__AWidget_destroy takes integer this returns nothing
    if this==null then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: AWidget")
        return
    elseif (si__AWidget_V[this]!=-1) then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: AWidget")
        return
    endif
    set f__arg_this=this
    call TriggerEvaluate(st__AWidget_onDestroy[si__AWidget_type[this]])
    set si__AWidget_V[this]=si__AWidget_F
    set si__AWidget_F=this
endfunction

//Generated method caller for AVideo.createSkipTrigger
function sc__AVideo_createSkipTrigger takes nothing returns nothing
    call TriggerEvaluate(st__AVideo_createSkipTrigger)
endfunction

//Generated allocator of AVideo
function s__AVideo__allocate takes nothing returns integer
 local integer this=si__AVideo_F
    if (this!=0) then
        set si__AVideo_F=si__AVideo_V[this]
    else
        set si__AVideo_I=si__AVideo_I+1
        set this=si__AVideo_I
    endif
    if (this>8190) then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: AVideo")
        return 0
    endif

    set si__AVideo_V[this]=-1
 return this
endfunction

//Generated destructor of AVideo
function s__AVideo_destroy takes integer this returns nothing
    if this==null then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: AVideo")
        return
    elseif (si__AVideo_V[this]!=-1) then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: AVideo")
        return
    endif
    set si__AVideo_V[this]=si__AVideo_F
    set si__AVideo_F=this
endfunction

//Generated method caller for ATalk.getCharacter
function sc__ATalk_getCharacter takes integer this returns integer
    set f__arg_this=this
    call TriggerEvaluate(st__ATalk_getCharacter)
 return f__result_integer
endfunction

//Generated method caller for ATalk.speech
function sc__ATalk_speech takes integer this,string text,sound usedSound,boolean toCharacter returns nothing
    set f__arg_this=this
    set f__arg_string1=text
    set f__arg_sound1=usedSound
    set f__arg_boolean1=toCharacter
    call TriggerEvaluate(st__ATalk_speech)
endfunction

//Generated method caller for ATalk.showFirstPage
function sc__ATalk_showFirstPage takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__ATalk_showFirstPage)
endfunction

//Generated method caller for ATalk.hide
function sc__ATalk_hide takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__ATalk_hide)
endfunction

//Generated method caller for ATalk.disable
function sc__ATalk_disable takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__ATalk_disable)
endfunction

//Generated method caller for ATalk.addButton
function sc__ATalk_addButton takes integer this,string text,integer buttonAction,integer info returns nothing
    set f__arg_this=this
    set f__arg_string1=text
    set f__arg_integer1=buttonAction
    set f__arg_integer2=info
    call TriggerEvaluate(st__ATalk_addButton)
endfunction

//Generated method caller for ATalk.runButtonAction
function sc__ATalk_runButtonAction takes integer this,integer index returns nothing
    set f__arg_this=this
    set f__arg_integer1=index
    call TriggerEvaluate(st__ATalk_runButtonAction)
endfunction

//Generated method caller for ATalk.wait
function sc__ATalk_wait takes integer this,sound usedSound returns nothing
    set f__arg_this=this
    set f__arg_sound1=usedSound
    call TriggerEvaluate(st__ATalk_wait)
endfunction

//Generated method caller for ATalk.refreshView
function sc__ATalk_refreshView takes integer this,boolean toCharacter returns nothing
    set f__arg_this=this
    set f__arg_boolean1=toCharacter
    call TriggerEvaluate(st__ATalk_refreshView)
endfunction

//Generated method caller for ATalk.refreshFacings
function sc__ATalk_refreshFacings takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__ATalk_refreshFacings)
endfunction

//Generated method caller for ATalk.resetFacings
function sc__ATalk_resetFacings takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__ATalk_resetFacings)
endfunction

//Generated method caller for ATalk.resetAnimations
function sc__ATalk_resetAnimations takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__ATalk_resetAnimations)
endfunction

//Generated method caller for ATalk.onDestroy
function sc__ATalk_onDestroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__ATalk_onDestroy)
endfunction

//Generated method caller for ATalk.createSkipTrigger
function sc__ATalk_createSkipTrigger takes nothing returns nothing
    call TriggerEvaluate(st__ATalk_createSkipTrigger)
endfunction

//Generated method caller for ATalk.getTime
function sc__ATalk_getTime takes sound usedSound returns real
    set f__arg_sound1=usedSound
    call TriggerEvaluate(st__ATalk_getTime)
 return f__result_real
endfunction

//Generated allocator of ATalk
function s__ATalk__allocate takes nothing returns integer
 local integer this=si__ATalk_F
    if (this!=0) then
        set si__ATalk_F=si__ATalk_V[this]
    else
        set si__ATalk_I=si__ATalk_I+1
        set this=si__ATalk_I
    endif
    if (this>162) then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: ATalk")
        return 0
    endif
    set s__ATalk_buttonAction[this]=(this-1)*12
    set s__ATalk_buttonInfo[this]=(this-1)*12
    set s__ATalk_info[this]=(this-1)*50
    set si__ATalk_V[this]=-1
 return this
endfunction

//Generated destructor of ATalk
function sc__ATalk_destroy takes integer this returns nothing
    if this==null then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: ATalk")
        return
    elseif (si__ATalk_V[this]!=-1) then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: ATalk")
        return
    endif
    set f__arg_this=this
    call TriggerEvaluate(st__ATalk_onDestroy)
    set si__ATalk_V[this]=si__ATalk_F
    set si__ATalk_F=this
endfunction

//Generated method caller for AStructSystemsCharacterTalk___AInfo.onDestroy
function sc__AStructSystemsCharacterTalk___AInfo_onDestroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AStructSystemsCharacterTalk___AInfo_onDestroy)
endfunction

//Generated allocator of AStructSystemsCharacterTalk___AInfo
function s__AStructSystemsCharacterTalk___AInfo__allocate takes nothing returns integer
 local integer this=si__AStructSystemsCharacterTalk___AInfo_F
    if (this!=0) then
        set si__AStructSystemsCharacterTalk___AInfo_F=si__AStructSystemsCharacterTalk___AInfo_V[this]
    else
        set si__AStructSystemsCharacterTalk___AInfo_I=si__AStructSystemsCharacterTalk___AInfo_I+1
        set this=si__AStructSystemsCharacterTalk___AInfo_I
    endif
    if (this>681) then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: AStructSystemsCharacterTalk___AInfo")
        return 0
    endif
    set s__AStructSystemsCharacterTalk___AInfo_wasPressed[this]=(this-1)*12
    set si__AStructSystemsCharacterTalk___AInfo_V[this]=-1
 return this
endfunction

//Generated destructor of AStructSystemsCharacterTalk___AInfo
function sc__AStructSystemsCharacterTalk___AInfo_destroy takes integer this returns nothing
    if this==null then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: AStructSystemsCharacterTalk___AInfo")
        return
    elseif (si__AStructSystemsCharacterTalk___AInfo_V[this]!=-1) then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: AStructSystemsCharacterTalk___AInfo")
        return
    endif
    set f__arg_this=this
    call TriggerEvaluate(st__AStructSystemsCharacterTalk___AInfo_onDestroy)
    set si__AStructSystemsCharacterTalk___AInfo_V[this]=si__AStructSystemsCharacterTalk___AInfo_F
    set si__AStructSystemsCharacterTalk___AInfo_F=this
endfunction

//Generated method caller for ARevival.enable
function sc__ARevival_enable takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_enable[84])
endfunction

//Generated method caller for ARevival.disable
function sc__ARevival_disable takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_disable[84])
endfunction

//Generated method caller for ARevival.end
function sc__ARevival_end takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__ARevival_end)
endfunction

//Generated method caller for ARevival.create
function sc__ARevival_create takes integer character returns integer
    set f__arg_integer1=character
    call TriggerEvaluate(st__ARevival_create)
 return f__result_integer
endfunction

//Generated method caller for ARevival.onDestroy
function sc__ARevival_onDestroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_onDestroy[84])
endfunction

//Generated allocator of ARevival
function s__ARevival__allocate takes integer character returns integer
 local integer this=sc__AAbstractCharacterSystem_create(character)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_type[this]=84
    set kthis=this

   set s__ARevival_usedTimer[this]= null
   set s__ARevival_timerDialog[this]= null
 return this
endfunction


//Generated method caller for AMovement.enable
function sc__AMovement_enable takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_enable[81])
endfunction

//Generated method caller for AMovement.disable
function sc__AMovement_disable takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_disable[81])
endfunction

//Generated method caller for AMovement.create
function sc__AMovement_create takes integer character returns integer
    set f__arg_integer1=character
    call TriggerEvaluate(st__AMovement_create)
 return f__result_integer
endfunction

//Generated method caller for AMovement.onDestroy
function sc__AMovement_onDestroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_onDestroy[81])
endfunction

//Generated allocator of AMovement
function s__AMovement__allocate takes integer character returns integer
 local integer this=sc__AAbstractCharacterSystem_create(character)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_type[this]=81
    if (si__AMovement_arrN==0) then
        set si__AMovement_arrI=si__AMovement_arrI+1
        set kthis=si__AMovement_arrI
        if (kthis>1022) then
            set si__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_type[this]=2
            call sc__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_destroy(this)
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: AMovement")
            return 0
        endif
    else
        set kthis=si__AMovement_arrV[si__AMovement_arrN]
        set si__AMovement_arrN=si__AMovement_arrN-1
    endif
    set si__AMovement_arr[this]=kthis
    set s__AMovement_startMovementTrigger[this]=(kthis-1)*8
    set s__AMovement_state[this]=(kthis-1)*4
 return this
endfunction


//Generated method caller for AItemType.onDestroy
function sc__AItemType_onDestroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AItemType_onDestroy)
endfunction

//Generated allocator of AItemType
function s__AItemType__allocate takes nothing returns integer
 local integer this=si__AItemType_F
    if (this!=0) then
        set si__AItemType_F=si__AItemType_V[this]
    else
        set si__AItemType_I=si__AItemType_I+1
        set this=si__AItemType_I
    endif
    if (this>8190) then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: AItemType")
        return 0
    endif

    set si__AItemType_V[this]=-1
 return this
endfunction

//Generated destructor of AItemType
function sc__AItemType_destroy takes integer this returns nothing
    if this==null then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: AItemType")
        return
    elseif (si__AItemType_V[this]!=-1) then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: AItemType")
        return
    endif
    set f__arg_this=this
    call TriggerEvaluate(st__AItemType_onDestroy)
    set si__AItemType_V[this]=si__AItemType_F
    set si__AItemType_F=this
endfunction

//Generated method caller for AFocus.enable
function sc__AFocus_enable takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_enable[79])
endfunction

//Generated method caller for AFocus.disable
function sc__AFocus_disable takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_disable[79])
endfunction

//Generated method caller for AFocus.create
function sc__AFocus_create takes integer character returns integer
    set f__arg_integer1=character
    call TriggerEvaluate(st__AFocus_create)
 return f__result_integer
endfunction

//Generated method caller for AFocus.onDestroy
function sc__AFocus_onDestroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_onDestroy[79])
endfunction

//Generated allocator of AFocus
function s__AFocus__allocate takes integer character returns integer
 local integer this=sc__AAbstractCharacterSystem_create(character)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_type[this]=79
    set kthis=this

 return this
endfunction


//Generated method caller for AClassSelection.createUnit
function sc__AClassSelection_createUnit takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AClassSelection_createUnit)
endfunction

//Generated method caller for AClassSelection.onDestroy
function sc__AClassSelection_onDestroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AClassSelection_onDestroy)
endfunction

//Generated allocator of AClassSelection
function s__AClassSelection__allocate takes nothing returns integer
 local integer this=si__AClassSelection_F
    if (this!=0) then
        set si__AClassSelection_F=si__AClassSelection_V[this]
    else
        set si__AClassSelection_I=si__AClassSelection_I+1
        set this=si__AClassSelection_I
    endif
    if (this>8190) then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: AClassSelection")
        return 0
    endif

    set si__AClassSelection_V[this]=-1
 return this
endfunction

//Generated destructor of AClassSelection
function sc__AClassSelection_destroy takes integer this returns nothing
    if this==null then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: AClassSelection")
        return
    elseif (si__AClassSelection_V[this]!=-1) then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: AClassSelection")
        return
    endif
    set f__arg_this=this
    call TriggerEvaluate(st__AClassSelection_onDestroy)
    set si__AClassSelection_V[this]=si__AClassSelection_F
    set si__AClassSelection_F=this
endfunction

//Generated method caller for ACharactersScheme.onDestroy
function sc__ACharactersScheme_onDestroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__ACharactersScheme_onDestroy)
endfunction

//Generated method caller for ACharactersScheme.createMultiboard
function sc__ACharactersScheme_createMultiboard takes nothing returns nothing
    call TriggerEvaluate(st__ACharactersScheme_createMultiboard)
endfunction

//Generated method caller for ACharactersScheme.createRefreshTrigger
function sc__ACharactersScheme_createRefreshTrigger takes nothing returns nothing
    call TriggerEvaluate(st__ACharactersScheme_createRefreshTrigger)
endfunction

//Generated allocator of ACharactersScheme
function s__ACharactersScheme__allocate takes nothing returns integer
 local integer this=si__ACharactersScheme_F
    if (this!=0) then
        set si__ACharactersScheme_F=si__ACharactersScheme_V[this]
    else
        set si__ACharactersScheme_I=si__ACharactersScheme_I+1
        set this=si__ACharactersScheme_I
    endif
    if (this>8190) then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: ACharactersScheme")
        return 0
    endif

    set si__ACharactersScheme_V[this]=-1
 return this
endfunction

//Generated destructor of ACharactersScheme
function sc__ACharactersScheme_destroy takes integer this returns nothing
    if this==null then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: ACharactersScheme")
        return
    elseif (si__ACharactersScheme_V[this]!=-1) then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: ACharactersScheme")
        return
    endif
    set f__arg_this=this
    call TriggerEvaluate(st__ACharactersScheme_onDestroy)
    set si__ACharactersScheme_V[this]=si__ACharactersScheme_F
    set si__ACharactersScheme_F=this
endfunction

//Generated method caller for AAbstractQuest.setState
function sc__AAbstractQuest_setState takes integer this,integer state returns nothing
    set f__arg_this=this
    set f__arg_integer1=state
    call TriggerEvaluate(st__AAbstractQuest_setState[si__AAbstractQuest_type[this]])
endfunction

//Generated method caller for AAbstractQuest.enable
function sc__AAbstractQuest_enable takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AAbstractQuest_enable)
endfunction

//Generated method caller for AAbstractQuest.disable
function sc__AAbstractQuest_disable takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AAbstractQuest_disable)
endfunction

//Generated method caller for AAbstractQuest.enableStateTriggers
function sc__AAbstractQuest_enableStateTriggers takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AAbstractQuest_enableStateTriggers)
endfunction

//Generated method caller for AAbstractQuest.enablePingTrigger
function sc__AAbstractQuest_enablePingTrigger takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AAbstractQuest_enablePingTrigger)
endfunction

//Generated method caller for AAbstractQuest.disableStateTriggers
function sc__AAbstractQuest_disableStateTriggers takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AAbstractQuest_disableStateTriggers)
endfunction

//Generated method caller for AAbstractQuest.disablePingTrigger
function sc__AAbstractQuest_disablePingTrigger takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AAbstractQuest_disablePingTrigger)
endfunction

//Generated method caller for AAbstractQuest.displayMessage
function sc__AAbstractQuest_displayMessage takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AAbstractQuest_displayMessage)
endfunction

//Generated method caller for AAbstractQuest.distributeRewards
function sc__AAbstractQuest_distributeRewards takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AAbstractQuest_distributeRewards)
endfunction

//Generated method caller for AAbstractQuest.triggerConditionRunQuestState
function sc__AAbstractQuest_triggerConditionRunQuestState takes nothing returns boolean
    call TriggerEvaluate(st__AAbstractQuest_triggerConditionRunQuestState)
 return f__result_boolean
endfunction

//Generated method caller for AAbstractQuest.triggerActionRunQuestState
function sc__AAbstractQuest_triggerActionRunQuestState takes nothing returns nothing
    call TriggerEvaluate(st__AAbstractQuest_triggerActionRunQuestState)
endfunction

//Generated method caller for AAbstractQuest.create
function sc__AAbstractQuest_create takes integer character,string title,real pingRate returns integer
    set f__arg_integer1=character
    set f__arg_string1=title
    set f__arg_real1=pingRate
    call TriggerEvaluate(st__AAbstractQuest_create)
 return f__result_integer
endfunction

//Generated method caller for AAbstractQuest.onDestroy
function sc__AAbstractQuest_onDestroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AAbstractQuest_onDestroy[70])
endfunction

//Generated allocator of AAbstractQuest
function s__AAbstractQuest__allocate takes nothing returns integer
 local integer this=si__AAbstractQuest_F
    if (this!=0) then
        set si__AAbstractQuest_F=si__AAbstractQuest_V[this]
    else
        set si__AAbstractQuest_I=si__AAbstractQuest_I+1
        set this=si__AAbstractQuest_I
    endif
    if (this>1022) then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: AAbstractQuest")
        return 0
    endif
    set s__AAbstractQuest_stateCondition[this]=(this-1)*3
    set s__AAbstractQuest_stateAction[this]=(this-1)*3
    set s__AAbstractQuest_reward[this]=(this-1)*8
    set s__AAbstractQuest_stateTrigger[this]=(this-1)*3
    set si__AAbstractQuest_type[this]=70
    set si__AAbstractQuest_V[this]=-1
 return this
endfunction

//Generated destructor of AAbstractQuest
function sc__AAbstractQuest_destroy takes integer this returns nothing
    if this==null then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: AAbstractQuest")
        return
    elseif (si__AAbstractQuest_V[this]!=-1) then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: AAbstractQuest")
        return
    endif
    set f__arg_this=this
    call TriggerEvaluate(st__AAbstractQuest_onDestroy[si__AAbstractQuest_type[this]])
    set si__AAbstractQuest_V[this]=si__AAbstractQuest_F
    set si__AAbstractQuest_F=this
endfunction

//Generated method caller for ASpawnPoint.onDestroy
function sc__ASpawnPoint_onDestroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__ASpawnPoint_onDestroy)
endfunction

//Generated allocator of ASpawnPoint
function s__ASpawnPoint__allocate takes nothing returns integer
 local integer this=si__ASpawnPoint_F
    if (this!=0) then
        set si__ASpawnPoint_F=si__ASpawnPoint_V[this]
    else
        set si__ASpawnPoint_I=si__ASpawnPoint_I+1
        set this=si__ASpawnPoint_I
    endif
    if (this>8190) then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: ASpawnPoint")
        return 0
    endif

    set si__ASpawnPoint_V[this]=-1
 return this
endfunction

//Generated destructor of ASpawnPoint
function sc__ASpawnPoint_destroy takes integer this returns nothing
    if this==null then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: ASpawnPoint")
        return
    elseif (si__ASpawnPoint_V[this]!=-1) then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: ASpawnPoint")
        return
    endif
    set f__arg_this=this
    call TriggerEvaluate(st__ASpawnPoint_onDestroy)
    set si__ASpawnPoint_V[this]=si__ASpawnPoint_F
    set si__ASpawnPoint_F=this
endfunction

//Generated method caller for ARoutine.onDestroy
function sc__ARoutine_onDestroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__ARoutine_onDestroy)
endfunction

//Generated allocator of ARoutine
function s__ARoutine__allocate takes nothing returns integer
 local integer this=si__ARoutine_F
    if (this!=0) then
        set si__ARoutine_F=si__ARoutine_V[this]
    else
        set si__ARoutine_I=si__ARoutine_I+1
        set this=si__ARoutine_I
    endif
    if (this>8190) then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: ARoutine")
        return 0
    endif

    set si__ARoutine_V[this]=-1
 return this
endfunction

//Generated destructor of ARoutine
function sc__ARoutine_destroy takes integer this returns nothing
    if this==null then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: ARoutine")
        return
    elseif (si__ARoutine_V[this]!=-1) then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: ARoutine")
        return
    endif
    set f__arg_this=this
    call TriggerEvaluate(st__ARoutine_onDestroy)
    set si__ARoutine_V[this]=si__ARoutine_F
    set si__ARoutine_F=this
endfunction

//Generated method caller for AGui.enableSpecialShortcutTriggers
function sc__AGui_enableSpecialShortcutTriggers takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AGui_enableSpecialShortcutTriggers)
endfunction

//Generated method caller for AGui.disableSpecialShortcutTriggers
function sc__AGui_disableSpecialShortcutTriggers takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AGui_disableSpecialShortcutTriggers)
endfunction

//Generated method caller for AGui.createSpecialShortcutTrigger
function sc__AGui_createSpecialShortcutTrigger takes integer this,integer shortcut returns nothing
    set f__arg_this=this
    set f__arg_integer1=shortcut
    call TriggerEvaluate(st__AGui_createSpecialShortcutTrigger)
endfunction

//Generated method caller for AGui.createDialogButtonTrigger
function sc__AGui_createDialogButtonTrigger takes integer this,integer index returns nothing
    set f__arg_this=this
    set f__arg_integer1=index
    call TriggerEvaluate(st__AGui_createDialogButtonTrigger)
endfunction

//Generated method caller for AGui.onDestroy
function sc__AGui_onDestroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AGui_onDestroy)
endfunction

//Generated allocator of AGui
function s__AGui__allocate takes nothing returns integer
 local integer this=si__AGui_F
    if (this!=0) then
        set si__AGui_F=si__AGui_V[this]
    else
        set si__AGui_I=si__AGui_I+1
        set this=si__AGui_I
    endif
    if (this>89) then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: AGui")
        return 0
    endif
    set s__AGui_onPressShortcutAction[this]=(this-1)*91
    set s__AGui_onPressShortcutActionId[this]=(this-1)*91
    set s__AGui_specialShortcutHandleTrigger[this]=(this-1)*9
    set s__AGui_dialogButton[this]=(this-1)*12
    set s__AGui_dialogButtonTrigger[this]=(this-1)*12
    set s__AGui_dialogButtonAction[this]=(this-1)*12
    set si__AGui_V[this]=-1
 return this
endfunction

//Generated destructor of AGui
function sc__AGui_destroy takes integer this returns nothing
    if this==null then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: AGui")
        return
    elseif (si__AGui_V[this]!=-1) then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: AGui")
        return
    endif
    set f__arg_this=this
    call TriggerEvaluate(st__AGui_onDestroy)
    set si__AGui_V[this]=si__AGui_F
    set si__AGui_F=this
endfunction

//Generated method caller for AMainWindowContainer.debugCheckIndex
function sc__AMainWindowContainer_debugCheckIndex takes integer this,integer index returns nothing
    set f__arg_this=this
    set f__arg_integer1=index
    call TriggerEvaluate(st__AMainWindowContainer_debugCheckIndex)
endfunction

//Generated allocator of AMainWindowContainer
function s__AMainWindowContainer__allocate takes nothing returns integer
 local integer this=si__AMainWindowContainer_F
    if (this!=0) then
        set si__AMainWindowContainer_F=si__AMainWindowContainer_V[this]
    else
        set si__AMainWindowContainer_I=si__AMainWindowContainer_I+1
        set this=si__AMainWindowContainer_I
    endif
    if (this>2046) then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: AMainWindowContainer")
        return 0
    endif
    set s__AMainWindowContainer_element[this]=(this-1)*4
    set si__AMainWindowContainer_V[this]=-1
 return this
endfunction

//Generated destructor of AMainWindowContainer
function s__AMainWindowContainer_destroy takes integer this returns nothing
    if this==null then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: AMainWindowContainer")
        return
    elseif (si__AMainWindowContainer_V[this]!=-1) then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: AMainWindowContainer")
        return
    endif
    set si__AMainWindowContainer_V[this]=si__AMainWindowContainer_F
    set si__AMainWindowContainer_F=this
endfunction

//Generated method caller for AView.enable
function sc__AView_enable takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_enable[46])
endfunction

//Generated method caller for AView.disable
function sc__AView_disable takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_disable[46])
endfunction

//Generated method caller for AView.create
function sc__AView_create takes integer character returns integer
    set f__arg_integer1=character
    call TriggerEvaluate(st__AView_create)
 return f__result_integer
endfunction

//Generated method caller for AView.onDestroy
function sc__AView_onDestroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_onDestroy[46])
endfunction

//Generated allocator of AView
function s__AView__allocate takes integer character returns integer
 local integer this=sc__AAbstractCharacterSystem_create(character)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_type[this]=46
    set kthis=this

 return this
endfunction


//Generated method caller for ASpell.enable
function sc__ASpell_enable takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_enable[45])
endfunction

//Generated method caller for ASpell.disable
function sc__ASpell_disable takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_disable[45])
endfunction

//Generated method caller for ASpell.onDestroy
function sc__ASpell_onDestroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_onDestroy[45])
endfunction

//Generated allocator of ASpell
function s__ASpell__allocate takes integer character returns integer
 local integer this=sc__AAbstractCharacterSystem_create(character)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_type[this]=45
    set kthis=this

 return this
endfunction


//Generated method caller for AFight.enable
function sc__AFight_enable takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_enable[43])
endfunction

//Generated method caller for AFight.disable
function sc__AFight_disable takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_disable[43])
endfunction

//Generated method caller for AFight.create
function sc__AFight_create takes integer character returns integer
    set f__arg_integer1=character
    call TriggerEvaluate(st__AFight_create)
 return f__result_integer
endfunction

//Generated method caller for AFight.onDestroy
function sc__AFight_onDestroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_onDestroy[43])
endfunction

//Generated allocator of AFight
function s__AFight__allocate takes integer character returns integer
 local integer this=sc__AAbstractCharacterSystem_create(character)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_type[this]=43
    set kthis=this

 return this
endfunction


//Generated method caller for ACharacter.getUser
function sc__ACharacter_getUser takes integer this returns player
    set f__arg_this=this
    call TriggerEvaluate(st__ACharacter_getUser)
 return f__result_player
endfunction

//Generated method caller for ACharacter.getUsedUnit
function sc__ACharacter_getUsedUnit takes integer this returns unit
    set f__arg_this=this
    call TriggerEvaluate(st__ACharacter_getUsedUnit)
 return f__result_unit
endfunction

//Generated method caller for ACharacter.onDestroy
function sc__ACharacter_onDestroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__ACharacter_onDestroy)
endfunction

//Generated method caller for ACharacter.getPlayerCharacter
function sc__ACharacter_getPlayerCharacter takes player user returns integer
    set f__arg_player1=user
    call TriggerEvaluate(st__ACharacter_getPlayerCharacter)
 return f__result_integer
endfunction

//Generated allocator of ACharacter
function s__ACharacter__allocate takes nothing returns integer
 local integer this=si__ACharacter_F
    if (this!=0) then
        set si__ACharacter_F=si__ACharacter_V[this]
    else
        set si__ACharacter_I=si__ACharacter_I+1
        set this=si__ACharacter_I
    endif
    if (this>8190) then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: ACharacter")
        return 0
    endif

    set si__ACharacter_V[this]=-1
 return this
endfunction

//Generated destructor of ACharacter
function sc__ACharacter_destroy takes integer this returns nothing
    if this==null then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: ACharacter")
        return
    elseif (si__ACharacter_V[this]!=-1) then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: ACharacter")
        return
    endif
    set f__arg_this=this
    call TriggerEvaluate(st__ACharacter_onDestroy)
    set si__ACharacter_V[this]=si__ACharacter_F
    set si__ACharacter_F=this
endfunction

//Generated method caller for AMultiboardBar.onDestroy
function sc__AMultiboardBar_onDestroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AMultiboardBar_onDestroy)
endfunction

//Generated allocator of AMultiboardBar
function s__AMultiboardBar__allocate takes nothing returns integer
 local integer this=si__AMultiboardBar_F
    if (this!=0) then
        set si__AMultiboardBar_F=si__AMultiboardBar_V[this]
    else
        set si__AMultiboardBar_I=si__AMultiboardBar_I+1
        set this=si__AMultiboardBar_I
    endif
    if (this>408) then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: AMultiboardBar")
        return 0
    endif
    set s__AMultiboardBar_valueIcon[this]=(this-1)*20
    set s__AMultiboardBar_emptyIcon[this]=(this-1)*20
    set si__AMultiboardBar_V[this]=-1
 return this
endfunction

//Generated destructor of AMultiboardBar
function sc__AMultiboardBar_destroy takes integer this returns nothing
    if this==null then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: AMultiboardBar")
        return
    elseif (si__AMultiboardBar_V[this]!=-1) then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: AMultiboardBar")
        return
    endif
    set f__arg_this=this
    call TriggerEvaluate(st__AMultiboardBar_onDestroy)
    set si__AMultiboardBar_V[this]=si__AMultiboardBar_F
    set si__AMultiboardBar_F=this
endfunction

//Generated method caller for AIndicator.reset
function sc__AIndicator_reset takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AIndicator_reset)
endfunction

//Generated method caller for AIndicator.onDestroy
function sc__AIndicator_onDestroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AIndicator_onDestroy)
endfunction

//Generated allocator of AIndicator
function s__AIndicator__allocate takes nothing returns integer
 local integer this=si__AIndicator_F
    if (this!=0) then
        set si__AIndicator_F=si__AIndicator_V[this]
    else
        set si__AIndicator_I=si__AIndicator_I+1
        set this=si__AIndicator_I
    endif
    if (this>8190) then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: AIndicator")
        return 0
    endif

    set si__AIndicator_V[this]=-1
 return this
endfunction

//Generated destructor of AIndicator
function sc__AIndicator_destroy takes integer this returns nothing
    if this==null then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: AIndicator")
        return
    elseif (si__AIndicator_V[this]!=-1) then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: AIndicator")
        return
    endif
    set f__arg_this=this
    call TriggerEvaluate(st__AIndicator_onDestroy)
    set si__AIndicator_V[this]=si__AIndicator_F
    set si__AIndicator_F=this
endfunction

//Generated method caller for ACheat.onDestroy
function sc__ACheat_onDestroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__ACheat_onDestroy)
endfunction

//Generated allocator of ACheat
function s__ACheat__allocate takes nothing returns integer
 local integer this=si__ACheat_F
    if (this!=0) then
        set si__ACheat_F=si__ACheat_V[this]
    else
        set si__ACheat_I=si__ACheat_I+1
        set this=si__ACheat_I
    endif
    if (this>8190) then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: ACheat")
        return 0
    endif

    set si__ACheat_V[this]=-1
 return this
endfunction

//Generated destructor of ACheat
function sc__ACheat_destroy takes integer this returns nothing
    if this==null then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: ACheat")
        return
    elseif (si__ACheat_V[this]!=-1) then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: ACheat")
        return
    endif
    set f__arg_this=this
    call TriggerEvaluate(st__ACheat_onDestroy)
    set si__ACheat_V[this]=si__ACheat_F
    set si__ACheat_F=this
endfunction

//Generated method caller for AIntegerContainer.debugCheckIndex
function sc__AIntegerContainer_debugCheckIndex takes integer this,integer index returns nothing
    set f__arg_this=this
    set f__arg_integer1=index
    call TriggerEvaluate(st__AIntegerContainer_debugCheckIndex)
endfunction

//Generated allocator of AIntegerContainer
function s__AIntegerContainer__allocate takes nothing returns integer
 local integer this=si__AIntegerContainer_F
    if (this!=0) then
        set si__AIntegerContainer_F=si__AIntegerContainer_V[this]
    else
        set si__AIntegerContainer_I=si__AIntegerContainer_I+1
        set this=si__AIntegerContainer_I
    endif
    if (this>7) then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: AIntegerContainer")
        return 0
    endif
    set s__AIntegerContainer_element[this]=(this-1)*1000
    set si__AIntegerContainer_V[this]=-1
 return this
endfunction

//Generated destructor of AIntegerContainer
function s__AIntegerContainer_destroy takes integer this returns nothing
    if this==null then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: AIntegerContainer")
        return
    elseif (si__AIntegerContainer_V[this]!=-1) then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: AIntegerContainer")
        return
    endif
    set si__AIntegerContainer_V[this]=si__AIntegerContainer_F
    set si__AIntegerContainer_F=this
endfunction

//Generated method caller for AStructSystemsWorldWorldHashTable__AWorldHashTable.onDestroy
function sc__AStructSystemsWorldWorldHashTable__AWorldHashTable_onDestroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AStructSystemsWorldWorldHashTable__AWorldHashTable_onDestroy)
endfunction

//Generated allocator of AStructSystemsWorldWorldHashTable__AWorldHashTable
function s__AStructSystemsWorldWorldHashTable__AWorldHashTable__allocate takes nothing returns integer
 local integer this=si__AStructSystemsWorldWorldHashTable__AWorldHashTable_F
    if (this!=0) then
        set si__AStructSystemsWorldWorldHashTable__AWorldHashTable_F=si__AStructSystemsWorldWorldHashTable__AWorldHashTable_V[this]
    else
        set si__AStructSystemsWorldWorldHashTable__AWorldHashTable_I=si__AStructSystemsWorldWorldHashTable__AWorldHashTable_I+1
        set this=si__AStructSystemsWorldWorldHashTable__AWorldHashTable_I
    endif
    if (this>8190) then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: AStructSystemsWorldWorldHashTable__AWorldHashTable")
        return 0
    endif

    set si__AStructSystemsWorldWorldHashTable__AWorldHashTable_V[this]=-1
 return this
endfunction

//Generated destructor of AStructSystemsWorldWorldHashTable__AWorldHashTable
function sc__AStructSystemsWorldWorldHashTable__AWorldHashTable_destroy takes integer this returns nothing
    if this==null then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: AStructSystemsWorldWorldHashTable__AWorldHashTable")
        return
    elseif (si__AStructSystemsWorldWorldHashTable__AWorldHashTable_V[this]!=-1) then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: AStructSystemsWorldWorldHashTable__AWorldHashTable")
        return
    endif
    set f__arg_this=this
    call TriggerEvaluate(st__AStructSystemsWorldWorldHashTable__AWorldHashTable_onDestroy)
    set si__AStructSystemsWorldWorldHashTable__AWorldHashTable_V[this]=si__AStructSystemsWorldWorldHashTable__AWorldHashTable_F
    set si__AStructSystemsWorldWorldHashTable__AWorldHashTable_F=this
endfunction

//Generated method caller for AStructSystemsCharacterCharacterHashTable___ACharacterHashTable.onDestroy
function sc__AStructSystemsCharacterCharacterHashTable___ACharacterHashTable_onDestroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AStructSystemsCharacterCharacterHashTable___ACharacterHashTable_onDestroy)
endfunction

//Generated allocator of AStructSystemsCharacterCharacterHashTable___ACharacterHashTable
function s__AStructSystemsCharacterCharacterHashTable___ACharacterHashTable__allocate takes nothing returns integer
 local integer this=si__AStructSystemsCharacterCharacterHashTable___ACharacterHashTable_F
    if (this!=0) then
        set si__AStructSystemsCharacterCharacterHashTable___ACharacterHashTable_F=si__AStructSystemsCharacterCharacterHashTable___ACharacterHashTable_V[this]
    else
        set si__AStructSystemsCharacterCharacterHashTable___ACharacterHashTable_I=si__AStructSystemsCharacterCharacterHashTable___ACharacterHashTable_I+1
        set this=si__AStructSystemsCharacterCharacterHashTable___ACharacterHashTable_I
    endif
    if (this>8190) then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: AStructSystemsCharacterCharacterHashTable___ACharacterHashTable")
        return 0
    endif

    set si__AStructSystemsCharacterCharacterHashTable___ACharacterHashTable_V[this]=-1
 return this
endfunction

//Generated destructor of AStructSystemsCharacterCharacterHashTable___ACharacterHashTable
function sc__AStructSystemsCharacterCharacterHashTable___ACharacterHashTable_destroy takes integer this returns nothing
    if this==null then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: AStructSystemsCharacterCharacterHashTable___ACharacterHashTable")
        return
    elseif (si__AStructSystemsCharacterCharacterHashTable___ACharacterHashTable_V[this]!=-1) then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: AStructSystemsCharacterCharacterHashTable___ACharacterHashTable")
        return
    endif
    set f__arg_this=this
    call TriggerEvaluate(st__AStructSystemsCharacterCharacterHashTable___ACharacterHashTable_onDestroy)
    set si__AStructSystemsCharacterCharacterHashTable___ACharacterHashTable_V[this]=si__AStructSystemsCharacterCharacterHashTable___ACharacterHashTable_F
    set si__AStructSystemsCharacterCharacterHashTable___ACharacterHashTable_F=this
endfunction

//Generated method caller for AStructCoreInterfaceInterfaceHashTable___AInterfaceHashTable.onDestroy
function sc__AStructCoreInterfaceInterfaceHashTable___AInterfaceHashTable_onDestroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AStructCoreInterfaceInterfaceHashTable___AInterfaceHashTable_onDestroy)
endfunction

//Generated allocator of AStructCoreInterfaceInterfaceHashTable___AInterfaceHashTable
function s__AStructCoreInterfaceInterfaceHashTable___AInterfaceHashTable__allocate takes nothing returns integer
 local integer this=si__AStructCoreInterfaceInterfaceHashTable___AInterfaceHashTable_F
    if (this!=0) then
        set si__AStructCoreInterfaceInterfaceHashTable___AInterfaceHashTable_F=si__AStructCoreInterfaceInterfaceHashTable___AInterfaceHashTable_V[this]
    else
        set si__AStructCoreInterfaceInterfaceHashTable___AInterfaceHashTable_I=si__AStructCoreInterfaceInterfaceHashTable___AInterfaceHashTable_I+1
        set this=si__AStructCoreInterfaceInterfaceHashTable___AInterfaceHashTable_I
    endif
    if (this>8190) then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: AStructCoreInterfaceInterfaceHashTable___AInterfaceHashTable")
        return 0
    endif

    set si__AStructCoreInterfaceInterfaceHashTable___AInterfaceHashTable_V[this]=-1
 return this
endfunction

//Generated destructor of AStructCoreInterfaceInterfaceHashTable___AInterfaceHashTable
function sc__AStructCoreInterfaceInterfaceHashTable___AInterfaceHashTable_destroy takes integer this returns nothing
    if this==null then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: AStructCoreInterfaceInterfaceHashTable___AInterfaceHashTable")
        return
    elseif (si__AStructCoreInterfaceInterfaceHashTable___AInterfaceHashTable_V[this]!=-1) then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: AStructCoreInterfaceInterfaceHashTable___AInterfaceHashTable")
        return
    endif
    set f__arg_this=this
    call TriggerEvaluate(st__AStructCoreInterfaceInterfaceHashTable___AInterfaceHashTable_onDestroy)
    set si__AStructCoreInterfaceInterfaceHashTable___AInterfaceHashTable_V[this]=si__AStructCoreInterfaceInterfaceHashTable___AInterfaceHashTable_F
    set si__AStructCoreInterfaceInterfaceHashTable___AInterfaceHashTable_F=this
endfunction

//Generated method caller for AMissile.start
function sc__AMissile_start takes integer this,real x,real y,real z,real angle returns nothing
    set f__arg_this=this
    set f__arg_real1=x
    set f__arg_real2=y
    set f__arg_real3=z
    set f__arg_real4=angle
    call TriggerEvaluate(st__AMissile_start)
endfunction

//Generated method caller for AMissile.causeDamage
function sc__AMissile_causeDamage takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AMissile_causeDamage)
endfunction

//Generated method caller for AMissile.showDeathEffect
function sc__AMissile_showDeathEffect takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AMissile_showDeathEffect)
endfunction

//Generated method caller for AMissile.playDeathSound
function sc__AMissile_playDeathSound takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AMissile_playDeathSound)
endfunction

//Generated method caller for AMissile.onDestroy
function sc__AMissile_onDestroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AMissile_onDestroy)
endfunction

//Generated allocator of AMissile
function s__AMissile__allocate takes nothing returns integer
 local integer this=si__AMissile_F
    if (this!=0) then
        set si__AMissile_F=si__AMissile_V[this]
    else
        set si__AMissile_I=si__AMissile_I+1
        set this=si__AMissile_I
    endif
    if (this>8190) then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: AMissile")
        return 0
    endif

    set si__AMissile_V[this]=-1
 return this
endfunction

//Generated destructor of AMissile
function sc__AMissile_destroy takes integer this returns nothing
    if this==null then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: AMissile")
        return
    elseif (si__AMissile_V[this]!=-1) then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: AMissile")
        return
    endif
    set f__arg_this=this
    call TriggerEvaluate(st__AMissile_onDestroy)
    set si__AMissile_V[this]=si__AMissile_F
    set si__AMissile_F=this
endfunction

//Generated method caller for AMissileContainer.debugCheckIndex
function sc__AMissileContainer_debugCheckIndex takes integer this,integer index returns nothing
    set f__arg_this=this
    set f__arg_integer1=index
    call TriggerEvaluate(st__AMissileContainer_debugCheckIndex)
endfunction

//Generated allocator of AMissileContainer
function s__AMissileContainer__allocate takes nothing returns integer
 local integer this=si__AMissileContainer_F
    if (this!=0) then
        set si__AMissileContainer_F=si__AMissileContainer_V[this]
    else
        set si__AMissileContainer_I=si__AMissileContainer_I+1
        set this=si__AMissileContainer_I
    endif
    if (this>80) then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: AMissileContainer")
        return 0
    endif
    set s__AMissileContainer_element[this]=(this-1)*100
    set si__AMissileContainer_V[this]=-1
 return this
endfunction

//Generated destructor of AMissileContainer
function s__AMissileContainer_destroy takes integer this returns nothing
    if this==null then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: AMissileContainer")
        return
    elseif (si__AMissileContainer_V[this]!=-1) then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: AMissileContainer")
        return
    endif
    set si__AMissileContainer_V[this]=si__AMissileContainer_F
    set si__AMissileContainer_F=this
endfunction

//Generated method caller for AStructCoreDebugDebugHashTable__ADebugHashTable.onDestroy
function sc__AStructCoreDebugDebugHashTable__ADebugHashTable_onDestroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AStructCoreDebugDebugHashTable__ADebugHashTable_onDestroy)
endfunction

//Generated allocator of AStructCoreDebugDebugHashTable__ADebugHashTable
function s__AStructCoreDebugDebugHashTable__ADebugHashTable__allocate takes nothing returns integer
 local integer this=si__AStructCoreDebugDebugHashTable__ADebugHashTable_F
    if (this!=0) then
        set si__AStructCoreDebugDebugHashTable__ADebugHashTable_F=si__AStructCoreDebugDebugHashTable__ADebugHashTable_V[this]
    else
        set si__AStructCoreDebugDebugHashTable__ADebugHashTable_I=si__AStructCoreDebugDebugHashTable__ADebugHashTable_I+1
        set this=si__AStructCoreDebugDebugHashTable__ADebugHashTable_I
    endif
    if (this>8190) then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: AStructCoreDebugDebugHashTable__ADebugHashTable")
        return 0
    endif

    set si__AStructCoreDebugDebugHashTable__ADebugHashTable_V[this]=-1
 return this
endfunction

//Generated destructor of AStructCoreDebugDebugHashTable__ADebugHashTable
function sc__AStructCoreDebugDebugHashTable__ADebugHashTable_destroy takes integer this returns nothing
    if this==null then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: AStructCoreDebugDebugHashTable__ADebugHashTable")
        return
    elseif (si__AStructCoreDebugDebugHashTable__ADebugHashTable_V[this]!=-1) then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: AStructCoreDebugDebugHashTable__ADebugHashTable")
        return
    endif
    set f__arg_this=this
    call TriggerEvaluate(st__AStructCoreDebugDebugHashTable__ADebugHashTable_onDestroy)
    set si__AStructCoreDebugDebugHashTable__ADebugHashTable_V[this]=si__AStructCoreDebugDebugHashTable__ADebugHashTable_F
    set si__AStructCoreDebugDebugHashTable__ADebugHashTable_F=this
endfunction

//Generated method caller for AVector.getLength
function sc__AVector_getLength takes integer this returns real
    set f__arg_this=this
    call TriggerEvaluate(st__AVector_getLength)
 return f__result_real
endfunction

//Generated method caller for AVector.scale
function sc__AVector_scale takes integer this,real factor returns nothing
    set f__arg_this=this
    set f__arg_real1=factor
    call TriggerEvaluate(st__AVector_scale)
endfunction

//Generated method caller for AVector.create
function sc__AVector_create takes real x,real y,real z returns integer
    set f__arg_real1=x
    set f__arg_real2=y
    set f__arg_real3=z
    call TriggerEvaluate(st__AVector_create)
 return f__result_integer
endfunction

//Generated allocator of AVector
function s__AVector__allocate takes nothing returns integer
 local integer this=si__AVector_F
    if (this!=0) then
        set si__AVector_F=si__AVector_V[this]
    else
        set si__AVector_I=si__AVector_I+1
        set this=si__AVector_I
    endif
    if (this>8190) then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: AVector")
        return 0
    endif

    set si__AVector_V[this]=-1
 return this
endfunction

//Generated destructor of AVector
function s__AVector_destroy takes integer this returns nothing
    if this==null then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: AVector")
        return
    elseif (si__AVector_V[this]!=-1) then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: AVector")
        return
    endif
    set si__AVector_V[this]=si__AVector_F
    set si__AVector_F=this
endfunction

//Generated method caller for APoint.create
function sc__APoint_create takes real x,real y returns integer
    set f__arg_real1=x
    set f__arg_real2=y
    call TriggerEvaluate(st__APoint_create)
 return f__result_integer
endfunction

//Generated allocator of APoint
function s__APoint__allocate takes nothing returns integer
 local integer this=si__APoint_F
    if (this!=0) then
        set si__APoint_F=si__APoint_V[this]
    else
        set si__APoint_I=si__APoint_I+1
        set this=si__APoint_I
    endif
    if (this>8190) then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: APoint")
        return 0
    endif

    set si__APoint_type[this]=8
    set si__APoint_V[this]=-1
 return this
endfunction

//Generated destructor of APoint
function sc__APoint_destroy takes integer this returns nothing
    if this==null then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: APoint")
        return
    elseif (si__APoint_V[this]!=-1) then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: APoint")
        return
    endif
    set f__arg_this=this
    call TriggerEvaluate(st__APoint_onDestroy[si__APoint_type[this]])
    set si__APoint_V[this]=si__APoint_F
    set si__APoint_F=this
endfunction

//Generated allocator of AIntegerStack
function s__AIntegerStack__allocate takes nothing returns integer
 local integer this=si__AIntegerStack_F
    if (this!=0) then
        set si__AIntegerStack_F=si__AIntegerStack_V[this]
    else
        set si__AIntegerStack_I=si__AIntegerStack_I+1
        set this=si__AIntegerStack_I
    endif
    if (this>8190) then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: AIntegerStack")
        return 0
    endif

    set si__AIntegerStack_V[this]=-1
 return this
endfunction

//Generated destructor of AIntegerStack
function s__AIntegerStack_destroy takes integer this returns nothing
    if this==null then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: AIntegerStack")
        return
    elseif (si__AIntegerStack_V[this]!=-1) then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: AIntegerStack")
        return
    endif
    set si__AIntegerStack_V[this]=si__AIntegerStack_F
    set si__AIntegerStack_F=this
endfunction

//Generated allocator of AStructCoreGeneralStack__AIntegerDataNode
function s__AStructCoreGeneralStack__AIntegerDataNode__allocate takes nothing returns integer
 local integer this=si__AStructCoreGeneralStack__AIntegerDataNode_F
    if (this!=0) then
        set si__AStructCoreGeneralStack__AIntegerDataNode_F=si__AStructCoreGeneralStack__AIntegerDataNode_V[this]
    else
        set si__AStructCoreGeneralStack__AIntegerDataNode_I=si__AStructCoreGeneralStack__AIntegerDataNode_I+1
        set this=si__AStructCoreGeneralStack__AIntegerDataNode_I
    endif
    if (this>8190) then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: AStructCoreGeneralStack__AIntegerDataNode")
        return 0
    endif

    set si__AStructCoreGeneralStack__AIntegerDataNode_V[this]=-1
 return this
endfunction

//Generated destructor of AStructCoreGeneralStack__AIntegerDataNode
function s__AStructCoreGeneralStack__AIntegerDataNode_destroy takes integer this returns nothing
    if this==null then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: AStructCoreGeneralStack__AIntegerDataNode")
        return
    elseif (si__AStructCoreGeneralStack__AIntegerDataNode_V[this]!=-1) then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: AStructCoreGeneralStack__AIntegerDataNode")
        return
    endif
    set si__AStructCoreGeneralStack__AIntegerDataNode_V[this]=si__AStructCoreGeneralStack__AIntegerDataNode_F
    set si__AStructCoreGeneralStack__AIntegerDataNode_F=this
endfunction

//Generated method caller for AHashTable.onDestroy
function sc__AHashTable_onDestroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AHashTable_onDestroy)
endfunction

//Generated allocator of AHashTable
function s__AHashTable__allocate takes nothing returns integer
 local integer this=si__AHashTable_F
    if (this!=0) then
        set si__AHashTable_F=si__AHashTable_V[this]
    else
        set si__AHashTable_I=si__AHashTable_I+1
        set this=si__AHashTable_I
    endif
    if (this>8190) then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: AHashTable")
        return 0
    endif

    set si__AHashTable_V[this]=-1
 return this
endfunction

//Generated destructor of AHashTable
function sc__AHashTable_destroy takes integer this returns nothing
    if this==null then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: AHashTable")
        return
    elseif (si__AHashTable_V[this]!=-1) then
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: AHashTable")
        return
    endif
    set f__arg_this=this
    call TriggerEvaluate(st__AHashTable_onDestroy)
    set si__AHashTable_V[this]=si__AHashTable_F
    set si__AHashTable_F=this
endfunction

//Generated method caller for ACheckBox.setChecked
function sc__ACheckBox_setChecked takes integer this,boolean checked returns nothing
    set f__arg_this=this
    set f__arg_boolean1=checked
    call TriggerEvaluate(st__ACheckBox_setChecked)
endfunction

//Generated method caller for ACheckBox.isChecked
function sc__ACheckBox_isChecked takes integer this returns boolean
    set f__arg_this=this
    call TriggerEvaluate(st__ACheckBox_isChecked)
 return f__result_boolean
endfunction

//Generated method caller for ACheckBox.show
function sc__ACheckBox_show takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__ACheckBox_show[si__AWidget_type[this]])
endfunction

//Generated method caller for ACheckBox.hide
function sc__ACheckBox_hide takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__ACheckBox_hide[si__AWidget_type[this]])
endfunction

//Generated allocator of ACheckBox
function s__ACheckBox__allocate takes integer mainWindow ,real x ,real y ,real sizeX ,real sizeY ,integer onHitAction ,integer onTrackAction returns integer
 local integer this=sc__AWidget_create(mainWindow,x,y,sizeX,sizeY,onHitAction,onTrackAction)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__AWidget_type[this]=118
    set kthis=this

 return this
endfunction


//Generated allocator of ACircle
function s__ACircle__allocate takes real x ,real y returns integer
 local integer this=sc__APoint_create(x,y)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__APoint_type[this]=12
    set kthis=this

 return this
endfunction


//Generated method caller for AQuest.setState
function sc__AQuest_setState takes integer this,integer state returns nothing
    set f__arg_this=this
    set f__arg_integer1=state
    call TriggerEvaluate(st__AQuest_setState[si__AAbstractQuest_type[this]])
endfunction

//Generated method caller for AQuest.onDestroy
function sc__AQuest_onDestroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AAbstractQuest_onDestroy[103])
endfunction

//Generated allocator of AQuest
function s__AQuest__allocate takes integer character ,string title ,real pingRate returns integer
 local integer this=sc__AAbstractQuest_create(character,title,pingRate)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__AAbstractQuest_type[this]=103
    if (si__AQuest_arrN==0) then
        set si__AQuest_arrI=si__AQuest_arrI+1
        set kthis=si__AQuest_arrI
        if (kthis>1637) then
            set si__AAbstractQuest_type[this]=70
            call sc__AAbstractQuest_destroy(this)
            call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: AQuest")
            return 0
        endif
    else
        set kthis=si__AQuest_arrV[si__AQuest_arrN]
        set si__AQuest_arrN=si__AQuest_arrN-1
    endif
    set si__AQuest_arr[this]=kthis
    set s__AQuest_questItem[this]=(kthis-1)*5
 return this
endfunction


//Generated allocator of AButton
function s__AButton__allocate takes integer mainWindow ,real x ,real y ,real sizeX ,real sizeY ,integer onHitAction ,integer onTrackAction returns integer
 local integer this=sc__AWidget_create(mainWindow,x,y,sizeX,sizeY,onHitAction,onTrackAction)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__AWidget_type[this]=106
    set kthis=this

 return this
endfunction


//Generated method caller for AImage.show
function sc__AImage_show takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AImage_show[si__AWidget_type[this]])
endfunction

//Generated method caller for AImage.hide
function sc__AImage_hide takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AImage_hide[si__AWidget_type[this]])
endfunction

//Generated method caller for AImage.onDestroy
function sc__AImage_onDestroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AWidget_onDestroy[107])
endfunction

//Generated allocator of AImage
function s__AImage__allocate takes integer mainWindow ,real x ,real y ,real sizeX ,real sizeY ,integer onHitAction ,integer onTrackAction returns integer
 local integer this=sc__AWidget_create(mainWindow,x,y,sizeX,sizeY,onHitAction,onTrackAction)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__AWidget_type[this]=107
    set kthis=this

 return this
endfunction


//Generated method caller for AText.show
function sc__AText_show takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AText_show[si__AWidget_type[this]])
endfunction

//Generated method caller for AText.hide
function sc__AText_hide takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AText_hide[si__AWidget_type[this]])
endfunction

//Generated method caller for AText.onDestroy
function sc__AText_onDestroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AWidget_onDestroy[116])
endfunction

//Generated allocator of AText
function s__AText__allocate takes integer mainWindow ,real x ,real y ,real sizeX ,real sizeY ,integer onHitAction ,integer onTrackAction returns integer
 local integer this=sc__AWidget_create(mainWindow,x,y,sizeX,sizeY,onHitAction,onTrackAction)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__AWidget_type[this]=116
    set kthis=this

 return this
endfunction


//Generated method caller for AQuestItem.setState
function sc__AQuestItem_setState takes integer this,integer state returns nothing
    set f__arg_this=this
    set f__arg_integer1=state
    call TriggerEvaluate(st__AQuestItem_setState[si__AAbstractQuest_type[this]])
endfunction

//Generated method caller for AQuestItem.onDestroy
function sc__AQuestItem_onDestroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AAbstractQuest_onDestroy[117])
endfunction

//Generated allocator of AQuestItem
function s__AQuestItem__allocate takes integer character ,string title ,real pingRate returns integer
 local integer this=sc__AAbstractQuest_create(character,title,pingRate)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__AAbstractQuest_type[this]=117
    set kthis=this

 return this
endfunction


//library ACoreAi:

//library ACoreAi ends
//library ALibraryCoreEnvironmentDestructable:

	/// Creates a dummy unit which tries to harvest the filtered destructable.
	/// It should only used by filters.
	/// @author PitzerMike
	/// @return Returns true if the filtered destructable is a tree.
 function TreeFilter takes nothing returns boolean
  local player neutralPassivePlayer= Player(PLAYER_NEUTRAL_PASSIVE)
  local destructable filterDestructable= GetFilterDestructable()
  local boolean isInvulnerable= IsDestructableInvulnerable(filterDestructable)
  local unit dummy= CreateUnit(neutralPassivePlayer , 'h000' , GetWidgetX(filterDestructable) , GetWidgetY(filterDestructable) , 0)
  local boolean result= false
		call UnitAddAbility(dummy , 'Ahrl')
		if isInvulnerable then
			call SetDestructableInvulnerable(filterDestructable , false)
		endif
		set result = IssueTargetOrder(dummy , "harvest" , filterDestructable)
		call RemoveUnit(dummy)
		if isInvulnerable then
			call SetDestructableInvulnerable(filterDestructable , true)
		endif
		set neutralPassivePlayer = null
		set filterDestructable = null
		set dummy = null
		return result
	endfunction


//library ALibraryCoreEnvironmentDestructable ends
//library ALibraryCoreEnvironmentLightning:

	/// Creates a single lightning which only can be seen by the player "user".
	/// @author Tamino Dauth
	/// @param user Player who can see the lightning.
	/// @param usedCode For furhter information look into the "Splats/LightningData.slk" file of the original Warcraft 3 The Frozen Throne MPQ archives.
	/// @param x0 Start x coordinate.
	/// @param y0 Start y coordinate.
	/// @param z0 Start z coordinate.
	/// @param x1 End x coordinate.
	/// @param y1 End y coordinate.
	/// @param z1 End z coordinate.
	/// @return Returns the created lightning.
 function CreateLightningForPlayer takes player user,string usedCode,real x0,real y0,real z0,real x1,real y1,real z1 returns lightning
  local player localPlayer= GetLocalPlayer()
  local string localCode= ""
		if ( user == localPlayer ) then
			set localCode = usedCode
		endif
		set localPlayer = null
		return AddLightningEx(localCode , false , x0 , y0 , z0 , x1 , y1 , z1)
	endfunction


//library ALibraryCoreEnvironmentLightning ends
//library ALibraryCoreEnvironmentSound:

	/// Plays a sound for the player user.
	/// @author Tamino Dauth
	/// @param user Player who can hear the sound.
	/// @param usedSound Played sound.
 function PlaySoundForPlayer takes player user,sound usedSound returns nothing
  local player localPlayer= GetLocalPlayer()
		if ( user == localPlayer ) then
			call StartSound(usedSound)
		endif
		set localPlayer = null
	endfunction

	/// Plays a sound for the player user by its file path.
	/// Note that sound paths has to be preloaded before they can be played.
	/// Otherwise the sound will just be played for the second time.
	/// @author Tamino Dauth
	/// @param user Player who can hear the sound.
	/// @param soundPath Played sound file.
 function PlaySoundPathForPlayer takes player user,string soundPath returns nothing
  local sound usedSound= CreateSound(soundPath , false , false , true , 12700 , 12700 , "")
		call PlaySoundForPlayer(user , usedSound)
		call KillSoundWhenDone(usedSound)
		set usedSound = null
	endfunction

	/// Preloads a sound file by its path.
	/// Note that sound paths has to be preloaded before they can be played.
	/// Otherwise the sound will just be played for the second time.
	/// @author Tamino Dauth
	/// @param soundPath Preloaded sound file.
 function PreloadSoundPath takes string soundPath returns nothing
  local sound usedSound= CreateSound(soundPath , false , false , false , 10 , 10 , "")
		call SetSoundVolume(usedSound , 0)
		call StartSound(usedSound)
		call KillSoundWhenDone(usedSound)
		set usedSound = null
	endfunction


//library ALibraryCoreEnvironmentSound ends
//library ALibraryCoreEnvironmentSpecialEffect:

	/// Creates a single special effect which only can be seen by player @param user.
	/// @author Tamino Dauth
 function CreateSpecialEffectForPlayer takes player user,string modelPath,real x,real y returns effect
  local player localPlayer= GetLocalPlayer()
  local string localPath= ""
		if ( user == localPlayer ) then
			set localPath = modelPath
		endif
		set localPlayer = null
		return AddSpecialEffect(localPath , x , y)
	endfunction

	/// Creates a single special effect on widget's @param target attachement point @param attachPoint with model file @param model path.
	/// The created special effect is only visible to player @param user.
 function CreateSpecialEffectOnTargetForPlayer takes player user,string modelPath,widget target,string attachPoint returns effect
  local player localPlayer= GetLocalPlayer()
  local string localPath= ""
		if ( user == localPlayer ) then
			set localPath = modelPath
		endif
		set localPlayer = null
		return AddSpecialEffectTarget(localPath , target , attachPoint)
	endfunction


//library ALibraryCoreEnvironmentSpecialEffect ends
//library ALibraryCoreEnvironmentTerrain:

	/// Original description:
	/// The function SetTerrainPathable sets a single 32x32 space on the pathing grid. However, SetTerrainType sets a
	/// 128x128 space on the terrain grid, and does not change the pathing for that space. If you want to change the
	/// pathing, you'd have to change the pathing for 16 individual points per terrain space. This function rectifies 
	/// the situation by allowing you to change the pathing for a single space on the terrain grid, instead of a single 
	/// space on the pathing grid.
	/// Note: In my tests, the alignment was correct. However, there might be cases where this isn't true, so if there 
	/// is a problem I will change the numbers as needed.
	/// @author Shvegait
	/// @source http://www.wc3jass.com/
 function SetTerrainSpacePathable takes real x,real y,pathingtype pathingType,boolean flag returns nothing
  local real newX= x + 64.0
  local real newY= y + 64.0
  local integer i
  local integer j
		set newX = ( newX - ModuloReal(newX , 128.0) - 64.0 )
		set newY = ( newY - ModuloReal(newY , 128.0) + 32.0 )
		set i = 0
		loop
			exitwhen ( i > 3 )
			set j = 0
			loop
				exitwhen ( j > 3 )
				call SetTerrainPathable(( newX + i * 32.0 ) , ( newY - j * 32.0 ) , pathingType , flag)
				set j = j + 1
			endloop
			set i = i + 1
		endloop
	endfunction


//library ALibraryCoreEnvironmentTerrain ends
//library ALibraryCoreEnvironmentUnit:

	/// Adds or removes the move ability to unit @param usedUnit.
	/// @author Tamino Dauth
	/// @param usedUnit The unit which the ability is added to.
	/// @param movable If this value is true the ability will be added to unit @param usedUnit, otherwise it will be removed.
 function MakeUnitMovable takes unit usedUnit,boolean movable returns nothing
		if ( movable ) then
			call UnitAddAbility(usedUnit , 'Amov')
		else
			call UnitRemoveAbility(usedUnit , 'Amov')
		endif
	endfunction

	/// Adds or removes the attack ability to unit @param usedUnit.
	/// @author Tamino Dauth
	/// @param usedUnit The unit which the ability is added to.
	/// @param attackable If this value is true the ability will be added to unit @param usedUnit, otherwise it will be removed.
 function MakeUnitAttackable takes unit usedUnit,boolean attackable returns nothing
		if ( attackable ) then
			call UnitAddAbility(usedUnit , 'Aatk')
		else
			call UnitRemoveAbility(usedUnit , 'Aatk')
		endif
	endfunction

	/// @todo Doesn't work.
	/// @author Tamino Dauth
	/// @return Returns true if unit @param usedUnit is invulnerable.
 function IsUnitInvulnerable takes unit usedUnit returns boolean
		return ( GetUnitAbilityLevel(usedUnit , 'Bvul') > 0 )
	endfunction

	/// @todo Function does not support all alliance states (only bj_ALLIANCE_NEUTRAL, bj_ALLIANCE_ALLIED and bj_ALLIANCE_UNALLIED).
	/// @author Tamino Dauth
	/// @return Returns the alliance state of the two unit's owners.
 function GetUnitAllianceStateToUnit takes unit usedUnit,unit otherUnit returns integer
  local player usedUnitOwner= GetOwningPlayer(usedUnit)
  local player otherUnitOwner= GetOwningPlayer(otherUnit)
  local integer allianceState= - 1
		if ( IsPlayerAlly(usedUnitOwner , otherUnitOwner) ) then
			if ( GetPlayerAlliance(usedUnitOwner , otherUnitOwner , ALLIANCE_PASSIVE) ) then
				set allianceState = bj_ALLIANCE_NEUTRAL
			else
				set allianceState = bj_ALLIANCE_ALLIED
			endif
		else
			set allianceState = bj_ALLIANCE_UNALLIED
		endif
		set usedUnitOwner = null
		set otherUnitOwner = null
		return allianceState
	endfunction


//library ALibraryCoreEnvironmentUnit ends
//library ALibraryCoreGeneralConversion:


//textmacro instance: AGeneralConversionMacro("handle", "H") //Kurze Variante
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2H takes integer Integer returns handle
			return Integer
			return null
		endfunction
		
  function H2I takes handle H returns integer
			return H
			return 0
		endfunction
		
  function B2H takes boolean Boolean returns handle
			return Boolean
			return null
		endfunction
		
  function H2B takes handle H returns boolean
			return H
			return false
		endfunction
		
  function R2H takes real Real returns handle
			return Real
			return null
		endfunction
		
  function H2R takes handle H returns real
			return H
			return 0.00
		endfunction
		
  function S2H takes string String returns handle
			return String
			return null
		endfunction
		
  function H2S takes handle H returns string
			return H
			return ""
		endfunction
//end of: AGeneralConversionMacro("handle", "H") //Kurze Variante
//textmacro instance: AGeneralConversionMacro("event", "Event")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2Event takes integer Integer returns event
			return Integer
			return null
		endfunction
		
  function Event2I takes event Event returns integer
			return Event
			return 0
		endfunction
		
  function B2Event takes boolean Boolean returns event
			return Boolean
			return null
		endfunction
		
  function Event2B takes event Event returns boolean
			return Event
			return false
		endfunction
		
  function R2Event takes real Real returns event
			return Real
			return null
		endfunction
		
  function Event2R takes event Event returns real
			return Event
			return 0.00
		endfunction
		
  function S2Event takes string String returns event
			return String
			return null
		endfunction
		
  function Event2S takes event Event returns string
			return Event
			return ""
		endfunction
//end of: AGeneralConversionMacro("event", "Event")
//textmacro instance: AGeneralConversionMacro("player", "P") //Kurze Variante, da es bereits die Funktion "Player" gibt.
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2P takes integer Integer returns player
			return Integer
			return null
		endfunction
		
  function P2I takes player P returns integer
			return P
			return 0
		endfunction
		
  function B2P takes boolean Boolean returns player
			return Boolean
			return null
		endfunction
		
  function P2B takes player P returns boolean
			return P
			return false
		endfunction
		
  function R2P takes real Real returns player
			return Real
			return null
		endfunction
		
  function P2R takes player P returns real
			return P
			return 0.00
		endfunction
		
  function S2P takes string String returns player
			return String
			return null
		endfunction
		
  function P2S takes player P returns string
			return P
			return ""
		endfunction
//end of: AGeneralConversionMacro("player", "P") //Kurze Variante, da es bereits die Funktion "Player" gibt.
//textmacro instance: AGeneralConversionMacro("widget", "Widget")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2Widget takes integer Integer returns widget
			return Integer
			return null
		endfunction
		
  function Widget2I takes widget Widget returns integer
			return Widget
			return 0
		endfunction
		
  function B2Widget takes boolean Boolean returns widget
			return Boolean
			return null
		endfunction
		
  function Widget2B takes widget Widget returns boolean
			return Widget
			return false
		endfunction
		
  function R2Widget takes real Real returns widget
			return Real
			return null
		endfunction
		
  function Widget2R takes widget Widget returns real
			return Widget
			return 0.00
		endfunction
		
  function S2Widget takes string String returns widget
			return String
			return null
		endfunction
		
  function Widget2S takes widget Widget returns string
			return Widget
			return ""
		endfunction
//end of: AGeneralConversionMacro("widget", "Widget")
//textmacro instance: AGeneralConversionMacro("unit", "Unit")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2Unit takes integer Integer returns unit
			return Integer
			return null
		endfunction
		
  function Unit2I takes unit Unit returns integer
			return Unit
			return 0
		endfunction
		
  function B2Unit takes boolean Boolean returns unit
			return Boolean
			return null
		endfunction
		
  function Unit2B takes unit Unit returns boolean
			return Unit
			return false
		endfunction
		
  function R2Unit takes real Real returns unit
			return Real
			return null
		endfunction
		
  function Unit2R takes unit Unit returns real
			return Unit
			return 0.00
		endfunction
		
  function S2Unit takes string String returns unit
			return String
			return null
		endfunction
		
  function Unit2S takes unit Unit returns string
			return Unit
			return ""
		endfunction
//end of: AGeneralConversionMacro("unit", "Unit")
//textmacro instance: AGeneralConversionMacro("destructable", "Destructable")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2Destructable takes integer Integer returns destructable
			return Integer
			return null
		endfunction
		
  function Destructable2I takes destructable Destructable returns integer
			return Destructable
			return 0
		endfunction
		
  function B2Destructable takes boolean Boolean returns destructable
			return Boolean
			return null
		endfunction
		
  function Destructable2B takes destructable Destructable returns boolean
			return Destructable
			return false
		endfunction
		
  function R2Destructable takes real Real returns destructable
			return Real
			return null
		endfunction
		
  function Destructable2R takes destructable Destructable returns real
			return Destructable
			return 0.00
		endfunction
		
  function S2Destructable takes string String returns destructable
			return String
			return null
		endfunction
		
  function Destructable2S takes destructable Destructable returns string
			return Destructable
			return ""
		endfunction
//end of: AGeneralConversionMacro("destructable", "Destructable")
//textmacro instance: AGeneralConversionMacro("item", "Item")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2Item takes integer Integer returns item
			return Integer
			return null
		endfunction
		
  function Item2I takes item Item returns integer
			return Item
			return 0
		endfunction
		
  function B2Item takes boolean Boolean returns item
			return Boolean
			return null
		endfunction
		
  function Item2B takes item Item returns boolean
			return Item
			return false
		endfunction
		
  function R2Item takes real Real returns item
			return Real
			return null
		endfunction
		
  function Item2R takes item Item returns real
			return Item
			return 0.00
		endfunction
		
  function S2Item takes string String returns item
			return String
			return null
		endfunction
		
  function Item2S takes item Item returns string
			return Item
			return ""
		endfunction
//end of: AGeneralConversionMacro("item", "Item")
//textmacro instance: AGeneralConversionMacro("ability", "Ability")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2Ability takes integer Integer returns ability
			return Integer
			return null
		endfunction
		
  function Ability2I takes ability Ability returns integer
			return Ability
			return 0
		endfunction
		
  function B2Ability takes boolean Boolean returns ability
			return Boolean
			return null
		endfunction
		
  function Ability2B takes ability Ability returns boolean
			return Ability
			return false
		endfunction
		
  function R2Ability takes real Real returns ability
			return Real
			return null
		endfunction
		
  function Ability2R takes ability Ability returns real
			return Ability
			return 0.00
		endfunction
		
  function S2Ability takes string String returns ability
			return String
			return null
		endfunction
		
  function Ability2S takes ability Ability returns string
			return Ability
			return ""
		endfunction
//end of: AGeneralConversionMacro("ability", "Ability")
//textmacro instance: AGeneralConversionMacro("buff", "Buff")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2Buff takes integer Integer returns buff
			return Integer
			return null
		endfunction
		
  function Buff2I takes buff Buff returns integer
			return Buff
			return 0
		endfunction
		
  function B2Buff takes boolean Boolean returns buff
			return Boolean
			return null
		endfunction
		
  function Buff2B takes buff Buff returns boolean
			return Buff
			return false
		endfunction
		
  function R2Buff takes real Real returns buff
			return Real
			return null
		endfunction
		
  function Buff2R takes buff Buff returns real
			return Buff
			return 0.00
		endfunction
		
  function S2Buff takes string String returns buff
			return String
			return null
		endfunction
		
  function Buff2S takes buff Buff returns string
			return Buff
			return ""
		endfunction
//end of: AGeneralConversionMacro("buff", "Buff")
//textmacro instance: AGeneralConversionMacro("force", "Force")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2Force takes integer Integer returns force
			return Integer
			return null
		endfunction
		
  function Force2I takes force Force returns integer
			return Force
			return 0
		endfunction
		
  function B2Force takes boolean Boolean returns force
			return Boolean
			return null
		endfunction
		
  function Force2B takes force Force returns boolean
			return Force
			return false
		endfunction
		
  function R2Force takes real Real returns force
			return Real
			return null
		endfunction
		
  function Force2R takes force Force returns real
			return Force
			return 0.00
		endfunction
		
  function S2Force takes string String returns force
			return String
			return null
		endfunction
		
  function Force2S takes force Force returns string
			return Force
			return ""
		endfunction
//end of: AGeneralConversionMacro("force", "Force")
//textmacro instance: AGeneralConversionMacro("group", "Group")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2Group takes integer Integer returns group
			return Integer
			return null
		endfunction
		
  function Group2I takes group Group returns integer
			return Group
			return 0
		endfunction
		
  function B2Group takes boolean Boolean returns group
			return Boolean
			return null
		endfunction
		
  function Group2B takes group Group returns boolean
			return Group
			return false
		endfunction
		
  function R2Group takes real Real returns group
			return Real
			return null
		endfunction
		
  function Group2R takes group Group returns real
			return Group
			return 0.00
		endfunction
		
  function S2Group takes string String returns group
			return String
			return null
		endfunction
		
  function Group2S takes group Group returns string
			return Group
			return ""
		endfunction
//end of: AGeneralConversionMacro("group", "Group")
//textmacro instance: AGeneralConversionMacro("trigger", "Trigger")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2Trigger takes integer Integer returns trigger
			return Integer
			return null
		endfunction
		
  function Trigger2I takes trigger Trigger returns integer
			return Trigger
			return 0
		endfunction
		
  function B2Trigger takes boolean Boolean returns trigger
			return Boolean
			return null
		endfunction
		
  function Trigger2B takes trigger Trigger returns boolean
			return Trigger
			return false
		endfunction
		
  function R2Trigger takes real Real returns trigger
			return Real
			return null
		endfunction
		
  function Trigger2R takes trigger Trigger returns real
			return Trigger
			return 0.00
		endfunction
		
  function S2Trigger takes string String returns trigger
			return String
			return null
		endfunction
		
  function Trigger2S takes trigger Trigger returns string
			return Trigger
			return ""
		endfunction
//end of: AGeneralConversionMacro("trigger", "Trigger")
//textmacro instance: AGeneralConversionMacro("triggercondition", "TriggerCondition")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2TriggerCondition takes integer Integer returns triggercondition
			return Integer
			return null
		endfunction
		
  function TriggerCondition2I takes triggercondition TriggerCondition returns integer
			return TriggerCondition
			return 0
		endfunction
		
  function B2TriggerCondition takes boolean Boolean returns triggercondition
			return Boolean
			return null
		endfunction
		
  function TriggerCondition2B takes triggercondition TriggerCondition returns boolean
			return TriggerCondition
			return false
		endfunction
		
  function R2TriggerCondition takes real Real returns triggercondition
			return Real
			return null
		endfunction
		
  function TriggerCondition2R takes triggercondition TriggerCondition returns real
			return TriggerCondition
			return 0.00
		endfunction
		
  function S2TriggerCondition takes string String returns triggercondition
			return String
			return null
		endfunction
		
  function TriggerCondition2S takes triggercondition TriggerCondition returns string
			return TriggerCondition
			return ""
		endfunction
//end of: AGeneralConversionMacro("triggercondition", "TriggerCondition")
//textmacro instance: AGeneralConversionMacro("triggeraction", "TriggerAction")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2TriggerAction takes integer Integer returns triggeraction
			return Integer
			return null
		endfunction
		
  function TriggerAction2I takes triggeraction TriggerAction returns integer
			return TriggerAction
			return 0
		endfunction
		
  function B2TriggerAction takes boolean Boolean returns triggeraction
			return Boolean
			return null
		endfunction
		
  function TriggerAction2B takes triggeraction TriggerAction returns boolean
			return TriggerAction
			return false
		endfunction
		
  function R2TriggerAction takes real Real returns triggeraction
			return Real
			return null
		endfunction
		
  function TriggerAction2R takes triggeraction TriggerAction returns real
			return TriggerAction
			return 0.00
		endfunction
		
  function S2TriggerAction takes string String returns triggeraction
			return String
			return null
		endfunction
		
  function TriggerAction2S takes triggeraction TriggerAction returns string
			return TriggerAction
			return ""
		endfunction
//end of: AGeneralConversionMacro("triggeraction", "TriggerAction")
//textmacro instance: AGeneralConversionMacro("timer", "Timer")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2Timer takes integer Integer returns timer
			return Integer
			return null
		endfunction
		
  function Timer2I takes timer Timer returns integer
			return Timer
			return 0
		endfunction
		
  function B2Timer takes boolean Boolean returns timer
			return Boolean
			return null
		endfunction
		
  function Timer2B takes timer Timer returns boolean
			return Timer
			return false
		endfunction
		
  function R2Timer takes real Real returns timer
			return Real
			return null
		endfunction
		
  function Timer2R takes timer Timer returns real
			return Timer
			return 0.00
		endfunction
		
  function S2Timer takes string String returns timer
			return String
			return null
		endfunction
		
  function Timer2S takes timer Timer returns string
			return Timer
			return ""
		endfunction
//end of: AGeneralConversionMacro("timer", "Timer")
//textmacro instance: AGeneralConversionMacro("location", "L") //Kurze Variante, da es bereits die Funktion "Location" gibt.
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2L takes integer Integer returns location
			return Integer
			return null
		endfunction
		
  function L2I takes location L returns integer
			return L
			return 0
		endfunction
		
  function B2L takes boolean Boolean returns location
			return Boolean
			return null
		endfunction
		
  function L2B takes location L returns boolean
			return L
			return false
		endfunction
		
  function R2L takes real Real returns location
			return Real
			return null
		endfunction
		
  function L2R takes location L returns real
			return L
			return 0.00
		endfunction
		
  function S2L takes string String returns location
			return String
			return null
		endfunction
		
  function L2S takes location L returns string
			return L
			return ""
		endfunction
//end of: AGeneralConversionMacro("location", "L") //Kurze Variante, da es bereits die Funktion "Location" gibt.
//textmacro instance: AGeneralConversionMacro("region", "RG") //Kurze Variante, da es bereits die Funktion "Region" gibt.
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2RG takes integer Integer returns region
			return Integer
			return null
		endfunction
		
  function RG2I takes region RG returns integer
			return RG
			return 0
		endfunction
		
  function B2RG takes boolean Boolean returns region
			return Boolean
			return null
		endfunction
		
  function RG2B takes region RG returns boolean
			return RG
			return false
		endfunction
		
  function R2RG takes real Real returns region
			return Real
			return null
		endfunction
		
  function RG2R takes region RG returns real
			return RG
			return 0.00
		endfunction
		
  function S2RG takes string String returns region
			return String
			return null
		endfunction
		
  function RG2S takes region RG returns string
			return RG
			return ""
		endfunction
//end of: AGeneralConversionMacro("region", "RG") //Kurze Variante, da es bereits die Funktion "Region" gibt.
//textmacro instance: AGeneralConversionMacro("rect", "RC") //Kurze Variante, da es bereits die Funktion "Rect" gibt.
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2RC takes integer Integer returns rect
			return Integer
			return null
		endfunction
		
  function RC2I takes rect RC returns integer
			return RC
			return 0
		endfunction
		
  function B2RC takes boolean Boolean returns rect
			return Boolean
			return null
		endfunction
		
  function RC2B takes rect RC returns boolean
			return RC
			return false
		endfunction
		
  function R2RC takes real Real returns rect
			return Real
			return null
		endfunction
		
  function RC2R takes rect RC returns real
			return RC
			return 0.00
		endfunction
		
  function S2RC takes string String returns rect
			return String
			return null
		endfunction
		
  function RC2S takes rect RC returns string
			return RC
			return ""
		endfunction
//end of: AGeneralConversionMacro("rect", "RC") //Kurze Variante, da es bereits die Funktion "Rect" gibt.
//textmacro instance: AGeneralConversionMacro("boolexpr", "BooleanExpression")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2BooleanExpression takes integer Integer returns boolexpr
			return Integer
			return null
		endfunction
		
  function BooleanExpression2I takes boolexpr BooleanExpression returns integer
			return BooleanExpression
			return 0
		endfunction
		
  function B2BooleanExpression takes boolean Boolean returns boolexpr
			return Boolean
			return null
		endfunction
		
  function BooleanExpression2B takes boolexpr BooleanExpression returns boolean
			return BooleanExpression
			return false
		endfunction
		
  function R2BooleanExpression takes real Real returns boolexpr
			return Real
			return null
		endfunction
		
  function BooleanExpression2R takes boolexpr BooleanExpression returns real
			return BooleanExpression
			return 0.00
		endfunction
		
  function S2BooleanExpression takes string String returns boolexpr
			return String
			return null
		endfunction
		
  function BooleanExpression2S takes boolexpr BooleanExpression returns string
			return BooleanExpression
			return ""
		endfunction
//end of: AGeneralConversionMacro("boolexpr", "BooleanExpression")
//textmacro instance: AGeneralConversionMacro("sound", "Sound")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2Sound takes integer Integer returns sound
			return Integer
			return null
		endfunction
		
  function Sound2I takes sound Sound returns integer
			return Sound
			return 0
		endfunction
		
  function B2Sound takes boolean Boolean returns sound
			return Boolean
			return null
		endfunction
		
  function Sound2B takes sound Sound returns boolean
			return Sound
			return false
		endfunction
		
  function R2Sound takes real Real returns sound
			return Real
			return null
		endfunction
		
  function Sound2R takes sound Sound returns real
			return Sound
			return 0.00
		endfunction
		
  function S2Sound takes string String returns sound
			return String
			return null
		endfunction
		
  function Sound2S takes sound Sound returns string
			return Sound
			return ""
		endfunction
//end of: AGeneralConversionMacro("sound", "Sound")
//textmacro instance: AGeneralConversionMacro("conditionfunc", "ConditionFunction")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2ConditionFunction takes integer Integer returns conditionfunc
			return Integer
			return null
		endfunction
		
  function ConditionFunction2I takes conditionfunc ConditionFunction returns integer
			return ConditionFunction
			return 0
		endfunction
		
  function B2ConditionFunction takes boolean Boolean returns conditionfunc
			return Boolean
			return null
		endfunction
		
  function ConditionFunction2B takes conditionfunc ConditionFunction returns boolean
			return ConditionFunction
			return false
		endfunction
		
  function R2ConditionFunction takes real Real returns conditionfunc
			return Real
			return null
		endfunction
		
  function ConditionFunction2R takes conditionfunc ConditionFunction returns real
			return ConditionFunction
			return 0.00
		endfunction
		
  function S2ConditionFunction takes string String returns conditionfunc
			return String
			return null
		endfunction
		
  function ConditionFunction2S takes conditionfunc ConditionFunction returns string
			return ConditionFunction
			return ""
		endfunction
//end of: AGeneralConversionMacro("conditionfunc", "ConditionFunction")
//textmacro instance: AGeneralConversionMacro("filterfunc", "FilterFunction")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2FilterFunction takes integer Integer returns filterfunc
			return Integer
			return null
		endfunction
		
  function FilterFunction2I takes filterfunc FilterFunction returns integer
			return FilterFunction
			return 0
		endfunction
		
  function B2FilterFunction takes boolean Boolean returns filterfunc
			return Boolean
			return null
		endfunction
		
  function FilterFunction2B takes filterfunc FilterFunction returns boolean
			return FilterFunction
			return false
		endfunction
		
  function R2FilterFunction takes real Real returns filterfunc
			return Real
			return null
		endfunction
		
  function FilterFunction2R takes filterfunc FilterFunction returns real
			return FilterFunction
			return 0.00
		endfunction
		
  function S2FilterFunction takes string String returns filterfunc
			return String
			return null
		endfunction
		
  function FilterFunction2S takes filterfunc FilterFunction returns string
			return FilterFunction
			return ""
		endfunction
//end of: AGeneralConversionMacro("filterfunc", "FilterFunction")
//textmacro instance: AGeneralConversionMacro("unitpool", "UnitPool")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2UnitPool takes integer Integer returns unitpool
			return Integer
			return null
		endfunction
		
  function UnitPool2I takes unitpool UnitPool returns integer
			return UnitPool
			return 0
		endfunction
		
  function B2UnitPool takes boolean Boolean returns unitpool
			return Boolean
			return null
		endfunction
		
  function UnitPool2B takes unitpool UnitPool returns boolean
			return UnitPool
			return false
		endfunction
		
  function R2UnitPool takes real Real returns unitpool
			return Real
			return null
		endfunction
		
  function UnitPool2R takes unitpool UnitPool returns real
			return UnitPool
			return 0.00
		endfunction
		
  function S2UnitPool takes string String returns unitpool
			return String
			return null
		endfunction
		
  function UnitPool2S takes unitpool UnitPool returns string
			return UnitPool
			return ""
		endfunction
//end of: AGeneralConversionMacro("unitpool", "UnitPool")
//textmacro instance: AGeneralConversionMacro("itempool", "ItemPool")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2ItemPool takes integer Integer returns itempool
			return Integer
			return null
		endfunction
		
  function ItemPool2I takes itempool ItemPool returns integer
			return ItemPool
			return 0
		endfunction
		
  function B2ItemPool takes boolean Boolean returns itempool
			return Boolean
			return null
		endfunction
		
  function ItemPool2B takes itempool ItemPool returns boolean
			return ItemPool
			return false
		endfunction
		
  function R2ItemPool takes real Real returns itempool
			return Real
			return null
		endfunction
		
  function ItemPool2R takes itempool ItemPool returns real
			return ItemPool
			return 0.00
		endfunction
		
  function S2ItemPool takes string String returns itempool
			return String
			return null
		endfunction
		
  function ItemPool2S takes itempool ItemPool returns string
			return ItemPool
			return ""
		endfunction
//end of: AGeneralConversionMacro("itempool", "ItemPool")
//textmacro instance: AGeneralConversionMacro("race", "Race")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2Race takes integer Integer returns race
			return Integer
			return null
		endfunction
		
  function Race2I takes race Race returns integer
			return Race
			return 0
		endfunction
		
  function B2Race takes boolean Boolean returns race
			return Boolean
			return null
		endfunction
		
  function Race2B takes race Race returns boolean
			return Race
			return false
		endfunction
		
  function R2Race takes real Real returns race
			return Real
			return null
		endfunction
		
  function Race2R takes race Race returns real
			return Race
			return 0.00
		endfunction
		
  function S2Race takes string String returns race
			return String
			return null
		endfunction
		
  function Race2S takes race Race returns string
			return Race
			return ""
		endfunction
//end of: AGeneralConversionMacro("race", "Race")
//textmacro instance: AGeneralConversionMacro("alliancetype", "AllianceType")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2AllianceType takes integer Integer returns alliancetype
			return Integer
			return null
		endfunction
		
  function AllianceType2I takes alliancetype AllianceType returns integer
			return AllianceType
			return 0
		endfunction
		
  function B2AllianceType takes boolean Boolean returns alliancetype
			return Boolean
			return null
		endfunction
		
  function AllianceType2B takes alliancetype AllianceType returns boolean
			return AllianceType
			return false
		endfunction
		
  function R2AllianceType takes real Real returns alliancetype
			return Real
			return null
		endfunction
		
  function AllianceType2R takes alliancetype AllianceType returns real
			return AllianceType
			return 0.00
		endfunction
		
  function S2AllianceType takes string String returns alliancetype
			return String
			return null
		endfunction
		
  function AllianceType2S takes alliancetype AllianceType returns string
			return AllianceType
			return ""
		endfunction
//end of: AGeneralConversionMacro("alliancetype", "AllianceType")
//textmacro instance: AGeneralConversionMacro("racepreference", "RacePreference")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2RacePreference takes integer Integer returns racepreference
			return Integer
			return null
		endfunction
		
  function RacePreference2I takes racepreference RacePreference returns integer
			return RacePreference
			return 0
		endfunction
		
  function B2RacePreference takes boolean Boolean returns racepreference
			return Boolean
			return null
		endfunction
		
  function RacePreference2B takes racepreference RacePreference returns boolean
			return RacePreference
			return false
		endfunction
		
  function R2RacePreference takes real Real returns racepreference
			return Real
			return null
		endfunction
		
  function RacePreference2R takes racepreference RacePreference returns real
			return RacePreference
			return 0.00
		endfunction
		
  function S2RacePreference takes string String returns racepreference
			return String
			return null
		endfunction
		
  function RacePreference2S takes racepreference RacePreference returns string
			return RacePreference
			return ""
		endfunction
//end of: AGeneralConversionMacro("racepreference", "RacePreference")
//textmacro instance: AGeneralConversionMacro("gamestate", "GameState")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2GameState takes integer Integer returns gamestate
			return Integer
			return null
		endfunction
		
  function GameState2I takes gamestate GameState returns integer
			return GameState
			return 0
		endfunction
		
  function B2GameState takes boolean Boolean returns gamestate
			return Boolean
			return null
		endfunction
		
  function GameState2B takes gamestate GameState returns boolean
			return GameState
			return false
		endfunction
		
  function R2GameState takes real Real returns gamestate
			return Real
			return null
		endfunction
		
  function GameState2R takes gamestate GameState returns real
			return GameState
			return 0.00
		endfunction
		
  function S2GameState takes string String returns gamestate
			return String
			return null
		endfunction
		
  function GameState2S takes gamestate GameState returns string
			return GameState
			return ""
		endfunction
//end of: AGeneralConversionMacro("gamestate", "GameState")
//textmacro instance: AGeneralConversionMacro("igamestate", "IGameState")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2IGameState takes integer Integer returns igamestate
			return Integer
			return null
		endfunction
		
  function IGameState2I takes igamestate IGameState returns integer
			return IGameState
			return 0
		endfunction
		
  function B2IGameState takes boolean Boolean returns igamestate
			return Boolean
			return null
		endfunction
		
  function IGameState2B takes igamestate IGameState returns boolean
			return IGameState
			return false
		endfunction
		
  function R2IGameState takes real Real returns igamestate
			return Real
			return null
		endfunction
		
  function IGameState2R takes igamestate IGameState returns real
			return IGameState
			return 0.00
		endfunction
		
  function S2IGameState takes string String returns igamestate
			return String
			return null
		endfunction
		
  function IGameState2S takes igamestate IGameState returns string
			return IGameState
			return ""
		endfunction
//end of: AGeneralConversionMacro("igamestate", "IGameState")
//textmacro instance: AGeneralConversionMacro("fgamestate", "FGameState")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2FGameState takes integer Integer returns fgamestate
			return Integer
			return null
		endfunction
		
  function FGameState2I takes fgamestate FGameState returns integer
			return FGameState
			return 0
		endfunction
		
  function B2FGameState takes boolean Boolean returns fgamestate
			return Boolean
			return null
		endfunction
		
  function FGameState2B takes fgamestate FGameState returns boolean
			return FGameState
			return false
		endfunction
		
  function R2FGameState takes real Real returns fgamestate
			return Real
			return null
		endfunction
		
  function FGameState2R takes fgamestate FGameState returns real
			return FGameState
			return 0.00
		endfunction
		
  function S2FGameState takes string String returns fgamestate
			return String
			return null
		endfunction
		
  function FGameState2S takes fgamestate FGameState returns string
			return FGameState
			return ""
		endfunction
//end of: AGeneralConversionMacro("fgamestate", "FGameState")
//textmacro instance: AGeneralConversionMacro("playerstate", "PlayerState")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2PlayerState takes integer Integer returns playerstate
			return Integer
			return null
		endfunction
		
  function PlayerState2I takes playerstate PlayerState returns integer
			return PlayerState
			return 0
		endfunction
		
  function B2PlayerState takes boolean Boolean returns playerstate
			return Boolean
			return null
		endfunction
		
  function PlayerState2B takes playerstate PlayerState returns boolean
			return PlayerState
			return false
		endfunction
		
  function R2PlayerState takes real Real returns playerstate
			return Real
			return null
		endfunction
		
  function PlayerState2R takes playerstate PlayerState returns real
			return PlayerState
			return 0.00
		endfunction
		
  function S2PlayerState takes string String returns playerstate
			return String
			return null
		endfunction
		
  function PlayerState2S takes playerstate PlayerState returns string
			return PlayerState
			return ""
		endfunction
//end of: AGeneralConversionMacro("playerstate", "PlayerState")
//textmacro instance: AGeneralConversionMacro("playerscore", "PlayerScore")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2PlayerScore takes integer Integer returns playerscore
			return Integer
			return null
		endfunction
		
  function PlayerScore2I takes playerscore PlayerScore returns integer
			return PlayerScore
			return 0
		endfunction
		
  function B2PlayerScore takes boolean Boolean returns playerscore
			return Boolean
			return null
		endfunction
		
  function PlayerScore2B takes playerscore PlayerScore returns boolean
			return PlayerScore
			return false
		endfunction
		
  function R2PlayerScore takes real Real returns playerscore
			return Real
			return null
		endfunction
		
  function PlayerScore2R takes playerscore PlayerScore returns real
			return PlayerScore
			return 0.00
		endfunction
		
  function S2PlayerScore takes string String returns playerscore
			return String
			return null
		endfunction
		
  function PlayerScore2S takes playerscore PlayerScore returns string
			return PlayerScore
			return ""
		endfunction
//end of: AGeneralConversionMacro("playerscore", "PlayerScore")
//textmacro instance: AGeneralConversionMacro("playergameresult", "PlayerGameResult")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2PlayerGameResult takes integer Integer returns playergameresult
			return Integer
			return null
		endfunction
		
  function PlayerGameResult2I takes playergameresult PlayerGameResult returns integer
			return PlayerGameResult
			return 0
		endfunction
		
  function B2PlayerGameResult takes boolean Boolean returns playergameresult
			return Boolean
			return null
		endfunction
		
  function PlayerGameResult2B takes playergameresult PlayerGameResult returns boolean
			return PlayerGameResult
			return false
		endfunction
		
  function R2PlayerGameResult takes real Real returns playergameresult
			return Real
			return null
		endfunction
		
  function PlayerGameResult2R takes playergameresult PlayerGameResult returns real
			return PlayerGameResult
			return 0.00
		endfunction
		
  function S2PlayerGameResult takes string String returns playergameresult
			return String
			return null
		endfunction
		
  function PlayerGameResult2S takes playergameresult PlayerGameResult returns string
			return PlayerGameResult
			return ""
		endfunction
//end of: AGeneralConversionMacro("playergameresult", "PlayerGameResult")
//textmacro instance: AGeneralConversionMacro("unitstate", "UnitState")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2UnitState takes integer Integer returns unitstate
			return Integer
			return null
		endfunction
		
  function UnitState2I takes unitstate UnitState returns integer
			return UnitState
			return 0
		endfunction
		
  function B2UnitState takes boolean Boolean returns unitstate
			return Boolean
			return null
		endfunction
		
  function UnitState2B takes unitstate UnitState returns boolean
			return UnitState
			return false
		endfunction
		
  function R2UnitState takes real Real returns unitstate
			return Real
			return null
		endfunction
		
  function UnitState2R takes unitstate UnitState returns real
			return UnitState
			return 0.00
		endfunction
		
  function S2UnitState takes string String returns unitstate
			return String
			return null
		endfunction
		
  function UnitState2S takes unitstate UnitState returns string
			return UnitState
			return ""
		endfunction
//end of: AGeneralConversionMacro("unitstate", "UnitState")
//textmacro instance: AGeneralConversionMacro("aidifficulty", "AIDifficulty")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2AIDifficulty takes integer Integer returns aidifficulty
			return Integer
			return null
		endfunction
		
  function AIDifficulty2I takes aidifficulty AIDifficulty returns integer
			return AIDifficulty
			return 0
		endfunction
		
  function B2AIDifficulty takes boolean Boolean returns aidifficulty
			return Boolean
			return null
		endfunction
		
  function AIDifficulty2B takes aidifficulty AIDifficulty returns boolean
			return AIDifficulty
			return false
		endfunction
		
  function R2AIDifficulty takes real Real returns aidifficulty
			return Real
			return null
		endfunction
		
  function AIDifficulty2R takes aidifficulty AIDifficulty returns real
			return AIDifficulty
			return 0.00
		endfunction
		
  function S2AIDifficulty takes string String returns aidifficulty
			return String
			return null
		endfunction
		
  function AIDifficulty2S takes aidifficulty AIDifficulty returns string
			return AIDifficulty
			return ""
		endfunction
//end of: AGeneralConversionMacro("aidifficulty", "AIDifficulty")
//textmacro instance: AGeneralConversionMacro("eventid", "EventId")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2EventId takes integer Integer returns eventid
			return Integer
			return null
		endfunction
		
  function EventId2I takes eventid EventId returns integer
			return EventId
			return 0
		endfunction
		
  function B2EventId takes boolean Boolean returns eventid
			return Boolean
			return null
		endfunction
		
  function EventId2B takes eventid EventId returns boolean
			return EventId
			return false
		endfunction
		
  function R2EventId takes real Real returns eventid
			return Real
			return null
		endfunction
		
  function EventId2R takes eventid EventId returns real
			return EventId
			return 0.00
		endfunction
		
  function S2EventId takes string String returns eventid
			return String
			return null
		endfunction
		
  function EventId2S takes eventid EventId returns string
			return EventId
			return ""
		endfunction
//end of: AGeneralConversionMacro("eventid", "EventId")
//textmacro instance: AGeneralConversionMacro("gameevent", "GameEvent")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2GameEvent takes integer Integer returns gameevent
			return Integer
			return null
		endfunction
		
  function GameEvent2I takes gameevent GameEvent returns integer
			return GameEvent
			return 0
		endfunction
		
  function B2GameEvent takes boolean Boolean returns gameevent
			return Boolean
			return null
		endfunction
		
  function GameEvent2B takes gameevent GameEvent returns boolean
			return GameEvent
			return false
		endfunction
		
  function R2GameEvent takes real Real returns gameevent
			return Real
			return null
		endfunction
		
  function GameEvent2R takes gameevent GameEvent returns real
			return GameEvent
			return 0.00
		endfunction
		
  function S2GameEvent takes string String returns gameevent
			return String
			return null
		endfunction
		
  function GameEvent2S takes gameevent GameEvent returns string
			return GameEvent
			return ""
		endfunction
//end of: AGeneralConversionMacro("gameevent", "GameEvent")
//textmacro instance: AGeneralConversionMacro("playerevent", "PlayerEvent")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2PlayerEvent takes integer Integer returns playerevent
			return Integer
			return null
		endfunction
		
  function PlayerEvent2I takes playerevent PlayerEvent returns integer
			return PlayerEvent
			return 0
		endfunction
		
  function B2PlayerEvent takes boolean Boolean returns playerevent
			return Boolean
			return null
		endfunction
		
  function PlayerEvent2B takes playerevent PlayerEvent returns boolean
			return PlayerEvent
			return false
		endfunction
		
  function R2PlayerEvent takes real Real returns playerevent
			return Real
			return null
		endfunction
		
  function PlayerEvent2R takes playerevent PlayerEvent returns real
			return PlayerEvent
			return 0.00
		endfunction
		
  function S2PlayerEvent takes string String returns playerevent
			return String
			return null
		endfunction
		
  function PlayerEvent2S takes playerevent PlayerEvent returns string
			return PlayerEvent
			return ""
		endfunction
//end of: AGeneralConversionMacro("playerevent", "PlayerEvent")
//textmacro instance: AGeneralConversionMacro("playerunitevent", "PlayerUnitEvent")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2PlayerUnitEvent takes integer Integer returns playerunitevent
			return Integer
			return null
		endfunction
		
  function PlayerUnitEvent2I takes playerunitevent PlayerUnitEvent returns integer
			return PlayerUnitEvent
			return 0
		endfunction
		
  function B2PlayerUnitEvent takes boolean Boolean returns playerunitevent
			return Boolean
			return null
		endfunction
		
  function PlayerUnitEvent2B takes playerunitevent PlayerUnitEvent returns boolean
			return PlayerUnitEvent
			return false
		endfunction
		
  function R2PlayerUnitEvent takes real Real returns playerunitevent
			return Real
			return null
		endfunction
		
  function PlayerUnitEvent2R takes playerunitevent PlayerUnitEvent returns real
			return PlayerUnitEvent
			return 0.00
		endfunction
		
  function S2PlayerUnitEvent takes string String returns playerunitevent
			return String
			return null
		endfunction
		
  function PlayerUnitEvent2S takes playerunitevent PlayerUnitEvent returns string
			return PlayerUnitEvent
			return ""
		endfunction
//end of: AGeneralConversionMacro("playerunitevent", "PlayerUnitEvent")
//textmacro instance: AGeneralConversionMacro("unitevent", "UnitEvent")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2UnitEvent takes integer Integer returns unitevent
			return Integer
			return null
		endfunction
		
  function UnitEvent2I takes unitevent UnitEvent returns integer
			return UnitEvent
			return 0
		endfunction
		
  function B2UnitEvent takes boolean Boolean returns unitevent
			return Boolean
			return null
		endfunction
		
  function UnitEvent2B takes unitevent UnitEvent returns boolean
			return UnitEvent
			return false
		endfunction
		
  function R2UnitEvent takes real Real returns unitevent
			return Real
			return null
		endfunction
		
  function UnitEvent2R takes unitevent UnitEvent returns real
			return UnitEvent
			return 0.00
		endfunction
		
  function S2UnitEvent takes string String returns unitevent
			return String
			return null
		endfunction
		
  function UnitEvent2S takes unitevent UnitEvent returns string
			return UnitEvent
			return ""
		endfunction
//end of: AGeneralConversionMacro("unitevent", "UnitEvent")
//textmacro instance: AGeneralConversionMacro("limitop", "LimitOP")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2LimitOP takes integer Integer returns limitop
			return Integer
			return null
		endfunction
		
  function LimitOP2I takes limitop LimitOP returns integer
			return LimitOP
			return 0
		endfunction
		
  function B2LimitOP takes boolean Boolean returns limitop
			return Boolean
			return null
		endfunction
		
  function LimitOP2B takes limitop LimitOP returns boolean
			return LimitOP
			return false
		endfunction
		
  function R2LimitOP takes real Real returns limitop
			return Real
			return null
		endfunction
		
  function LimitOP2R takes limitop LimitOP returns real
			return LimitOP
			return 0.00
		endfunction
		
  function S2LimitOP takes string String returns limitop
			return String
			return null
		endfunction
		
  function LimitOP2S takes limitop LimitOP returns string
			return LimitOP
			return ""
		endfunction
//end of: AGeneralConversionMacro("limitop", "LimitOP")
//textmacro instance: AGeneralConversionMacro("widgetevent", "WidgetEvent")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2WidgetEvent takes integer Integer returns widgetevent
			return Integer
			return null
		endfunction
		
  function WidgetEvent2I takes widgetevent WidgetEvent returns integer
			return WidgetEvent
			return 0
		endfunction
		
  function B2WidgetEvent takes boolean Boolean returns widgetevent
			return Boolean
			return null
		endfunction
		
  function WidgetEvent2B takes widgetevent WidgetEvent returns boolean
			return WidgetEvent
			return false
		endfunction
		
  function R2WidgetEvent takes real Real returns widgetevent
			return Real
			return null
		endfunction
		
  function WidgetEvent2R takes widgetevent WidgetEvent returns real
			return WidgetEvent
			return 0.00
		endfunction
		
  function S2WidgetEvent takes string String returns widgetevent
			return String
			return null
		endfunction
		
  function WidgetEvent2S takes widgetevent WidgetEvent returns string
			return WidgetEvent
			return ""
		endfunction
//end of: AGeneralConversionMacro("widgetevent", "WidgetEvent")
//textmacro instance: AGeneralConversionMacro("dialogevent", "DialogEvent")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2DialogEvent takes integer Integer returns dialogevent
			return Integer
			return null
		endfunction
		
  function DialogEvent2I takes dialogevent DialogEvent returns integer
			return DialogEvent
			return 0
		endfunction
		
  function B2DialogEvent takes boolean Boolean returns dialogevent
			return Boolean
			return null
		endfunction
		
  function DialogEvent2B takes dialogevent DialogEvent returns boolean
			return DialogEvent
			return false
		endfunction
		
  function R2DialogEvent takes real Real returns dialogevent
			return Real
			return null
		endfunction
		
  function DialogEvent2R takes dialogevent DialogEvent returns real
			return DialogEvent
			return 0.00
		endfunction
		
  function S2DialogEvent takes string String returns dialogevent
			return String
			return null
		endfunction
		
  function DialogEvent2S takes dialogevent DialogEvent returns string
			return DialogEvent
			return ""
		endfunction
//end of: AGeneralConversionMacro("dialogevent", "DialogEvent")
//textmacro instance: AGeneralConversionMacro("unittype", "UnitType")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2UnitType takes integer Integer returns unittype
			return Integer
			return null
		endfunction
		
  function UnitType2I takes unittype UnitType returns integer
			return UnitType
			return 0
		endfunction
		
  function B2UnitType takes boolean Boolean returns unittype
			return Boolean
			return null
		endfunction
		
  function UnitType2B takes unittype UnitType returns boolean
			return UnitType
			return false
		endfunction
		
  function R2UnitType takes real Real returns unittype
			return Real
			return null
		endfunction
		
  function UnitType2R takes unittype UnitType returns real
			return UnitType
			return 0.00
		endfunction
		
  function S2UnitType takes string String returns unittype
			return String
			return null
		endfunction
		
  function UnitType2S takes unittype UnitType returns string
			return UnitType
			return ""
		endfunction
//end of: AGeneralConversionMacro("unittype", "UnitType")
//textmacro instance: AGeneralConversionMacro("gamespeed", "GameSpeed")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2GameSpeed takes integer Integer returns gamespeed
			return Integer
			return null
		endfunction
		
  function GameSpeed2I takes gamespeed GameSpeed returns integer
			return GameSpeed
			return 0
		endfunction
		
  function B2GameSpeed takes boolean Boolean returns gamespeed
			return Boolean
			return null
		endfunction
		
  function GameSpeed2B takes gamespeed GameSpeed returns boolean
			return GameSpeed
			return false
		endfunction
		
  function R2GameSpeed takes real Real returns gamespeed
			return Real
			return null
		endfunction
		
  function GameSpeed2R takes gamespeed GameSpeed returns real
			return GameSpeed
			return 0.00
		endfunction
		
  function S2GameSpeed takes string String returns gamespeed
			return String
			return null
		endfunction
		
  function GameSpeed2S takes gamespeed GameSpeed returns string
			return GameSpeed
			return ""
		endfunction
//end of: AGeneralConversionMacro("gamespeed", "GameSpeed")
//textmacro instance: AGeneralConversionMacro("gamedifficulty", "GameDifficulty")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2GameDifficulty takes integer Integer returns gamedifficulty
			return Integer
			return null
		endfunction
		
  function GameDifficulty2I takes gamedifficulty GameDifficulty returns integer
			return GameDifficulty
			return 0
		endfunction
		
  function B2GameDifficulty takes boolean Boolean returns gamedifficulty
			return Boolean
			return null
		endfunction
		
  function GameDifficulty2B takes gamedifficulty GameDifficulty returns boolean
			return GameDifficulty
			return false
		endfunction
		
  function R2GameDifficulty takes real Real returns gamedifficulty
			return Real
			return null
		endfunction
		
  function GameDifficulty2R takes gamedifficulty GameDifficulty returns real
			return GameDifficulty
			return 0.00
		endfunction
		
  function S2GameDifficulty takes string String returns gamedifficulty
			return String
			return null
		endfunction
		
  function GameDifficulty2S takes gamedifficulty GameDifficulty returns string
			return GameDifficulty
			return ""
		endfunction
//end of: AGeneralConversionMacro("gamedifficulty", "GameDifficulty")
//textmacro instance: AGeneralConversionMacro("gametype", "GameType")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2GameType takes integer Integer returns gametype
			return Integer
			return null
		endfunction
		
  function GameType2I takes gametype GameType returns integer
			return GameType
			return 0
		endfunction
		
  function B2GameType takes boolean Boolean returns gametype
			return Boolean
			return null
		endfunction
		
  function GameType2B takes gametype GameType returns boolean
			return GameType
			return false
		endfunction
		
  function R2GameType takes real Real returns gametype
			return Real
			return null
		endfunction
		
  function GameType2R takes gametype GameType returns real
			return GameType
			return 0.00
		endfunction
		
  function S2GameType takes string String returns gametype
			return String
			return null
		endfunction
		
  function GameType2S takes gametype GameType returns string
			return GameType
			return ""
		endfunction
//end of: AGeneralConversionMacro("gametype", "GameType")
//textmacro instance: AGeneralConversionMacro("mapflag", "MapFlag")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2MapFlag takes integer Integer returns mapflag
			return Integer
			return null
		endfunction
		
  function MapFlag2I takes mapflag MapFlag returns integer
			return MapFlag
			return 0
		endfunction
		
  function B2MapFlag takes boolean Boolean returns mapflag
			return Boolean
			return null
		endfunction
		
  function MapFlag2B takes mapflag MapFlag returns boolean
			return MapFlag
			return false
		endfunction
		
  function R2MapFlag takes real Real returns mapflag
			return Real
			return null
		endfunction
		
  function MapFlag2R takes mapflag MapFlag returns real
			return MapFlag
			return 0.00
		endfunction
		
  function S2MapFlag takes string String returns mapflag
			return String
			return null
		endfunction
		
  function MapFlag2S takes mapflag MapFlag returns string
			return MapFlag
			return ""
		endfunction
//end of: AGeneralConversionMacro("mapflag", "MapFlag")
//textmacro instance: AGeneralConversionMacro("mapvisibility", "MapVisibility")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2MapVisibility takes integer Integer returns mapvisibility
			return Integer
			return null
		endfunction
		
  function MapVisibility2I takes mapvisibility MapVisibility returns integer
			return MapVisibility
			return 0
		endfunction
		
  function B2MapVisibility takes boolean Boolean returns mapvisibility
			return Boolean
			return null
		endfunction
		
  function MapVisibility2B takes mapvisibility MapVisibility returns boolean
			return MapVisibility
			return false
		endfunction
		
  function R2MapVisibility takes real Real returns mapvisibility
			return Real
			return null
		endfunction
		
  function MapVisibility2R takes mapvisibility MapVisibility returns real
			return MapVisibility
			return 0.00
		endfunction
		
  function S2MapVisibility takes string String returns mapvisibility
			return String
			return null
		endfunction
		
  function MapVisibility2S takes mapvisibility MapVisibility returns string
			return MapVisibility
			return ""
		endfunction
//end of: AGeneralConversionMacro("mapvisibility", "MapVisibility")
//textmacro instance: AGeneralConversionMacro("mapsetting", "MapSetting")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2MapSetting takes integer Integer returns mapsetting
			return Integer
			return null
		endfunction
		
  function MapSetting2I takes mapsetting MapSetting returns integer
			return MapSetting
			return 0
		endfunction
		
  function B2MapSetting takes boolean Boolean returns mapsetting
			return Boolean
			return null
		endfunction
		
  function MapSetting2B takes mapsetting MapSetting returns boolean
			return MapSetting
			return false
		endfunction
		
  function R2MapSetting takes real Real returns mapsetting
			return Real
			return null
		endfunction
		
  function MapSetting2R takes mapsetting MapSetting returns real
			return MapSetting
			return 0.00
		endfunction
		
  function S2MapSetting takes string String returns mapsetting
			return String
			return null
		endfunction
		
  function MapSetting2S takes mapsetting MapSetting returns string
			return MapSetting
			return ""
		endfunction
//end of: AGeneralConversionMacro("mapsetting", "MapSetting")
//textmacro instance: AGeneralConversionMacro("mapdensity", "MapDensity")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2MapDensity takes integer Integer returns mapdensity
			return Integer
			return null
		endfunction
		
  function MapDensity2I takes mapdensity MapDensity returns integer
			return MapDensity
			return 0
		endfunction
		
  function B2MapDensity takes boolean Boolean returns mapdensity
			return Boolean
			return null
		endfunction
		
  function MapDensity2B takes mapdensity MapDensity returns boolean
			return MapDensity
			return false
		endfunction
		
  function R2MapDensity takes real Real returns mapdensity
			return Real
			return null
		endfunction
		
  function MapDensity2R takes mapdensity MapDensity returns real
			return MapDensity
			return 0.00
		endfunction
		
  function S2MapDensity takes string String returns mapdensity
			return String
			return null
		endfunction
		
  function MapDensity2S takes mapdensity MapDensity returns string
			return MapDensity
			return ""
		endfunction
//end of: AGeneralConversionMacro("mapdensity", "MapDensity")
//textmacro instance: AGeneralConversionMacro("mapcontrol", "MapControl")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2MapControl takes integer Integer returns mapcontrol
			return Integer
			return null
		endfunction
		
  function MapControl2I takes mapcontrol MapControl returns integer
			return MapControl
			return 0
		endfunction
		
  function B2MapControl takes boolean Boolean returns mapcontrol
			return Boolean
			return null
		endfunction
		
  function MapControl2B takes mapcontrol MapControl returns boolean
			return MapControl
			return false
		endfunction
		
  function R2MapControl takes real Real returns mapcontrol
			return Real
			return null
		endfunction
		
  function MapControl2R takes mapcontrol MapControl returns real
			return MapControl
			return 0.00
		endfunction
		
  function S2MapControl takes string String returns mapcontrol
			return String
			return null
		endfunction
		
  function MapControl2S takes mapcontrol MapControl returns string
			return MapControl
			return ""
		endfunction
//end of: AGeneralConversionMacro("mapcontrol", "MapControl")
//textmacro instance: AGeneralConversionMacro("playerslotstate", "PlayerSlotState")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2PlayerSlotState takes integer Integer returns playerslotstate
			return Integer
			return null
		endfunction
		
  function PlayerSlotState2I takes playerslotstate PlayerSlotState returns integer
			return PlayerSlotState
			return 0
		endfunction
		
  function B2PlayerSlotState takes boolean Boolean returns playerslotstate
			return Boolean
			return null
		endfunction
		
  function PlayerSlotState2B takes playerslotstate PlayerSlotState returns boolean
			return PlayerSlotState
			return false
		endfunction
		
  function R2PlayerSlotState takes real Real returns playerslotstate
			return Real
			return null
		endfunction
		
  function PlayerSlotState2R takes playerslotstate PlayerSlotState returns real
			return PlayerSlotState
			return 0.00
		endfunction
		
  function S2PlayerSlotState takes string String returns playerslotstate
			return String
			return null
		endfunction
		
  function PlayerSlotState2S takes playerslotstate PlayerSlotState returns string
			return PlayerSlotState
			return ""
		endfunction
//end of: AGeneralConversionMacro("playerslotstate", "PlayerSlotState")
//textmacro instance: AGeneralConversionMacro("volumegroup", "VolumeGroup")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2VolumeGroup takes integer Integer returns volumegroup
			return Integer
			return null
		endfunction
		
  function VolumeGroup2I takes volumegroup VolumeGroup returns integer
			return VolumeGroup
			return 0
		endfunction
		
  function B2VolumeGroup takes boolean Boolean returns volumegroup
			return Boolean
			return null
		endfunction
		
  function VolumeGroup2B takes volumegroup VolumeGroup returns boolean
			return VolumeGroup
			return false
		endfunction
		
  function R2VolumeGroup takes real Real returns volumegroup
			return Real
			return null
		endfunction
		
  function VolumeGroup2R takes volumegroup VolumeGroup returns real
			return VolumeGroup
			return 0.00
		endfunction
		
  function S2VolumeGroup takes string String returns volumegroup
			return String
			return null
		endfunction
		
  function VolumeGroup2S takes volumegroup VolumeGroup returns string
			return VolumeGroup
			return ""
		endfunction
//end of: AGeneralConversionMacro("volumegroup", "VolumeGroup")
//textmacro instance: AGeneralConversionMacro("camerafield", "CameraField")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2CameraField takes integer Integer returns camerafield
			return Integer
			return null
		endfunction
		
  function CameraField2I takes camerafield CameraField returns integer
			return CameraField
			return 0
		endfunction
		
  function B2CameraField takes boolean Boolean returns camerafield
			return Boolean
			return null
		endfunction
		
  function CameraField2B takes camerafield CameraField returns boolean
			return CameraField
			return false
		endfunction
		
  function R2CameraField takes real Real returns camerafield
			return Real
			return null
		endfunction
		
  function CameraField2R takes camerafield CameraField returns real
			return CameraField
			return 0.00
		endfunction
		
  function S2CameraField takes string String returns camerafield
			return String
			return null
		endfunction
		
  function CameraField2S takes camerafield CameraField returns string
			return CameraField
			return ""
		endfunction
//end of: AGeneralConversionMacro("camerafield", "CameraField")
//textmacro instance: AGeneralConversionMacro("camerasetup", "CameraSetup")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2CameraSetup takes integer Integer returns camerasetup
			return Integer
			return null
		endfunction
		
  function CameraSetup2I takes camerasetup CameraSetup returns integer
			return CameraSetup
			return 0
		endfunction
		
  function B2CameraSetup takes boolean Boolean returns camerasetup
			return Boolean
			return null
		endfunction
		
  function CameraSetup2B takes camerasetup CameraSetup returns boolean
			return CameraSetup
			return false
		endfunction
		
  function R2CameraSetup takes real Real returns camerasetup
			return Real
			return null
		endfunction
		
  function CameraSetup2R takes camerasetup CameraSetup returns real
			return CameraSetup
			return 0.00
		endfunction
		
  function S2CameraSetup takes string String returns camerasetup
			return String
			return null
		endfunction
		
  function CameraSetup2S takes camerasetup CameraSetup returns string
			return CameraSetup
			return ""
		endfunction
//end of: AGeneralConversionMacro("camerasetup", "CameraSetup")
//textmacro instance: AGeneralConversionMacro("playercolor", "PlayerColor")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2PlayerColor takes integer Integer returns playercolor
			return Integer
			return null
		endfunction
		
  function PlayerColor2I takes playercolor PlayerColor returns integer
			return PlayerColor
			return 0
		endfunction
		
  function B2PlayerColor takes boolean Boolean returns playercolor
			return Boolean
			return null
		endfunction
		
  function PlayerColor2B takes playercolor PlayerColor returns boolean
			return PlayerColor
			return false
		endfunction
		
  function R2PlayerColor takes real Real returns playercolor
			return Real
			return null
		endfunction
		
  function PlayerColor2R takes playercolor PlayerColor returns real
			return PlayerColor
			return 0.00
		endfunction
		
  function S2PlayerColor takes string String returns playercolor
			return String
			return null
		endfunction
		
  function PlayerColor2S takes playercolor PlayerColor returns string
			return PlayerColor
			return ""
		endfunction
//end of: AGeneralConversionMacro("playercolor", "PlayerColor")
//textmacro instance: AGeneralConversionMacro("placement", "Placement")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2Placement takes integer Integer returns placement
			return Integer
			return null
		endfunction
		
  function Placement2I takes placement Placement returns integer
			return Placement
			return 0
		endfunction
		
  function B2Placement takes boolean Boolean returns placement
			return Boolean
			return null
		endfunction
		
  function Placement2B takes placement Placement returns boolean
			return Placement
			return false
		endfunction
		
  function R2Placement takes real Real returns placement
			return Real
			return null
		endfunction
		
  function Placement2R takes placement Placement returns real
			return Placement
			return 0.00
		endfunction
		
  function S2Placement takes string String returns placement
			return String
			return null
		endfunction
		
  function Placement2S takes placement Placement returns string
			return Placement
			return ""
		endfunction
//end of: AGeneralConversionMacro("placement", "Placement")
//textmacro instance: AGeneralConversionMacro("startlocprio", "StartLocationPriority")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2StartLocationPriority takes integer Integer returns startlocprio
			return Integer
			return null
		endfunction
		
  function StartLocationPriority2I takes startlocprio StartLocationPriority returns integer
			return StartLocationPriority
			return 0
		endfunction
		
  function B2StartLocationPriority takes boolean Boolean returns startlocprio
			return Boolean
			return null
		endfunction
		
  function StartLocationPriority2B takes startlocprio StartLocationPriority returns boolean
			return StartLocationPriority
			return false
		endfunction
		
  function R2StartLocationPriority takes real Real returns startlocprio
			return Real
			return null
		endfunction
		
  function StartLocationPriority2R takes startlocprio StartLocationPriority returns real
			return StartLocationPriority
			return 0.00
		endfunction
		
  function S2StartLocationPriority takes string String returns startlocprio
			return String
			return null
		endfunction
		
  function StartLocationPriority2S takes startlocprio StartLocationPriority returns string
			return StartLocationPriority
			return ""
		endfunction
//end of: AGeneralConversionMacro("startlocprio", "StartLocationPriority")
//textmacro instance: AGeneralConversionMacro("raritycontrol", "RarityControl")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2RarityControl takes integer Integer returns raritycontrol
			return Integer
			return null
		endfunction
		
  function RarityControl2I takes raritycontrol RarityControl returns integer
			return RarityControl
			return 0
		endfunction
		
  function B2RarityControl takes boolean Boolean returns raritycontrol
			return Boolean
			return null
		endfunction
		
  function RarityControl2B takes raritycontrol RarityControl returns boolean
			return RarityControl
			return false
		endfunction
		
  function R2RarityControl takes real Real returns raritycontrol
			return Real
			return null
		endfunction
		
  function RarityControl2R takes raritycontrol RarityControl returns real
			return RarityControl
			return 0.00
		endfunction
		
  function S2RarityControl takes string String returns raritycontrol
			return String
			return null
		endfunction
		
  function RarityControl2S takes raritycontrol RarityControl returns string
			return RarityControl
			return ""
		endfunction
//end of: AGeneralConversionMacro("raritycontrol", "RarityControl")
//textmacro instance: AGeneralConversionMacro("blendmode", "BlendMode")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2BlendMode takes integer Integer returns blendmode
			return Integer
			return null
		endfunction
		
  function BlendMode2I takes blendmode BlendMode returns integer
			return BlendMode
			return 0
		endfunction
		
  function B2BlendMode takes boolean Boolean returns blendmode
			return Boolean
			return null
		endfunction
		
  function BlendMode2B takes blendmode BlendMode returns boolean
			return BlendMode
			return false
		endfunction
		
  function R2BlendMode takes real Real returns blendmode
			return Real
			return null
		endfunction
		
  function BlendMode2R takes blendmode BlendMode returns real
			return BlendMode
			return 0.00
		endfunction
		
  function S2BlendMode takes string String returns blendmode
			return String
			return null
		endfunction
		
  function BlendMode2S takes blendmode BlendMode returns string
			return BlendMode
			return ""
		endfunction
//end of: AGeneralConversionMacro("blendmode", "BlendMode")
//textmacro instance: AGeneralConversionMacro("texmapflags", "TextureMapFlags")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2TextureMapFlags takes integer Integer returns texmapflags
			return Integer
			return null
		endfunction
		
  function TextureMapFlags2I takes texmapflags TextureMapFlags returns integer
			return TextureMapFlags
			return 0
		endfunction
		
  function B2TextureMapFlags takes boolean Boolean returns texmapflags
			return Boolean
			return null
		endfunction
		
  function TextureMapFlags2B takes texmapflags TextureMapFlags returns boolean
			return TextureMapFlags
			return false
		endfunction
		
  function R2TextureMapFlags takes real Real returns texmapflags
			return Real
			return null
		endfunction
		
  function TextureMapFlags2R takes texmapflags TextureMapFlags returns real
			return TextureMapFlags
			return 0.00
		endfunction
		
  function S2TextureMapFlags takes string String returns texmapflags
			return String
			return null
		endfunction
		
  function TextureMapFlags2S takes texmapflags TextureMapFlags returns string
			return TextureMapFlags
			return ""
		endfunction
//end of: AGeneralConversionMacro("texmapflags", "TextureMapFlags")
//textmacro instance: AGeneralConversionMacro("effect", "Effect")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2Effect takes integer Integer returns effect
			return Integer
			return null
		endfunction
		
  function Effect2I takes effect Effect returns integer
			return Effect
			return 0
		endfunction
		
  function B2Effect takes boolean Boolean returns effect
			return Boolean
			return null
		endfunction
		
  function Effect2B takes effect Effect returns boolean
			return Effect
			return false
		endfunction
		
  function R2Effect takes real Real returns effect
			return Real
			return null
		endfunction
		
  function Effect2R takes effect Effect returns real
			return Effect
			return 0.00
		endfunction
		
  function S2Effect takes string String returns effect
			return String
			return null
		endfunction
		
  function Effect2S takes effect Effect returns string
			return Effect
			return ""
		endfunction
//end of: AGeneralConversionMacro("effect", "Effect")
//textmacro instance: AGeneralConversionMacro("effecttype", "EffectType")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2EffectType takes integer Integer returns effecttype
			return Integer
			return null
		endfunction
		
  function EffectType2I takes effecttype EffectType returns integer
			return EffectType
			return 0
		endfunction
		
  function B2EffectType takes boolean Boolean returns effecttype
			return Boolean
			return null
		endfunction
		
  function EffectType2B takes effecttype EffectType returns boolean
			return EffectType
			return false
		endfunction
		
  function R2EffectType takes real Real returns effecttype
			return Real
			return null
		endfunction
		
  function EffectType2R takes effecttype EffectType returns real
			return EffectType
			return 0.00
		endfunction
		
  function S2EffectType takes string String returns effecttype
			return String
			return null
		endfunction
		
  function EffectType2S takes effecttype EffectType returns string
			return EffectType
			return ""
		endfunction
//end of: AGeneralConversionMacro("effecttype", "EffectType")
//textmacro instance: AGeneralConversionMacro("weathereffect", "WeatherEffect")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2WeatherEffect takes integer Integer returns weathereffect
			return Integer
			return null
		endfunction
		
  function WeatherEffect2I takes weathereffect WeatherEffect returns integer
			return WeatherEffect
			return 0
		endfunction
		
  function B2WeatherEffect takes boolean Boolean returns weathereffect
			return Boolean
			return null
		endfunction
		
  function WeatherEffect2B takes weathereffect WeatherEffect returns boolean
			return WeatherEffect
			return false
		endfunction
		
  function R2WeatherEffect takes real Real returns weathereffect
			return Real
			return null
		endfunction
		
  function WeatherEffect2R takes weathereffect WeatherEffect returns real
			return WeatherEffect
			return 0.00
		endfunction
		
  function S2WeatherEffect takes string String returns weathereffect
			return String
			return null
		endfunction
		
  function WeatherEffect2S takes weathereffect WeatherEffect returns string
			return WeatherEffect
			return ""
		endfunction
//end of: AGeneralConversionMacro("weathereffect", "WeatherEffect")
//textmacro instance: AGeneralConversionMacro("terraindeformation", "TerrainDeformation")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2TerrainDeformation takes integer Integer returns terraindeformation
			return Integer
			return null
		endfunction
		
  function TerrainDeformation2I takes terraindeformation TerrainDeformation returns integer
			return TerrainDeformation
			return 0
		endfunction
		
  function B2TerrainDeformation takes boolean Boolean returns terraindeformation
			return Boolean
			return null
		endfunction
		
  function TerrainDeformation2B takes terraindeformation TerrainDeformation returns boolean
			return TerrainDeformation
			return false
		endfunction
		
  function R2TerrainDeformation takes real Real returns terraindeformation
			return Real
			return null
		endfunction
		
  function TerrainDeformation2R takes terraindeformation TerrainDeformation returns real
			return TerrainDeformation
			return 0.00
		endfunction
		
  function S2TerrainDeformation takes string String returns terraindeformation
			return String
			return null
		endfunction
		
  function TerrainDeformation2S takes terraindeformation TerrainDeformation returns string
			return TerrainDeformation
			return ""
		endfunction
//end of: AGeneralConversionMacro("terraindeformation", "TerrainDeformation")
//textmacro instance: AGeneralConversionMacro("fogstate", "FogState")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2FogState takes integer Integer returns fogstate
			return Integer
			return null
		endfunction
		
  function FogState2I takes fogstate FogState returns integer
			return FogState
			return 0
		endfunction
		
  function B2FogState takes boolean Boolean returns fogstate
			return Boolean
			return null
		endfunction
		
  function FogState2B takes fogstate FogState returns boolean
			return FogState
			return false
		endfunction
		
  function R2FogState takes real Real returns fogstate
			return Real
			return null
		endfunction
		
  function FogState2R takes fogstate FogState returns real
			return FogState
			return 0.00
		endfunction
		
  function S2FogState takes string String returns fogstate
			return String
			return null
		endfunction
		
  function FogState2S takes fogstate FogState returns string
			return FogState
			return ""
		endfunction
//end of: AGeneralConversionMacro("fogstate", "FogState")
//textmacro instance: AGeneralConversionMacro("fogmodifier", "FogModifier")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2FogModifier takes integer Integer returns fogmodifier
			return Integer
			return null
		endfunction
		
  function FogModifier2I takes fogmodifier FogModifier returns integer
			return FogModifier
			return 0
		endfunction
		
  function B2FogModifier takes boolean Boolean returns fogmodifier
			return Boolean
			return null
		endfunction
		
  function FogModifier2B takes fogmodifier FogModifier returns boolean
			return FogModifier
			return false
		endfunction
		
  function R2FogModifier takes real Real returns fogmodifier
			return Real
			return null
		endfunction
		
  function FogModifier2R takes fogmodifier FogModifier returns real
			return FogModifier
			return 0.00
		endfunction
		
  function S2FogModifier takes string String returns fogmodifier
			return String
			return null
		endfunction
		
  function FogModifier2S takes fogmodifier FogModifier returns string
			return FogModifier
			return ""
		endfunction
//end of: AGeneralConversionMacro("fogmodifier", "FogModifier")
//textmacro instance: AGeneralConversionMacro("dialog", "Dialog")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2Dialog takes integer Integer returns dialog
			return Integer
			return null
		endfunction
		
  function Dialog2I takes dialog Dialog returns integer
			return Dialog
			return 0
		endfunction
		
  function B2Dialog takes boolean Boolean returns dialog
			return Boolean
			return null
		endfunction
		
  function Dialog2B takes dialog Dialog returns boolean
			return Dialog
			return false
		endfunction
		
  function R2Dialog takes real Real returns dialog
			return Real
			return null
		endfunction
		
  function Dialog2R takes dialog Dialog returns real
			return Dialog
			return 0.00
		endfunction
		
  function S2Dialog takes string String returns dialog
			return String
			return null
		endfunction
		
  function Dialog2S takes dialog Dialog returns string
			return Dialog
			return ""
		endfunction
//end of: AGeneralConversionMacro("dialog", "Dialog")
//textmacro instance: AGeneralConversionMacro("button", "Button")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2Button takes integer Integer returns button
			return Integer
			return null
		endfunction
		
  function Button2I takes button Button returns integer
			return Button
			return 0
		endfunction
		
  function B2Button takes boolean Boolean returns button
			return Boolean
			return null
		endfunction
		
  function Button2B takes button Button returns boolean
			return Button
			return false
		endfunction
		
  function R2Button takes real Real returns button
			return Real
			return null
		endfunction
		
  function Button2R takes button Button returns real
			return Button
			return 0.00
		endfunction
		
  function S2Button takes string String returns button
			return String
			return null
		endfunction
		
  function Button2S takes button Button returns string
			return Button
			return ""
		endfunction
//end of: AGeneralConversionMacro("button", "Button")
//textmacro instance: AGeneralConversionMacro("quest", "Quest")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2Quest takes integer Integer returns quest
			return Integer
			return null
		endfunction
		
  function Quest2I takes quest Quest returns integer
			return Quest
			return 0
		endfunction
		
  function B2Quest takes boolean Boolean returns quest
			return Boolean
			return null
		endfunction
		
  function Quest2B takes quest Quest returns boolean
			return Quest
			return false
		endfunction
		
  function R2Quest takes real Real returns quest
			return Real
			return null
		endfunction
		
  function Quest2R takes quest Quest returns real
			return Quest
			return 0.00
		endfunction
		
  function S2Quest takes string String returns quest
			return String
			return null
		endfunction
		
  function Quest2S takes quest Quest returns string
			return Quest
			return ""
		endfunction
//end of: AGeneralConversionMacro("quest", "Quest")
//textmacro instance: AGeneralConversionMacro("questitem", "QuestItem")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2QuestItem takes integer Integer returns questitem
			return Integer
			return null
		endfunction
		
  function QuestItem2I takes questitem QuestItem returns integer
			return QuestItem
			return 0
		endfunction
		
  function B2QuestItem takes boolean Boolean returns questitem
			return Boolean
			return null
		endfunction
		
  function QuestItem2B takes questitem QuestItem returns boolean
			return QuestItem
			return false
		endfunction
		
  function R2QuestItem takes real Real returns questitem
			return Real
			return null
		endfunction
		
  function QuestItem2R takes questitem QuestItem returns real
			return QuestItem
			return 0.00
		endfunction
		
  function S2QuestItem takes string String returns questitem
			return String
			return null
		endfunction
		
  function QuestItem2S takes questitem QuestItem returns string
			return QuestItem
			return ""
		endfunction
//end of: AGeneralConversionMacro("questitem", "QuestItem")
//textmacro instance: AGeneralConversionMacro("defeatcondition", "DefeatCondition")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2DefeatCondition takes integer Integer returns defeatcondition
			return Integer
			return null
		endfunction
		
  function DefeatCondition2I takes defeatcondition DefeatCondition returns integer
			return DefeatCondition
			return 0
		endfunction
		
  function B2DefeatCondition takes boolean Boolean returns defeatcondition
			return Boolean
			return null
		endfunction
		
  function DefeatCondition2B takes defeatcondition DefeatCondition returns boolean
			return DefeatCondition
			return false
		endfunction
		
  function R2DefeatCondition takes real Real returns defeatcondition
			return Real
			return null
		endfunction
		
  function DefeatCondition2R takes defeatcondition DefeatCondition returns real
			return DefeatCondition
			return 0.00
		endfunction
		
  function S2DefeatCondition takes string String returns defeatcondition
			return String
			return null
		endfunction
		
  function DefeatCondition2S takes defeatcondition DefeatCondition returns string
			return DefeatCondition
			return ""
		endfunction
//end of: AGeneralConversionMacro("defeatcondition", "DefeatCondition")
//textmacro instance: AGeneralConversionMacro("timerdialog", "TimerDialog")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2TimerDialog takes integer Integer returns timerdialog
			return Integer
			return null
		endfunction
		
  function TimerDialog2I takes timerdialog TimerDialog returns integer
			return TimerDialog
			return 0
		endfunction
		
  function B2TimerDialog takes boolean Boolean returns timerdialog
			return Boolean
			return null
		endfunction
		
  function TimerDialog2B takes timerdialog TimerDialog returns boolean
			return TimerDialog
			return false
		endfunction
		
  function R2TimerDialog takes real Real returns timerdialog
			return Real
			return null
		endfunction
		
  function TimerDialog2R takes timerdialog TimerDialog returns real
			return TimerDialog
			return 0.00
		endfunction
		
  function S2TimerDialog takes string String returns timerdialog
			return String
			return null
		endfunction
		
  function TimerDialog2S takes timerdialog TimerDialog returns string
			return TimerDialog
			return ""
		endfunction
//end of: AGeneralConversionMacro("timerdialog", "TimerDialog")
//textmacro instance: AGeneralConversionMacro("leaderboard", "Leaderboard")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2Leaderboard takes integer Integer returns leaderboard
			return Integer
			return null
		endfunction
		
  function Leaderboard2I takes leaderboard Leaderboard returns integer
			return Leaderboard
			return 0
		endfunction
		
  function B2Leaderboard takes boolean Boolean returns leaderboard
			return Boolean
			return null
		endfunction
		
  function Leaderboard2B takes leaderboard Leaderboard returns boolean
			return Leaderboard
			return false
		endfunction
		
  function R2Leaderboard takes real Real returns leaderboard
			return Real
			return null
		endfunction
		
  function Leaderboard2R takes leaderboard Leaderboard returns real
			return Leaderboard
			return 0.00
		endfunction
		
  function S2Leaderboard takes string String returns leaderboard
			return String
			return null
		endfunction
		
  function Leaderboard2S takes leaderboard Leaderboard returns string
			return Leaderboard
			return ""
		endfunction
//end of: AGeneralConversionMacro("leaderboard", "Leaderboard")
//textmacro instance: AGeneralConversionMacro("multiboard", "Multiboard")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2Multiboard takes integer Integer returns multiboard
			return Integer
			return null
		endfunction
		
  function Multiboard2I takes multiboard Multiboard returns integer
			return Multiboard
			return 0
		endfunction
		
  function B2Multiboard takes boolean Boolean returns multiboard
			return Boolean
			return null
		endfunction
		
  function Multiboard2B takes multiboard Multiboard returns boolean
			return Multiboard
			return false
		endfunction
		
  function R2Multiboard takes real Real returns multiboard
			return Real
			return null
		endfunction
		
  function Multiboard2R takes multiboard Multiboard returns real
			return Multiboard
			return 0.00
		endfunction
		
  function S2Multiboard takes string String returns multiboard
			return String
			return null
		endfunction
		
  function Multiboard2S takes multiboard Multiboard returns string
			return Multiboard
			return ""
		endfunction
//end of: AGeneralConversionMacro("multiboard", "Multiboard")
//textmacro instance: AGeneralConversionMacro("multiboarditem", "MultiboardItem")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2MultiboardItem takes integer Integer returns multiboarditem
			return Integer
			return null
		endfunction
		
  function MultiboardItem2I takes multiboarditem MultiboardItem returns integer
			return MultiboardItem
			return 0
		endfunction
		
  function B2MultiboardItem takes boolean Boolean returns multiboarditem
			return Boolean
			return null
		endfunction
		
  function MultiboardItem2B takes multiboarditem MultiboardItem returns boolean
			return MultiboardItem
			return false
		endfunction
		
  function R2MultiboardItem takes real Real returns multiboarditem
			return Real
			return null
		endfunction
		
  function MultiboardItem2R takes multiboarditem MultiboardItem returns real
			return MultiboardItem
			return 0.00
		endfunction
		
  function S2MultiboardItem takes string String returns multiboarditem
			return String
			return null
		endfunction
		
  function MultiboardItem2S takes multiboarditem MultiboardItem returns string
			return MultiboardItem
			return ""
		endfunction
//end of: AGeneralConversionMacro("multiboarditem", "MultiboardItem")
//textmacro instance: AGeneralConversionMacro("trackable", "Trackable")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2Trackable takes integer Integer returns trackable
			return Integer
			return null
		endfunction
		
  function Trackable2I takes trackable Trackable returns integer
			return Trackable
			return 0
		endfunction
		
  function B2Trackable takes boolean Boolean returns trackable
			return Boolean
			return null
		endfunction
		
  function Trackable2B takes trackable Trackable returns boolean
			return Trackable
			return false
		endfunction
		
  function R2Trackable takes real Real returns trackable
			return Real
			return null
		endfunction
		
  function Trackable2R takes trackable Trackable returns real
			return Trackable
			return 0.00
		endfunction
		
  function S2Trackable takes string String returns trackable
			return String
			return null
		endfunction
		
  function Trackable2S takes trackable Trackable returns string
			return Trackable
			return ""
		endfunction
//end of: AGeneralConversionMacro("trackable", "Trackable")
//textmacro instance: AGeneralConversionMacro("gamecache", "GameCache")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2GameCache takes integer Integer returns gamecache
			return Integer
			return null
		endfunction
		
  function GameCache2I takes gamecache GameCache returns integer
			return GameCache
			return 0
		endfunction
		
  function B2GameCache takes boolean Boolean returns gamecache
			return Boolean
			return null
		endfunction
		
  function GameCache2B takes gamecache GameCache returns boolean
			return GameCache
			return false
		endfunction
		
  function R2GameCache takes real Real returns gamecache
			return Real
			return null
		endfunction
		
  function GameCache2R takes gamecache GameCache returns real
			return GameCache
			return 0.00
		endfunction
		
  function S2GameCache takes string String returns gamecache
			return String
			return null
		endfunction
		
  function GameCache2S takes gamecache GameCache returns string
			return GameCache
			return ""
		endfunction
//end of: AGeneralConversionMacro("gamecache", "GameCache")
//textmacro instance: AGeneralConversionMacro("version", "Version")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2Version takes integer Integer returns version
			return Integer
			return null
		endfunction
		
  function Version2I takes version Version returns integer
			return Version
			return 0
		endfunction
		
  function B2Version takes boolean Boolean returns version
			return Boolean
			return null
		endfunction
		
  function Version2B takes version Version returns boolean
			return Version
			return false
		endfunction
		
  function R2Version takes real Real returns version
			return Real
			return null
		endfunction
		
  function Version2R takes version Version returns real
			return Version
			return 0.00
		endfunction
		
  function S2Version takes string String returns version
			return String
			return null
		endfunction
		
  function Version2S takes version Version returns string
			return Version
			return ""
		endfunction
//end of: AGeneralConversionMacro("version", "Version")
//textmacro instance: AGeneralConversionMacro("itemtype", "ItemType")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2ItemType takes integer Integer returns itemtype
			return Integer
			return null
		endfunction
		
  function ItemType2I takes itemtype ItemType returns integer
			return ItemType
			return 0
		endfunction
		
  function B2ItemType takes boolean Boolean returns itemtype
			return Boolean
			return null
		endfunction
		
  function ItemType2B takes itemtype ItemType returns boolean
			return ItemType
			return false
		endfunction
		
  function R2ItemType takes real Real returns itemtype
			return Real
			return null
		endfunction
		
  function ItemType2R takes itemtype ItemType returns real
			return ItemType
			return 0.00
		endfunction
		
  function S2ItemType takes string String returns itemtype
			return String
			return null
		endfunction
		
  function ItemType2S takes itemtype ItemType returns string
			return ItemType
			return ""
		endfunction
//end of: AGeneralConversionMacro("itemtype", "ItemType")
//textmacro instance: AGeneralConversionMacro("texttag", "TextTag")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2TextTag takes integer Integer returns texttag
			return Integer
			return null
		endfunction
		
  function TextTag2I takes texttag TextTag returns integer
			return TextTag
			return 0
		endfunction
		
  function B2TextTag takes boolean Boolean returns texttag
			return Boolean
			return null
		endfunction
		
  function TextTag2B takes texttag TextTag returns boolean
			return TextTag
			return false
		endfunction
		
  function R2TextTag takes real Real returns texttag
			return Real
			return null
		endfunction
		
  function TextTag2R takes texttag TextTag returns real
			return TextTag
			return 0.00
		endfunction
		
  function S2TextTag takes string String returns texttag
			return String
			return null
		endfunction
		
  function TextTag2S takes texttag TextTag returns string
			return TextTag
			return ""
		endfunction
//end of: AGeneralConversionMacro("texttag", "TextTag")
//textmacro instance: AGeneralConversionMacro("attacktype", "AttackType")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2AttackType takes integer Integer returns attacktype
			return Integer
			return null
		endfunction
		
  function AttackType2I takes attacktype AttackType returns integer
			return AttackType
			return 0
		endfunction
		
  function B2AttackType takes boolean Boolean returns attacktype
			return Boolean
			return null
		endfunction
		
  function AttackType2B takes attacktype AttackType returns boolean
			return AttackType
			return false
		endfunction
		
  function R2AttackType takes real Real returns attacktype
			return Real
			return null
		endfunction
		
  function AttackType2R takes attacktype AttackType returns real
			return AttackType
			return 0.00
		endfunction
		
  function S2AttackType takes string String returns attacktype
			return String
			return null
		endfunction
		
  function AttackType2S takes attacktype AttackType returns string
			return AttackType
			return ""
		endfunction
//end of: AGeneralConversionMacro("attacktype", "AttackType")
//textmacro instance: AGeneralConversionMacro("damagetype", "DamageType")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2DamageType takes integer Integer returns damagetype
			return Integer
			return null
		endfunction
		
  function DamageType2I takes damagetype DamageType returns integer
			return DamageType
			return 0
		endfunction
		
  function B2DamageType takes boolean Boolean returns damagetype
			return Boolean
			return null
		endfunction
		
  function DamageType2B takes damagetype DamageType returns boolean
			return DamageType
			return false
		endfunction
		
  function R2DamageType takes real Real returns damagetype
			return Real
			return null
		endfunction
		
  function DamageType2R takes damagetype DamageType returns real
			return DamageType
			return 0.00
		endfunction
		
  function S2DamageType takes string String returns damagetype
			return String
			return null
		endfunction
		
  function DamageType2S takes damagetype DamageType returns string
			return DamageType
			return ""
		endfunction
//end of: AGeneralConversionMacro("damagetype", "DamageType")
//textmacro instance: AGeneralConversionMacro("weapontype", "WeaponType")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2WeaponType takes integer Integer returns weapontype
			return Integer
			return null
		endfunction
		
  function WeaponType2I takes weapontype WeaponType returns integer
			return WeaponType
			return 0
		endfunction
		
  function B2WeaponType takes boolean Boolean returns weapontype
			return Boolean
			return null
		endfunction
		
  function WeaponType2B takes weapontype WeaponType returns boolean
			return WeaponType
			return false
		endfunction
		
  function R2WeaponType takes real Real returns weapontype
			return Real
			return null
		endfunction
		
  function WeaponType2R takes weapontype WeaponType returns real
			return WeaponType
			return 0.00
		endfunction
		
  function S2WeaponType takes string String returns weapontype
			return String
			return null
		endfunction
		
  function WeaponType2S takes weapontype WeaponType returns string
			return WeaponType
			return ""
		endfunction
//end of: AGeneralConversionMacro("weapontype", "WeaponType")
//textmacro instance: AGeneralConversionMacro("soundtype", "SoundType")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2SoundType takes integer Integer returns soundtype
			return Integer
			return null
		endfunction
		
  function SoundType2I takes soundtype SoundType returns integer
			return SoundType
			return 0
		endfunction
		
  function B2SoundType takes boolean Boolean returns soundtype
			return Boolean
			return null
		endfunction
		
  function SoundType2B takes soundtype SoundType returns boolean
			return SoundType
			return false
		endfunction
		
  function R2SoundType takes real Real returns soundtype
			return Real
			return null
		endfunction
		
  function SoundType2R takes soundtype SoundType returns real
			return SoundType
			return 0.00
		endfunction
		
  function S2SoundType takes string String returns soundtype
			return String
			return null
		endfunction
		
  function SoundType2S takes soundtype SoundType returns string
			return SoundType
			return ""
		endfunction
//end of: AGeneralConversionMacro("soundtype", "SoundType")
//textmacro instance: AGeneralConversionMacro("lightning", "Lightning")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2Lightning takes integer Integer returns lightning
			return Integer
			return null
		endfunction
		
  function Lightning2I takes lightning Lightning returns integer
			return Lightning
			return 0
		endfunction
		
  function B2Lightning takes boolean Boolean returns lightning
			return Boolean
			return null
		endfunction
		
  function Lightning2B takes lightning Lightning returns boolean
			return Lightning
			return false
		endfunction
		
  function R2Lightning takes real Real returns lightning
			return Real
			return null
		endfunction
		
  function Lightning2R takes lightning Lightning returns real
			return Lightning
			return 0.00
		endfunction
		
  function S2Lightning takes string String returns lightning
			return String
			return null
		endfunction
		
  function Lightning2S takes lightning Lightning returns string
			return Lightning
			return ""
		endfunction
//end of: AGeneralConversionMacro("lightning", "Lightning")
//textmacro instance: AGeneralConversionMacro("pathingtype", "PathingType")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2PathingType takes integer Integer returns pathingtype
			return Integer
			return null
		endfunction
		
  function PathingType2I takes pathingtype PathingType returns integer
			return PathingType
			return 0
		endfunction
		
  function B2PathingType takes boolean Boolean returns pathingtype
			return Boolean
			return null
		endfunction
		
  function PathingType2B takes pathingtype PathingType returns boolean
			return PathingType
			return false
		endfunction
		
  function R2PathingType takes real Real returns pathingtype
			return Real
			return null
		endfunction
		
  function PathingType2R takes pathingtype PathingType returns real
			return PathingType
			return 0.00
		endfunction
		
  function S2PathingType takes string String returns pathingtype
			return String
			return null
		endfunction
		
  function PathingType2S takes pathingtype PathingType returns string
			return PathingType
			return ""
		endfunction
//end of: AGeneralConversionMacro("pathingtype", "PathingType")
//textmacro instance: AGeneralConversionMacro("image", "Image")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2Image takes integer Integer returns image
			return Integer
			return null
		endfunction
		
  function Image2I takes image Image returns integer
			return Image
			return 0
		endfunction
		
  function B2Image takes boolean Boolean returns image
			return Boolean
			return null
		endfunction
		
  function Image2B takes image Image returns boolean
			return Image
			return false
		endfunction
		
  function R2Image takes real Real returns image
			return Real
			return null
		endfunction
		
  function Image2R takes image Image returns real
			return Image
			return 0.00
		endfunction
		
  function S2Image takes string String returns image
			return String
			return null
		endfunction
		
  function Image2S takes image Image returns string
			return Image
			return ""
		endfunction
//end of: AGeneralConversionMacro("image", "Image")
//textmacro instance: AGeneralConversionMacro("ubersplat", "Ubersplat")
		//Fr die Integer-Konvertierung existieren bereits Native-Funktionen.
  function I2Ubersplat takes integer Integer returns ubersplat
			return Integer
			return null
		endfunction
		
  function Ubersplat2I takes ubersplat Ubersplat returns integer
			return Ubersplat
			return 0
		endfunction
		
  function B2Ubersplat takes boolean Boolean returns ubersplat
			return Boolean
			return null
		endfunction
		
  function Ubersplat2B takes ubersplat Ubersplat returns boolean
			return Ubersplat
			return false
		endfunction
		
  function R2Ubersplat takes real Real returns ubersplat
			return Real
			return null
		endfunction
		
  function Ubersplat2R takes ubersplat Ubersplat returns real
			return Ubersplat
			return 0.00
		endfunction
		
  function S2Ubersplat takes string String returns ubersplat
			return String
			return null
		endfunction
		
  function Ubersplat2S takes ubersplat Ubersplat returns string
			return Ubersplat
			return ""
		endfunction
//end of: AGeneralConversionMacro("ubersplat", "Ubersplat")


//library ALibraryCoreGeneralConversion ends
//library ALibraryCoreGeneralGame:

	/// This function I discovered myself (and with the help of Captain Griffen). Simply put, if your
	/// actually playing a game, it will return true HOWEVER if your viewing the game as a replay it
	/// will return false. The function has been tested in MultiPlayer and it now causes no desyncs
	/// (by tested I mean vigorously tested by IceFrog for like 3 months). There is only one
	/// downside, and that is the function uses up one pause.
	///
	/// There might be a second version of the function that doesn't use up a pause (discovered by
	/// Strilanc) however there are a couple of issues with it
	///
	/// How does it work?
	/// Simply put a replay is just a file that contains the inputs from the various players when
	/// playing a game. However when Wc3 views a replay, there are differences then if you were
	/// physically playing the game. One of the differences is pausing. If you are actually playing
	/// and you pause a game, it is paused. However during a replay, if you pause a game the replay
	/// simply finishes at the point you paused the game, if the game is resumed some time later then
	/// the replay completely skips the pause phase. There are only a few things that work in real
	/// time during pauses when your playing the game (anything else you do during the pause just
	/// gets 'suspended' until the game is resumed). The 2 things that work in real time are camera
	/// angles and trigger sleep action.
	///
	/// The function works by moving the camera during the pause. If the camera is moved during the
	/// pause, then you are playing the actual game. If the camera isn't moved then it is the replay
	/// (since the pause phase is totally skipped)
	///
	/// - It is HIGHLY recommended that you save the returning value of the function into a boolean
	/// variable i.e.
	/// set someboolean = IsInGame()
	/// So you only call the function once (since it takes up a pause)
	/// @author PandaMine, Captain Griffen
 function IsInGame takes nothing returns boolean
  local integer counter= 0
  local player localPlayer= GetLocalPlayer()
  local player user
  local real cameraX
  local real cameraY
  local real x
  local real y
  local boolean result
		loop
			exitwhen ( counter == bj_MAX_PLAYERS )
			set user = Player(counter)
			if ( localPlayer == user ) then
				set cameraX = GetCameraTargetPositionX()
				set cameraY = GetCameraTargetPositionY()
			endif
			set user = null
			set counter = counter + 1
		endloop
		call PauseGame(true)
		call TriggerSleepAction(0)
		set counter = 0
		loop
			exitwhen ( counter == bj_MAX_PLAYERS )
			set user = Player(counter)
			if ( localPlayer == user ) then
				call SetCameraPosition(cameraX + 1 , cameraY + 1)
			endif
			set user = null
			set counter = counter + 1
		endloop
		call TriggerSleepAction(0)
		call PauseGame(false)
		set counter = 0
		loop
			exitwhen ( counter == bj_MAX_PLAYERS )
			set user = Player(counter)
			if ( localPlayer == user ) then
				set x = GetCameraTargetPositionX()
				if x == cameraX + 1 then
					set result = true
				else
					set result = false
				endif
				call SetCameraPosition(cameraX , cameraY)
			endif
			set user = null
			set counter = counter + 1
		endloop
		return result
	endfunction

	/// With the new change to the function, it no longer needs to be synchronized however you should 
	/// still initialize it like this because it has been reported that selecting units +
	/// triggersleepaction can cause desyncs
	/// @author PandaMine, Captain Griffen
 function IsInGameEx takes nothing returns boolean
  local boolean result
		call EnableUserControl(false)
		call TriggerSleepAction(.0)
		set result = IsInGame()
		call EnableUserControl(true)
		return result
	endfunction


//library ALibraryCoreGeneralGame ends
//library ALibraryCoreGeneralPlayer:

	/// You have not to set GetTriggerPlayer() to null.
	/// @author Tamino Dauth
 function GetTriggerPlayerId takes nothing returns integer
  local player user= GetTriggerPlayer()
  local integer id= GetPlayerId(user)
		set user = null
		return id
	endfunction

	/// You have not to set GetTriggerUnit() and GetOwningPlayer to null.
	/// @author Tamino Dauth
 function GetOwningPlayerId takes nothing returns integer
  local unit triggerunit= GetTriggerUnit()
  local player owner= GetOwningPlayer(triggerunit)
  local integer id= GetPlayerId(owner)
		set triggerunit = null
		set owner = null
		return id
	endfunction

	/// Checks whether a player is a playing user.
	/// @author Tamino Dauth
 function IsPlayerPlayingUser takes player user returns boolean
		return ( ( GetPlayerController(user) == MAP_CONTROL_USER ) and ( GetPlayerSlotState(user) == PLAYER_SLOT_STATE_PLAYING ) )
	endfunction


//library ALibraryCoreGeneralPlayer ends
//library ALibraryCoreGeneralUnit:

	/// Sicheres iterieren per FirstOfGroup
	///
	/// Heyhey,
	///
	/// dieser Bug (oder Feature, je nachdem wie mans nimmt) hat mich etwa 4 Stunden debuggen 
	/// gekostet.
	///
	/// Hintergrund: Wie ihr wisst kann man ja über eine Unitgroup iterieren (und diese dabei leeren) 
	/// (Die gruppe nenne ich einfach mal g):
	///
	/// code:
	/// local unit u
	/// loop
	/// 	set u = FirstOfGroup(g)
	/// 	exitwhen u == null
	///
	/// 	//HIER das mit der unit machen was man machen will
	///
	/// 	call GroupRemoveUnit(g,u)
	/// endloop
	///
	/// Tja, nur blöd dass das buggy ist, sobald einmal eine unit in der Gruppe aus dem Spiel 
	/// entfernt wurde ohne sie vorher ordnungsgemäß aus der Gruppe zu removen. Das wusste ich bisher 
	/// auch nicht.
	///
	/// Beispiel:
	/// Wir adden in eine Gruppe 4 units. Dann entfernen wir die erste geaddete unit per 
	/// RemoveUnit(...) aus dem Spiel. Nun ist die Gruppe kaputt (zumindest für das Iterieren per 
	/// FirstOfGroup()). Denn FirstOfGroup(g) wird nun null liefern, die schleife endet also sofort 
	/// obwohl drei units in der Group sind. Denn die "Lücke" die die unit hinterlassen hat bleibt in 
	/// der Group. Und das blödeste: Diese lücke können wir auch nicht mehr per call 
	/// GroupRemoveUnit(FirstOfGroup()) entfernen, da ja FoG nun null zurückliefert und 
	/// GroupRemoveUnit(null) nichts macht.
	///
	///
	/// ALSO VORSICHT! Das FirstOfGroup(...) null zurückliefert heisst nicht unbedingt, dass die 
	/// Gruppe leer ist!
	///
	/// Deshalb hab ich mir eine kleine Funktion geschrieben die äquivalent zu einem Aufruf von 
	/// FirstOfGroup ist, aber solche Lücken erkennt und die Gruppe automatisch repariert sobald sie 
	/// auf so eine Lücke trifft, hier ist sie:
	///
	/// Die Idee:
	/// Erstmal führt die Funktion ein normales FirstOfGroup auf die gewünschte Gruppe aus. Liefert 
	/// dieser aufruf NICHT null, klappt ja alles perfekt, dann gibt sie einfach die unit zurück. 
	/// Liefert der Aufruf aber null können zwei Fälle eingetreten sein:
	///
	/// 1.) Die Group ist tatsächlich empty
	/// 2.) Wir sind auf eine Lücke gestoßen die repariert werden muss.
	///
	/// Das überprüfen wir einfach indem wir ein GroupIsEmpty-derivat aufrufen. Liefert es true /// 
	/// zurück war die gruppe wirklich leer und wir können null returnen. sonst reparieren wir sie, 
	/// das geht so:
	/// Wir kopieren per ForGroup alle units in eine swap gruppe. Dabei werden lücken nicht 
	/// mitkopiert, da ForGroup so schlau ist und solche lücken beim iterieren nicht beachtet. Dann 
	/// leeren wir die gruppe und kopieren einfach die units aus der swapgruppe zurück und fertig ist 
	/// die reparierte Gruppe auf die wir nun ein erneutes FirstOfGroup aufrufen um die wirkliche 
	/// first unit zu ermitteln die wir zurück geben.
	///
	/// Ich empfehle euch dringend diese Funktion zu benutzen wenn ihr über eine Group per 
	/// FirstOfGroup iterieren wollt, aber nicht sicher sein könnt, dass keine unit jemals aus dem 
	/// Spiel entfernt wurde (was auch nach dem normalen tod und dekay automatisch passiert) die in 
	/// der Gruppe war.
	///
	/// Hoffe ich kann euch damit die Stunden des Bugfixen die ich hatte ersparen...
	/// @author gexxo
	/// @param g Used unit group.
	/// @return Returns the first unit of group g. If the group is empty it will return null.
 function FirstOfGroupSave takes group g returns unit
  local unit u= FirstOfGroup(g) //Try a normal first of group
  local group swap
		
		// If the result is null there may be gaps in the group
		if u == null then
			//Check if the group is empty. If it is not, then there must be gaps -> repair
			set bj_isUnitGroupEmptyResult = true
			call ForGroup(g , function IsUnitGroupEmptyBJEnum)
			if not bj_isUnitGroupEmptyResult then
				//** Repair the group **
				set swap = CreateGroup()
				call GroupAddGroup(g , swap) //Add all units to a swapping group
				call GroupClear(g) //Clear the buggy group hence removing the gaps
				call GroupAddGroup(swap , g) //Put the units back in from the swapping group
				
				//Collect garbage
				call DestroyGroup(swap)
				set swap = null
				
				//Do another FirstOfGroup to gain the real first unit
				set u = FirstOfGroup(g)
			endif
		endif
		
		return u //Return the unit we wanted   
	endfunction


//library ALibraryCoreGeneralUnit ends
//library ALibraryCoreInterfaceCamera:

 function SetCameraBoundsForPlayer takes player user,real x1,real y1,real x2,real y2,real x3,real y3,real x4,real y4 returns nothing
  local player localPlayer= GetLocalPlayer()
		if ( user == localPlayer ) then
			call SetCameraBounds(x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4)
		endif
		set localPlayer = null
	endfunction

 function SetCameraBoundsToPointForPlayer takes player user,real x,real y returns nothing
		call SetCameraBoundsForPlayer(user , x , y , x , y , x , y , x , y)
	endfunction

 function ResetCameraBoundsToMapRectForPlayer takes player user returns nothing
  local real minX= GetRectMinX(bj_mapInitialCameraBounds)
      local real minY= GetRectMinY(bj_mapInitialCameraBounds)
      local real maxX= GetRectMaxX(bj_mapInitialCameraBounds)
      local real maxY= GetRectMaxY(bj_mapInitialCameraBounds)
		call SetCameraBoundsForPlayer(user , minX , minY , minX , maxY , maxX , maxY , maxX , minY)
	endfunction

 function GetCameraTargetPositionOfPlayer takes player user returns location
  local player localPlayer= GetLocalPlayer()
  local location cameraTargetPosition
		if ( user == localPlayer ) then
			set cameraTargetPosition = GetCameraTargetPositionLoc()
		endif
		set localPlayer = null
		return cameraTargetPosition
	endfunction

 function GetCameraTargetPositionXOfPlayer takes player user returns real
  local player localPlayer= GetLocalPlayer()
  local real value
		if ( user == localPlayer ) then
			set value = GetCameraTargetPositionX()
		endif
		set localPlayer = null
		return value
	endfunction

 function GetCameraTargetPositionYOfPlayer takes player user returns real
  local player localPlayer= GetLocalPlayer()
  local real value
		if ( user == localPlayer ) then
			set value = GetCameraTargetPositionY()
		endif
		set localPlayer = null
		return value
	endfunction

 function GetCameraTargetPositionZOfPlayer takes player user returns real
  local player localPlayer= GetLocalPlayer()
  local real value
		if ( user == localPlayer ) then
			set value = GetCameraTargetPositionZ()
		endif
		set localPlayer = null
		return value
	endfunction

 function GetCameraFieldOfPlayer takes player user,camerafield cameraField returns real
  local player localPlayer= GetLocalPlayer()
  local real cameraFieldValue
		if ( user == localPlayer ) then
			set cameraFieldValue = GetCameraField(cameraField)
		endif
		set localPlayer = null
		return cameraFieldValue
	endfunction


//library ALibraryCoreInterfaceCamera ends
//library ALibraryCoreInterfaceCinematic:

	//smaller function than the real
	//you don't have to use player forces
 function SetCinematicSceneForPlayer takes player user,integer unitType,string title,string text,real sceneTime,real voiceTime returns nothing
  local player localPlayer= GetLocalPlayer()
  local playercolor playerColour= GetPlayerColor(user)
		if ( user == localPlayer ) then
			call SetCinematicScene(unitType , playerColour , title , text , sceneTime , voiceTime)
		endif
		set localPlayer = null
		set playerColour = null
	endfunction

	//here it's the same
	//you don't have to use fucking player forces
	//we want to use players only!
 function ClearScreenMessagesForPlayer takes player user returns nothing
  local player localPlayer= GetLocalPlayer()
		if ( user == localPlayer ) then
			call ClearTextMessages()
		endif
		set localPlayer = null
	endfunction

	//and the same
	//we combinated the interface settings and the user control settings
 function SetUserInterfaceForPlayer takes player user,boolean show,boolean control returns nothing
  local player localPlayer= GetLocalPlayer()
		if ( user == localPlayer ) then
			call ShowInterface(show , 0.0)
		endif
		if ( user == localPlayer ) then
			call EnableUserControl(control) //test
		endif
		set localPlayer = null
	endfunction


//library ALibraryCoreInterfaceCinematic ends
//library ALibraryCoreInterfaceCinematicFilter:

	/// @author KaTTaNa
	/// @todo Crashes the game?!
	/// @state unstable
 function ShowGenericCinematicFilterForPlayer takes player user,real duration,blendmode bmode,string tex,real red0,real green0,real blue0,real trans0,real red1,real green1,real blue1,real trans1 returns nothing
  local player localPlayer= GetLocalPlayer()
		if ( localPlayer == user ) then
			call SetCineFilterTexture(tex)
			call SetCineFilterBlendMode(bmode)
			call SetCineFilterTexMapFlags(TEXMAP_FLAG_NONE)
			call SetCineFilterStartUV(0 , 0 , 1 , 1)
			call SetCineFilterEndUV(0 , 0 , 1 , 1)
			call SetCineFilterStartColor(PercentTo255(red0) , PercentTo255(green0) , PercentTo255(blue0) , PercentTo255(100 - trans0))
			call SetCineFilterEndColor(PercentTo255(red1) , PercentTo255(green1) , PercentTo255(blue1) , PercentTo255(100 - trans1))
			call SetCineFilterDuration(duration)
			call DisplayCineFilter(true)
		endif
		set localPlayer = null
	endfunction
	
	/// @author Tamino Dauth
 function ShowBlackScreenCinematicFilterForPlayer takes player user,real duration returns nothing
  local player localPlayer= GetLocalPlayer()
		if ( localPlayer == user ) then
			call SetCineFilterTexture("ReplaceableTextures\\CameraMasks\\Black_mask.blp")
			call SetCineFilterBlendMode(BLEND_MODE_NONE)
			call SetCineFilterTexMapFlags(TEXMAP_FLAG_NONE)
			call SetCineFilterStartUV(0 , 0 , 1 , 1)
			call SetCineFilterEndUV(0 , 0 , 1 , 1)
			call SetCineFilterStartColor(255 , 255 , 255 , 0)
			call SetCineFilterEndColor(255 , 255 , 255 , 0)
			call SetCineFilterDuration(duration)
			call DisplayCineFilter(true)
		endif
		set localPlayer = null
	endfunction


//library ALibraryCoreInterfaceCinematicFilter ends
//library ALibraryCoreInterfaceImage:

	/// @author PitzerMike
	/// - Bilder brauchen einen unsichtbaren Rand von 1 Pixel
	/// - Man macht ein neues Bild mit der originalen Größe und transparentem Hintergrund
	/// - Bildergrößen müssen eine 2er Potenz sein!!!
	/// - Dann fügt man das Bild mit Rand in das neue Bild und hat einen transparenten Rand
	/// - Das Bild darf nur RGB-Kanäle und keine Alpha-Kanäle enthalten
	/// - Dann speichert man es als 32-Bit-TGA
	/// - Dann muss man es mit dem Wc3Viewer zu einem BLP-Bild konvertieren
	/// Hier braucht man eine lokale Variable für das Image, wegen des Renderns
 function CreateImageForPlayer takes player user,string imagePath,real x,real y,real z,real sizeX,real sizeY returns image
  local player localPlayer= GetLocalPlayer()
  local image usedImage
  local string localPath= ""
		if ( user == localPlayer ) then
			set localPath = imagePath
		endif
		set usedImage = CreateImage(localPath , sizeX , sizeY , 0.0 , ( x - ( sizeX / 2.0 ) ) , ( y - ( sizeY / 2.0 ) ) , z , 0.0 , 0.0 , 0.0 , 2) //Bild wird in der Mitte platziert
		call SetImageRenderAlways(usedImage , true) //Hierbei testen, ob es dadurch dann doch f�r alle Spieler sichtbar ist
		set localPlayer = null
		return usedImage
	endfunction

	/// Shows or hides image @param shownImage for player @param user.
	/// @param user Player who the image is shown or hidden to.
	/// @param shownImage Image handle which should be shown or hidden.
	/// @param show If this value is true image @param shownImage will be shown otherwise it will be hidden.
 function ShowImageForPlayer takes player user,image shownImage,boolean show returns nothing
  local player localPlayer= GetLocalPlayer()
		if ( user == localPlayer ) then
			call ShowImage(shownImage , show)
		endif
		set localPlayer = null
	endfunction


//library ALibraryCoreInterfaceImage ends
//library ALibraryCoreInterfaceLeaderboard:

 function ShowLeaderboardForPlayer takes player user,leaderboard usedLeaderboard,boolean show returns nothing
  local player localPlayer= GetLocalPlayer()
		call PlayerSetLeaderboard(user , usedLeaderboard)
		if ( user == localPlayer ) then
			call LeaderboardDisplay(usedLeaderboard , show)
		endif
		set localPlayer = null
	endfunction


//library ALibraryCoreInterfaceLeaderboard ends
//library ALibraryCoreInterfaceMinimap:

	//WE DON'T WANT TO USE PLAYER FORCES!!!!!!!!!!!!!!!!!!!!!!!!!
 function PingMinimapExForPlayer takes player user,real x,real y,real duration,real red,real green,real blue,boolean extraEffect returns nothing
  local player localPlayer= GetLocalPlayer()
		if ( user == localPlayer ) then
			call PingMinimapEx(x , y , duration , PercentTo255(red) , PercentTo255(green) , PercentTo255(blue) , extraEffect)
		endif
		set localPlayer = null
	endfunction


//library ALibraryCoreInterfaceMinimap ends
//library ALibraryCoreInterfaceMultiboard:

 function ShowMultiboardForPlayer takes player user,multiboard usedMultiboard,boolean show returns nothing
  local player localPlayer= GetLocalPlayer()
		if ( user == localPlayer ) then
			call MultiboardDisplay(usedMultiboard , show)
		endif
		set localPlayer = null
	endfunction


//library ALibraryCoreInterfaceMultiboard ends
//library ALibraryCoreInterfaceSelection:

 function IsPlayerSelectionEmpty takes player user returns boolean
  local group selectedUnits= CreateGroup()
  local boolean result= true
		call GroupEnumUnitsSelected(selectedUnits , user , null)
		if ( selectedUnits != null ) then
			set result = false
		endif
		call DestroyGroup(selectedUnits)
		set selectedUnits = null
		return result
	endfunction

 function GetFirstSelectedUnitOfPlayer takes player user returns unit
  local group selectedUnits= null
  local unit selectedUnit= null //Startwert, falls die Gruppe leer ist
		set selectedUnits = GetUnitsSelectedAll(user)
		set selectedUnit = FirstOfGroup(selectedUnits)
		call DestroyGroup(selectedUnits)
		set selectedUnits = null
		return selectedUnit
	endfunction

	/// Makes a unit select- or unselectable by removing or adding the gasshopper ability.
 function MakeUnitSelectable takes unit usedUnit,boolean selectable returns nothing
		if ( selectable ) then
			call UnitRemoveAbility(usedUnit , 'Aloc')
		else
			call UnitAddAbility(usedUnit , 'Aloc')
		endif
	endfunction


//library ALibraryCoreInterfaceSelection ends
//library ALibraryCoreInterfaceTextTag:

	//SetTextTagAge
	//Setzt das Alter des schwebenden Textes (Eventuell die Zeit, die er schon existiert).
	//SetTextTagFadepoint
	//Setzt die Zeit an der der schwebende Text ausgelbendet werden soll.
	//SetTextTagPermanent
	//Macht den schwebenden Text dauerhaft. Ist er nicht dauerhaft, wird er nach Ablaufen der Lebensdauer automatisch zerstrt.
	//SetTextTagSuspended
	//Unterbricht einen schwebenden Text.
	//SetTextTagVelocity
	//Stellt ein wie schnell sich der Text nach oben und rechts bewegt.
	

	//Auskommentierte Funktionen sind alter Mll
	//Genau wie der Papst.
	//Aktualisiert die Position, den Text und die Gre des Textes.
	//Funktioniert nicht.
	//function SetTextTagForPlayer takes integer PlayerNumber, texttag TextTag, string Text, real Size, real X, real Y, real Z returns nothing
		//local player UsedPlayer = Player(PlayerNumber)
		//local player LocalPlayer = GetLocalPlayer()
		//if (UsedPlayer == GetLocalPlayer()) then
			//call SetTextTagTextBJ(TextTag, Text, Size)
		//endif
		//call SetTextTagPos(TextTag, X, Y, Z)
		//set UsedPlayer = null
		//set LocalPlayer = null
	//endfunction

	//Verursacht Desynchronisation im Multiplayer.
	//function CreateTextTagForPlayer takes integer PlayerNumber returns texttag
		//local player UsedPlayer = Player(PlayerNumber)
		//local player LocalPlayer = GetLocalPlayer()
		//local texttag TextTag
		//if (UsedPlayer == LocalPlayer) then
			//set TextTag = CreateTextTag()
		//endif
		//set UsedPlayer = null
		//set LocalPlayer = null
		//return TextTag
	//endfunction

	/// @author Tamino Dauth
	/// We do not want to use player forces ftw!!!
 function ShowTextTagForPlayer takes player user,texttag textTag,boolean show returns nothing
  local player localPlayer= GetLocalPlayer()
		call SetTextTagVisibility(textTag , user == localPlayer)
		set localPlayer = null
	endfunction

	/// @author Tamino Dauth
 function ShowFadingTextTagForPlayer takes player user,string text,real size,real x,real y,integer red,integer green,integer blue,integer alpha,real velocity,real fadepoint,real lifespan returns nothing
  local player localPlayer
  local texttag textTag= CreateTextTag()
		call SetTextTagText(textTag , text , size)
		call SetTextTagPos(textTag , x , y , 0.0)
		call SetTextTagColor(textTag , red , green , blue , alpha)
		call SetTextTagVelocity(textTag , 0.0 , velocity)
		if ( user == null ) then
			call SetTextTagVisibility(textTag , true)
		else
			call ShowTextTagForPlayer(user , textTag , true)
		endif
		call SetTextTagFadepoint(textTag , fadepoint)
		call SetTextTagLifespan(textTag , lifespan)
		call SetTextTagPermanent(textTag , false)
		set textTag = null
	endfunction

	/// @author Tamino Dauth
 function ShowGeneralFadingTextTagForPlayer takes player user,string text,real x,real y,integer red,integer green,integer blue,integer alpha returns nothing
		call ShowFadingTextTagForPlayer(user , text , 0.025 , x , y , red , green , blue , alpha , 0.03 , 1.0 , 2.0)
	endfunction

	// The following parameters have been token from the UI/Misc.txt file of the War3X.mpq archive.

	/// @author Tamino Dauth
 function ShowGoldTextTagForPlayer takes player user,real x,real y,integer gold returns nothing
		call ShowFadingTextTagForPlayer(user , "+" + I2S(gold) , 0.025 , x , y , 255 , 255 , 220 , 0 , 0.03 , 1.0 , 2.0)
	endfunction

	/// @author Tamino Dauth
 function ShowLumberTextTagForPlayer takes player user,real x,real y,integer lumber returns nothing
		call ShowFadingTextTagForPlayer(user , "+" + I2S(lumber) , 0.025 , x , y , 255 , 0 , 200 , 80 , 0.03 , 1.0 , 2.0)
	endfunction

	/// @author Tamino Dauth
 function ShowBountyTextTagForPlayer takes player user,real x,real y,integer bounty returns nothing
		call ShowFadingTextTagForPlayer(user , "+" + I2S(bounty) , 0.025 , x , y , 255 , 255 , 220 , 0 , 0.03 , 2.0 , 3.0)
	endfunction

	/// @author Tamino Dauth
 function ShowMissTextTagForPlayer takes player user,real x,real y returns nothing
		call ShowFadingTextTagForPlayer(user , GetLocalizedString("MISS") + "!" , 0.025 , x , y , 255 , 255 , 0 , 0 , 0.03 , 1.0 , 3.0)
	endfunction

	/// @author Tamino Dauth
 function ShowCriticalStrikeTextTagForPlayer takes player user,real x,real y,integer damage returns nothing
		call ShowFadingTextTagForPlayer(user , I2S(damage) + "!" , 0.025 , x , y , 255 , 255 , 0 , 0 , 0.04 , 2.0 , 5.0)
	endfunction

	/// @author Tamino Dauth
 function ShowManaBurnTextTagForPlayer takes player user,real x,real y,integer damage returns nothing
		call ShowFadingTextTagForPlayer(user , "-" + I2S(damage) , 0.025 , x , y , 255 , 82 , 82 , 255 , 0.04 , 2.0 , 5.0)
	endfunction

	/// @author Tamino Dauth
	/// @todo Look for bash.
 function ShowBashTextTagForPlayer takes player user,real x,real y,integer damage returns nothing
		call ShowFadingTextTagForPlayer(user , I2S(damage) + "!" , 0.025 , x , y , 255 , 0 , 0 , 255 , 0.04 , 2.0 , 5.0)
	endfunction


//library ALibraryCoreInterfaceTextTag ends
//library ALibraryCoreInterfaceTrackable:

	/// Auf WC3Jass.com wurde die lokale Erzeugung ebenfalls so angewandt.
 function CreateTrackableForPlayer takes player user,string modelPath,real x,real y,real facingAngle returns trackable
  local player localPlayer= GetLocalPlayer()
  local string localPath= ""
		if ( user == localPlayer ) then
			set localPath = modelPath
		endif
		set localPlayer = null
		return CreateTrackable(localPath , x , y , facingAngle)
	endfunction

	/// Eine unsichtbare Plattform wird unter dem Trackable erzeugt.
	/// Diese Funktion ist extra, da sie mehr Speicher verbraucht und nicht immer benötigt wird.
	/// @author KaTTaNa
	/// From: http://www.wc3jass.com/
	/// This creates a trackable at the given coordinates that floats above the ground with the height specified by z.
	//It works by creating an invisible platform, creating the trackable and removing the platform again.
 function CreateTrackableForPlayerZ takes player user,string modelPath,real x,real y,real z,real facingAngle returns trackable
  local destructable heightDestructable= CreateDestructableZ('OTip' , x , y , z , 0.0 , 1.0 , 0)
  local trackable usedTrackable= CreateTrackableForPlayer(user , modelPath , x , y , facingAngle)
		call RemoveDestructable(heightDestructable)
		set heightDestructable = null
		return usedTrackable
	endfunction


//library ALibraryCoreInterfaceTrackable ends
//library ALibraryCoreMathsPoint:

	/// Returns the z value of the point with coordinates @param x and @param y.
 function GetTerrainZ takes real x,real y returns real
  local location usedLocation= Location(x , y)
  local real z= GetLocationZ(usedLocation)
		call RemoveLocation(usedLocation)
		set usedLocation = null
		return z
	endfunction

	/// Copied from the new FPS mod.
 function GetPointZ takes real x,real y returns real
  local real x1= x - ModuloReal(x , 128.0) //top left corner
  local real y1= y - ModuloReal(x , 128.0) + 128.0
  local real z1= GetTerrainZ(x1 , y1)
  local real x3= x1 + 128.0 //bottom right
  local real y3= y1 - 128.0
  local real z3= GetTerrainZ(x3 , y3)
  local real x2
  local real y2
  local real z2
  local real A
  local real B
  local real C
  local real D

		if ( ( x - x1 ) < ( y1 - y ) ) then //in bottom left section
			set x2 = x1
			set y2 = y3
		else
			set x2 = x3 //top right corner
			set y2 = y1
		endif
		set z2 = GetTerrainZ(x2 , y2)

		set A = y1 * ( z2 - z3 ) + y2 * ( z3 - z1 ) + y3 * ( z1 - z2 ) //
	
		//http://local.wasp.uwa.edu.au/~pbourke/geometry/planeeq/ ftw
		set B = z1 * ( x2 - x3 ) + z2 * ( x3 - x1 ) + z3 * ( x1 - x2 )
		set C = x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 )
		set D = - ( x1 * ( y2 * z3 - y3 * z2 ) + x2 * ( y3 * z1 - y1 * z3 ) + x3 * ( y1 * z2 - y2 * z1 ) )
	
		return - ( A * x + B * y + D ) / C
	endfunction

	/// Returns the distance between two points.
	/// Uses z values, too.
 function GetDistanceBetweenPoints takes real x0,real y0,real z0,real x1,real y1,real z1 returns real
  local real distanceX= ( x1 - x0 )
  local real distanceY= ( y1 - y0 )
  local real distanceZ= ( z1 - z0 )
		return SquareRoot(( distanceX * distanceX ) + ( distanceY * distanceY ) + ( distanceZ * distanceZ ))
	endfunction

	/// Returns the centre between two points.
	/// Achtung: Z muss ignoriert werden, da sich kein Punkt mit einem Z-Wert erstellen lässt.
 function GetCentreBetweenPoints takes real x0,real y0,real x1,real y1 returns location
		return Location(( ( x0 + x1 ) / 2.0 ) , ( ( y0 + y1 ) / 2.0 ))
	endfunction

	/// Der X-Wert des Punktes der Funktion "GetPolarProjectionOfPoint".
 function GetPolarProjectionX takes real x,real angle,real distance returns real
		return ( x + distance * Cos(angle * bj_DEGTORAD) )
	endfunction

	/// Der Y-Wert des Punktes der Funktion "GetPolarProjectionOfPoint".
 function GetPolarProjectionY takes real Y,real angle,real distance returns real
		return ( Y + distance * Sin(angle * bj_DEGTORAD) )
	endfunction

	/// Eine andere Version der Funktion "PolarProjectionBJ" ohne Location-Parameter.
 function GetPolarProjectionOfPoint takes real x,real y,real angle,real distance returns location
  local real resultX= ( x + distance * Cos(angle * bj_DEGTORAD) )
  local real resultY= ( y + distance * Sin(angle * bj_DEGTORAD) )
		return Location(resultX , resultY)
	endfunction

	/// Der Winkel zwischen zwei Punkten in Grad.
	/// "AngleBetweenPoints" ist der Gegensatz dazu mit "Locations -> blizzard.j".
 function GetAngleBetweenPoints takes real x0,real y0,real x1,real y1 returns real
		return Atan2BJ(( y1 - y0 ) , ( x1 - x0 ))
	endfunction

	/// Der Winkel zwischen zwei Punkten in Grad.
	/// "CentreX" und "CentreY" stellen dabei den Mittelpunkt dar, von dem aus die Winkel berechnet werden.
 function GetAngleBetweenPointsFromCentre takes real centreX,real centreY,real x0,real y0,real x1,real y1 returns real
  local real ax= ( x0 - centreX )
  local real ay= ( y0 - centreY )
  local real bx= ( x1 - centreX )
  local real by= ( y1 - centreY )
  local real a= SquareRoot(( ax * ax ) + ( ax * ax ))
  local real b= SquareRoot(( bx * bx ) + ( by * by ))
		return AcosBJ(( ( ax * bx ) + ( ay * by ) ) / ( a * b ))
	endfunction


//library ALibraryCoreMathsPoint ends
//library ALibraryCoreMathsReal:

	/// @author WaterKnight
	/// @source http://www.inwarcraft.de/
	/// Siehe RoundTo.
 function ALibraryCoreMathsReal__RoundToGetDifference takes real dividend,real divisor returns real
		return RAbsBJ(dividend - R2I(dividend / divisor) * divisor)
	endfunction

	/// @author WaterKnight
	/// Gibt das von base nächstgelegene Vielfache von interval zurck. Also praktisch ein allgemeines Runden. Ist @param interval 0, so gibt die Funktion 0 zurück.
	/// Sollte der Abstand gleich sein, hat das Ergebnis mit dem kleineren Betrag Vorrang. RoundToGetDifference ist für RoundTo gedacht, deswegen habe ich eine Sicherheitsmanahme, die eine Nulldivision verhindern würde, ausgelassen, da diese schon bei RoundTo stattfindet.
 function RoundTo takes real base,real interval returns real
  local real difference1
  local real difference2
		if ( interval == 0 ) then
			return 0.0
		endif
		set difference1 = ALibraryCoreMathsReal__RoundToGetDifference(base , interval)
		set difference2 = RAbsBJ(interval) - difference1
		if ( difference2 < difference1 ) then
			return ( base + RSignBJ(interval) * difference2 )
		endif
		return ( base - RSignBJ(interval) * difference1 )
	endfunction

	/// @author Shadow1500
	/// @source http://www.hiveworkshop.com/
	/// @return Returns the height.
 function JumpParabola takes real distance,real maxDistance,real curve returns real
  local real t= ( distance * 2 ) / maxDistance - 1
		return ( - t * t + 1 ) * ( maxDistance / curve )
	endfunction

	/// @author Vexorian
	/// @source http://www.wc3campaigns.net/
 function Log takes real x,integer iterations returns real
  local real min= - 88.0
  local real max= 88.0
  local real mid
  local integer i= iterations
		loop
			set mid = ( min + max ) / 2
			exitwhen ( i <= 0 )
			set i = i - 1
			if ( Pow(bj_E , mid) >= x ) then
				set max = mid
			else
				set min = mid
			endif
		endloop
		return mid
	endfunction

	/// @author Vexorian
	/// @source http://www.wc3campaigns.net/
 function Logarithm takes real base,real x,integer iterations returns real
  local real min= - 88.0
  local real max= 88.0
  local real mid
  local integer i= iterations
		loop
			set mid = ( min + max ) / 2
			exitwhen ( i <= 0 )
			set i = i - 1
			if ( Pow(base , mid) >= x ) then
				set max = mid
			else
				set min = mid
			endif
		endloop
		return mid
	endfunction


//library ALibraryCoreMathsReal ends
//library ALibraryCoreMathsRect:

	/// Das Gebiet an dem sich zwei Gebiete überschneiden.
	/// Überschneiden sich die Gebiete nicht, gibt die Funktion null zurck.
 function GetRectsBorderRect takes rect rect0,rect rect1 returns rect
  local real x0= RMaxBJ(GetRectMinX(rect0) , GetRectMinX(rect1))
  local real x1= RMinBJ(GetRectMaxX(rect0) , GetRectMaxX(rect1))
  local real y0= RMaxBJ(GetRectMinY(rect0) , GetRectMinY(rect1))
  local real y1= RMinBJ(GetRectMaxY(rect0) , GetRectMaxY(rect1))
		if ( ( x0 > x1 ) or ( y0 > y1 ) ) then
			return null
		endif
		return Rect(x0 , y0 , x1 , y1)
	endfunction

	/// Alternative zu @function RectFromCenterSizeBJ.
 function RectFromPointSize takes real x,real y,real width,real height returns rect
		return Rect(( x - width * 0.5 ) , ( y - height * 0.5 ) , ( x + width * 0.5 ) , ( y + height * 0.5 ))
	endfunction

 function SetRectByCoordinates takes rect usedRect,real x1,real y1,real x2,real y2,real x3,real y3,real x4,real y4 returns nothing
  local real minX= 0.0
  local real maxX= 0.0
  local real minY= 0.0
  local real maxY= 0.0

		if ( x1 >= x2 and x1 >= x3 and x1 >= x4 ) then
			set maxX = x1
		elseif ( x2 >= x1 and x2 >= x3 and x2 >= x4 ) then
			set maxX = x2
		elseif ( x3 >= x1 and x3 >= x2 and x3 >= x4 ) then
			set maxX = x3
		else
			set maxX = x4
		endif
	
		if ( x1 <= x2 and x1 <= x3 and x1 <= x4 ) then
			set minX = x1
		elseif ( x2 <= x1 and x2 <= x3 and x2 <= x4 ) then
			set minX = x2
		elseif ( x3 <= x1 and x3 <= x2 and x3 <= x4 ) then
			set minX = x3
		else
			set minX = x4
		endif

		if ( y1 >= y2 and y1 >= y3 and y1 >= y4 ) then
			set maxY = y1
		elseif ( y2 >= y1 and y2 >= y3 and y2 >= y4 ) then
			set maxY = y2
		elseif ( y3 >= y1 and y3 >= y2 and y3 >= y4 ) then
			set maxY = y3
		else
			set maxY = y4
		endif
	
		if ( y1 <= y2 and y1 <= y3 and y1 <= y4 ) then
			set minY = y1
		elseif ( y2 <= y1 and y2 <= y3 and y2 <= y4 ) then
			set minY = y2
		elseif ( y3 <= y1 and y3 <= y2 and y3 <= y4 ) then
			set minY = y3
		else
			set minY = y4
		endif

		call SetRect(usedRect , minX , minY , maxX , maxY)
	endfunction

 function GetGroupInRectByCoordinates takes real x1,real y1,real x2,real y2,real x3,real y3,real x4,real y4 returns group
  local rect usedRect= Rect(0.0 , 0.0 , 0.0 , 0.0)
  local group usedGroup= CreateGroup()
  local unit firstUnit= null
  local real firstUnitX= 0.0
  local real firstUnitY= 0.0
		call SetRectByCoordinates(usedRect , x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4)
		call GroupEnumUnitsInRect(usedGroup , usedRect , null)
		loop
			set firstUnit = FirstOfGroup(usedGroup)
			exitwhen ( firstUnit == null )
	
			set firstUnitX = GetUnitX(firstUnit)
			set firstUnitY = GetUnitY(firstUnit)

			if ( ( firstUnitY - y1 ) * ( x2 - x1 ) - ( firstUnitX - x1 ) * ( y2 - y1 ) > 0.0 ) then
				call GroupRemoveUnit(usedGroup , firstUnit)
			elseif ( ( firstUnitY - y2 ) * ( x3 - x2 ) - ( firstUnitX - x2 ) * ( y3 - y2 ) > 0.0 ) then
				call GroupRemoveUnit(usedGroup , firstUnit)
			elseif ( ( firstUnitY - y3 ) * ( x4 - x3 ) - ( firstUnitX - x3 ) * ( y4 - y3 ) > 0.0 ) then
				call GroupRemoveUnit(usedGroup , firstUnit)
			elseif ( ( firstUnitY - y4 ) * ( x1 - x4 ) - ( firstUnitX - x4 ) * ( y1 - y4 ) > 0.0 ) then
				call GroupRemoveUnit(usedGroup , firstUnit)
			endif
			set firstUnit = null
		endloop
		call RemoveRect(usedRect)
		set usedRect = null
		return usedGroup
	endfunction


//library ALibraryCoreMathsRect ends
//library ALibraryCoreMathsRegion:

//library ALibraryCoreMathsRegion ends
//library ALibraryObjectsDoodads:

	//Tileset List
	//* A Ashenvale
	//* B Barrens
	//* C Felwood
	//* D Dungeon
	//* F Lordaeron Fall
	//* G Underground
	//* L Lordaeron Summer
	//* N Northrend
	//* Q Village Fall
	//* V Village
	//* W Lordaeron Winter
	//* X Dalaran
	//* Y Cityscape
	//* Z Sunken Ruins
	//* I Icecrown
	//* J Dalaran Ruins
	//* O Outland
	//* K Black Citadel

	//example: //! runtextmacro A_DOODAD("Z000", "Pilz", "Pilz", "Grasland", "1.0")
	
	//File parameter without the mdx postfix
	
	
	//Grasland
	////! runtextmacro A_AMBIENT_DOODAD("Z000", "Amboss", "Amboss", "Grasland", "1")
	
	//Island
	
	//Mountains
	
	//Special - Extra
	
	//Swamp


//library ALibraryObjectsDoodads ends
//library ALibraryObjectsUnits:



//library ALibraryObjectsUnits ends
//library AStructCoreGeneralSlkTableEntry:

	/// This struct is a basic inheritance struct for SLK tables.
	/// SLK tables are used by Warcraft 3 for saving object data of various kinds of objects like doodads, units etc..
	/// @todo There exists a problem with strings because their quotes will be ignored.

		/// This method is based on the JassHelper manual's example.
  function s__ASlkTableEntry_getEntry takes integer index returns integer
			if ( s__ASlkTableEntry_entry[index] == 0 ) then
				set s__ASlkTableEntry_entry[index]=s__ASlkTableEntry__allocate()
			endif
			return s__ASlkTableEntry_entry[index]
  endfunction


//library AStructCoreGeneralSlkTableEntry ends
//library AStructSystemsCharacterAbstractCharacterSystem:

		//static method create takes ACharacter character returns ACharacterSystemInterface

		//start members

		//start members

  function s__AAbstractCharacterSystem_getCharacter takes integer this returns integer
			return s__AAbstractCharacterSystem_character[this]
  endfunction

		//convenience methods

  function s__AAbstractCharacterSystem_getUser takes integer this returns player
			return sc__ACharacter_getUser(s__AAbstractCharacterSystem_character[this])
  endfunction

  function s__AAbstractCharacterSystem_getUnit takes integer this returns unit
			return sc__ACharacter_getUsedUnit(s__AAbstractCharacterSystem_character[this])
  endfunction

		//methods

  function s__AAbstractCharacterSystem_enable takes integer this returns nothing
  endfunction

  function s__AAbstractCharacterSystem_disable takes integer this returns nothing
  endfunction

  function s__AAbstractCharacterSystem_create takes integer character returns integer
   local integer this= s__AAbstractCharacterSystem__allocate()
			//start members
			set s__AAbstractCharacterSystem_character[this]=character

			return this
  endfunction


//library AStructSystemsCharacterAbstractCharacterSystem ends
//library AStructSystemsCharacterClass:

		//static constant members
		//static start members
		//dynamic members
		//start members

		//dynamic members

  function s__AClass_setAbilityIconPath takes integer this,integer number,string abilityIconPath returns nothing
			set s___AClass_abilityIconPath[s__AClass_abilityIconPath[this]+number]=abilityIconPath
  endfunction

  function s__AClass_getAbilityIconPath takes integer this,integer number returns string
			return s___AClass_abilityIconPath[s__AClass_abilityIconPath[this]+number]
  endfunction

  function s__AClass_setUsedAbility takes integer this,integer number,integer usedAbility returns nothing
			set s___AClass_usedAbility[s__AClass_usedAbility[this]+number]=usedAbility
  endfunction

  function s__AClass_getUsedAbility takes integer this,integer number returns integer
			return s___AClass_usedAbility[s__AClass_usedAbility[this]+number]
  endfunction

  function s__AClass_setDescriptionLine takes integer this,integer number,string descriptionLine returns nothing
			set s___AClass_descriptionLine[s__AClass_descriptionLine[this]+number]=descriptionLine
  endfunction

  function s__AClass_getDescriptionLine takes integer this,integer number returns string
			return s___AClass_descriptionLine[s__AClass_descriptionLine[this]+number]
  endfunction

		//start members

		/// Friend relation to AClassSelection, don't use.
  function s__AClass_getUnitType takes integer this returns integer
			return s__AClass_unitType[this]
  endfunction

		/// Friend relation to AClassSelection, don't use.
  function s__AClass_getAnimation takes integer this returns string
			return s__AClass_animation[this]
  endfunction

		/// Friend relation to AClassSelection, don't use.
  function s__AClass_getSoundPath takes integer this returns string
			return s__AClass_soundPath[this]
  endfunction

		//methods

  function s__AClass_containsAbility takes integer this,integer usedAbility returns boolean
   local integer i= 0
			loop
				exitwhen ( i == s__AClass_maxAbilities )
				if ( s___AClass_usedAbility[s__AClass_usedAbility[this]+i] == usedAbility ) then
					return true
				endif
				set i = i + 1
			endloop
			return false
  endfunction

  function s__AClass_generateUnit takes integer this,player user,real x,real y,real facing returns unit
   local unit usedUnit= CreateUnit(user , s__AClass_unitType[this] , x , y , facing)
			call SetHeroLevelBJ(usedUnit , s__AClass_startLevel , false)
			call UnitModifySkillPoints(usedUnit , ( s__AClass_startSkillPoints - GetHeroSkillPoints(usedUnit) )) //Setzt die Fhigkeiten-Punkte
			return usedUnit
  endfunction

		/// @param unitType Should be the type of a hero
  function s__AClass_create takes integer unitType,string animation,string soundPath returns integer
   local integer this= s__AClass__allocate()
			//start members
			set s__AClass_unitType[this]=unitType
			set s__AClass_animation[this]=animation
			set s__AClass_soundPath[this]=soundPath

			return this
  endfunction

  function s__AClass_init takes integer startLevel,integer startSkillPoints returns nothing
			//static start members
			set s__AClass_startLevel=startLevel
			set s__AClass_startSkillPoints=startSkillPoints
  endfunction


//library AStructSystemsCharacterClass ends
//library ALibraryCoreGeneralDebug:

	/// Displays text on the screen if the debug mode is enabled.
	/// DebugMsg: Your Message - Echoes Your Message to logs//war3erruser.txt
	/// Ursprünglich war es eine Platzhalter-Funktion.
	/// @author Tamino Dauth
	/// @param message The message which will be shown on the screen and if Warcraft is started with Grimore it prints the messag into logs//war3err.txt.
  function Print takes string message returns nothing
   local integer i
   local player user
   set i = 0
   loop
    exitwhen ( i == bj_MAX_PLAYERS )
    set user = Player(i)
    if ( IsPlayerPlayingUser(user) ) then
     call DisplayTimedTextToPlayer(user , 0.0 , 0.0 , 999999.0 , message)
    endif
    set user = null
    set i = i + 1
   endloop
   call Cheat("DebugMsg:" + message) //JNGP
  endfunction

	/// Useful for getting the causing struct and instance of the debug message.
	/// Displays the string @param message in the following schema: "<structname> - <instanceid>: <message>"
	/// @author Tamino Dauth

	/// war3err DumpGlobalHT - prints the names and values of all global variables to logs//war3err.txt
	/// @author Tamino Dauth
  function PrintGlobals takes nothing returns nothing
   call Cheat("war3err DumpGlobalHT") //JNGP
  endfunction

	/// war3err DumpLocalHT - As above, but for the local variables of the current scope
	/// @author Tamino Dauth
  function PrintLocals takes nothing returns nothing
   call Cheat("war3err DumpLocalHT") //JNGP
  endfunction

	/// PauseTracer: If bytecode logging is enabled, this pauses recording
	/// @author Tamino Dauth
  function PauseBytecodeLogging takes nothing returns nothing
   call Cheat("PauseTracer")
  endfunction

	/// ContinueTracer: If bytecode logging is enabled, this resumes recording
	/// @author Tamino Dauth
  function ContinueBytecodeLogging takes nothing returns nothing
   call Cheat("ContinueTracer")
  endfunction


//library ALibraryCoreGeneralDebug ends
//library ALibraryCoreMathsHandle:


//textmacro instance: ALibraryMathsHandleMacro("widget", "Widget")
  function GetWidgetZ takes widget Widget returns real
			return GetTerrainZ(GetWidgetX(Widget) , GetWidgetY(Widget))
		endfunction

		/// Returns the distance between two Widgets.
		/// Da es die Natives "GetWidgetX" und "GetWidgetY" gibt, dürfte es schneller sein als erst Locations der Widgets zu erzeugen und diese zu vergleichen.
		/// Achtung: Beim Ignorieren des Z-Wertes "z0" und "z1" 0 bergeben.
  function GetDistanceBetweenWidgets takes widget Widget0,widget Widget1,real z0,real z1 returns real
			return GetDistanceBetweenPoints(GetWidgetX(Widget0) , GetWidgetY(Widget0) , z0 , GetWidgetX(Widget1) , GetWidgetY(Widget1) , z1)
		endfunction

		/// Returns the centre location between two Widgets.
		/// Achtung: Z muss ignoriert werden, da sich kein Punkt mit einem Z-Wert erstellen lässt.
  function GetCentreBetweenWidgets takes widget Widget0,widget Widget1 returns location
			return GetCentreBetweenPoints(GetWidgetX(Widget0) , GetWidgetY(Widget0) , GetWidgetX(Widget1) , GetWidgetY(Widget1))
		endfunction

  function GetWidgetPolarProjectionX takes widget Widget,real angle,real distance returns real
			return GetPolarProjectionX(GetWidgetX(Widget) , angle , distance)
		endfunction

  function GetWidgetPolarProjectionY takes widget Widget,real angle,real distance returns real
			return GetPolarProjectionY(GetWidgetY(Widget) , angle , distance)
		endfunction

		/// Returns the angle between two Widgets.
		/// Da es die Natives "GetWidgetX" und "GetWidgetY" gibt, dürfte es schneller sein als erst Locations der Widgets zu erzeugen und diese zu vergleichen.
  function GetAngleBetweenWidgets takes widget Widget0,widget Widget1 returns real
			return GetAngleBetweenPoints(GetWidgetX(Widget0) , GetWidgetY(Widget0) , GetWidgetX(Widget1) , GetWidgetY(Widget1))
		endfunction

  function RectFromWidgetSize takes widget Widget,real width,real height returns rect
			return RectFromPointSize(GetWidgetX(Widget) , GetWidgetY(Widget) , width , height)
		endfunction
//end of: ALibraryMathsHandleMacro("widget", "Widget")
//textmacro instance: ALibraryMathsHandleMacro("unit", "Unit")
  function GetUnitZ takes unit Unit returns real
			return GetTerrainZ(GetUnitX(Unit) , GetUnitY(Unit))
		endfunction

		/// Returns the distance between two Units.
		/// Da es die Natives "GetUnitX" und "GetUnitY" gibt, dürfte es schneller sein als erst Locations der Units zu erzeugen und diese zu vergleichen.
		/// Achtung: Beim Ignorieren des Z-Wertes "z0" und "z1" 0 bergeben.
  function GetDistanceBetweenUnits takes unit Unit0,unit Unit1,real z0,real z1 returns real
			return GetDistanceBetweenPoints(GetUnitX(Unit0) , GetUnitY(Unit0) , z0 , GetUnitX(Unit1) , GetUnitY(Unit1) , z1)
		endfunction

		/// Returns the centre location between two Units.
		/// Achtung: Z muss ignoriert werden, da sich kein Punkt mit einem Z-Wert erstellen lässt.
  function GetCentreBetweenUnits takes unit Unit0,unit Unit1 returns location
			return GetCentreBetweenPoints(GetUnitX(Unit0) , GetUnitY(Unit0) , GetUnitX(Unit1) , GetUnitY(Unit1))
		endfunction

  function GetUnitPolarProjectionX takes unit Unit,real angle,real distance returns real
			return GetPolarProjectionX(GetUnitX(Unit) , angle , distance)
		endfunction

  function GetUnitPolarProjectionY takes unit Unit,real angle,real distance returns real
			return GetPolarProjectionY(GetUnitY(Unit) , angle , distance)
		endfunction

		/// Returns the angle between two Units.
		/// Da es die Natives "GetUnitX" und "GetUnitY" gibt, dürfte es schneller sein als erst Locations der Units zu erzeugen und diese zu vergleichen.
  function GetAngleBetweenUnits takes unit Unit0,unit Unit1 returns real
			return GetAngleBetweenPoints(GetUnitX(Unit0) , GetUnitY(Unit0) , GetUnitX(Unit1) , GetUnitY(Unit1))
		endfunction

  function RectFromUnitSize takes unit Unit,real width,real height returns rect
			return RectFromPointSize(GetUnitX(Unit) , GetUnitY(Unit) , width , height)
		endfunction
//end of: ALibraryMathsHandleMacro("unit", "Unit")
//textmacro instance: ALibraryMathsHandleMacro("destructable", "Destructable")
  function GetDestructableZ takes destructable Destructable returns real
			return GetTerrainZ(GetDestructableX(Destructable) , GetDestructableY(Destructable))
		endfunction

		/// Returns the distance between two Destructables.
		/// Da es die Natives "GetDestructableX" und "GetDestructableY" gibt, dürfte es schneller sein als erst Locations der Destructables zu erzeugen und diese zu vergleichen.
		/// Achtung: Beim Ignorieren des Z-Wertes "z0" und "z1" 0 bergeben.
  function GetDistanceBetweenDestructables takes destructable Destructable0,destructable Destructable1,real z0,real z1 returns real
			return GetDistanceBetweenPoints(GetDestructableX(Destructable0) , GetDestructableY(Destructable0) , z0 , GetDestructableX(Destructable1) , GetDestructableY(Destructable1) , z1)
		endfunction

		/// Returns the centre location between two Destructables.
		/// Achtung: Z muss ignoriert werden, da sich kein Punkt mit einem Z-Wert erstellen lässt.
  function GetCentreBetweenDestructables takes destructable Destructable0,destructable Destructable1 returns location
			return GetCentreBetweenPoints(GetDestructableX(Destructable0) , GetDestructableY(Destructable0) , GetDestructableX(Destructable1) , GetDestructableY(Destructable1))
		endfunction

  function GetDestructablePolarProjectionX takes destructable Destructable,real angle,real distance returns real
			return GetPolarProjectionX(GetDestructableX(Destructable) , angle , distance)
		endfunction

  function GetDestructablePolarProjectionY takes destructable Destructable,real angle,real distance returns real
			return GetPolarProjectionY(GetDestructableY(Destructable) , angle , distance)
		endfunction

		/// Returns the angle between two Destructables.
		/// Da es die Natives "GetDestructableX" und "GetDestructableY" gibt, dürfte es schneller sein als erst Locations der Destructables zu erzeugen und diese zu vergleichen.
  function GetAngleBetweenDestructables takes destructable Destructable0,destructable Destructable1 returns real
			return GetAngleBetweenPoints(GetDestructableX(Destructable0) , GetDestructableY(Destructable0) , GetDestructableX(Destructable1) , GetDestructableY(Destructable1))
		endfunction

  function RectFromDestructableSize takes destructable Destructable,real width,real height returns rect
			return RectFromPointSize(GetDestructableX(Destructable) , GetDestructableY(Destructable) , width , height)
		endfunction
//end of: ALibraryMathsHandleMacro("destructable", "Destructable")
//textmacro instance: ALibraryMathsHandleMacro("item", "Item")
  function GetItemZ takes item Item returns real
			return GetTerrainZ(GetItemX(Item) , GetItemY(Item))
		endfunction

		/// Returns the distance between two Items.
		/// Da es die Natives "GetItemX" und "GetItemY" gibt, dürfte es schneller sein als erst Locations der Items zu erzeugen und diese zu vergleichen.
		/// Achtung: Beim Ignorieren des Z-Wertes "z0" und "z1" 0 bergeben.
  function GetDistanceBetweenItems takes item Item0,item Item1,real z0,real z1 returns real
			return GetDistanceBetweenPoints(GetItemX(Item0) , GetItemY(Item0) , z0 , GetItemX(Item1) , GetItemY(Item1) , z1)
		endfunction

		/// Returns the centre location between two Items.
		/// Achtung: Z muss ignoriert werden, da sich kein Punkt mit einem Z-Wert erstellen lässt.
  function GetCentreBetweenItems takes item Item0,item Item1 returns location
			return GetCentreBetweenPoints(GetItemX(Item0) , GetItemY(Item0) , GetItemX(Item1) , GetItemY(Item1))
		endfunction

  function GetItemPolarProjectionX takes item Item,real angle,real distance returns real
			return GetPolarProjectionX(GetItemX(Item) , angle , distance)
		endfunction

  function GetItemPolarProjectionY takes item Item,real angle,real distance returns real
			return GetPolarProjectionY(GetItemY(Item) , angle , distance)
		endfunction

		/// Returns the angle between two Items.
		/// Da es die Natives "GetItemX" und "GetItemY" gibt, dürfte es schneller sein als erst Locations der Items zu erzeugen und diese zu vergleichen.
  function GetAngleBetweenItems takes item Item0,item Item1 returns real
			return GetAngleBetweenPoints(GetItemX(Item0) , GetItemY(Item0) , GetItemX(Item1) , GetItemY(Item1))
		endfunction

  function RectFromItemSize takes item Item,real width,real height returns rect
			return RectFromPointSize(GetItemX(Item) , GetItemY(Item) , width , height)
		endfunction
//end of: ALibraryMathsHandleMacro("item", "Item")


//library ALibraryCoreMathsHandle ends
//library ALibraryCoreMathsLocation:

	/// Returns the distance between location @param location0 and @param location1.
	/// Benutzt im Gegensatz zur originalen Funktion den Z-Wert.
 function GetDistanceBetweenLocations takes location location0,location location1 returns real
		return GetDistanceBetweenPoints(GetLocationX(location0) , GetLocationY(location0) , GetLocationZ(location0) , GetLocationX(location1) , GetLocationY(location1) , GetLocationZ(location1))
	endfunction

	/// Returns the centre location between location @param location0 and @param location1.
	/// Achtung: Z muss ignoriert werden, da sich kein Punkt mit einem Z-Wert erstellen lässt.
 function GetCentreBetweenLocations takes location location0,location location1 returns location
		return GetCentreBetweenPoints(GetLocationX(location0) , GetLocationY(location0) , GetLocationX(location1) , GetLocationY(location1))
	endfunction

	/// Returns the angle between location @param location0 and @param location1 from centre location @param centre.
 function GetAngleBetweenLocationsFromCentre takes location centre,location location0,location location1 returns real
		return GetAngleBetweenPointsFromCentre(GetLocationX(centre) , GetLocationY(centre) , GetLocationX(location0) , GetLocationY(location0) , GetLocationX(location1) , GetLocationY(location1))
	endfunction


//library ALibraryCoreMathsLocation ends
//library AObjects:

//library AObjects ends
//library AStructCoreMathsPoint:

		//dynamic members

		//dynamic members

  function s__APoint_setX takes integer this,real x returns nothing
			set s__APoint_x[this]=x
  endfunction

  function s__APoint_getX takes integer this returns real
			return s__APoint_x[this]
  endfunction

  function s__APoint_setY takes integer this,real y returns nothing
			set s__APoint_y[this]=y
  endfunction

  function s__APoint_getY takes integer this returns real
			return s__APoint_y[this]
  endfunction

		//methods

  function s__APoint_getPolarProjectionX takes integer this,real angle,real distance returns real
			return GetPolarProjectionX(s__APoint_x[this] , angle , distance)
  endfunction

  function s__APoint_getPolarProjectionY takes integer this,real angle,real distance returns real
			return GetPolarProjectionY(s__APoint_y[this] , angle , distance)
  endfunction

  function s__APoint_getLocation takes integer this,real angle,real distance returns location
			return GetPolarProjectionOfPoint(s__APoint_getX(this) , s__APoint_getY(this) , angle , distance)
  endfunction

  function s__APoint_create takes real x,real y returns integer
   local integer this= s__APoint__allocate()
			//dynamic members
			set s__APoint_x[this]=x
			set s__APoint_y[this]=y

			return this
  endfunction


//library AStructCoreMathsPoint ends
//library ALibraryCoreMathsIndex:

	/// @todo private causes an error
  function DebugCheckIndex takes integer index returns nothing
   if ( index > JASS_MAX_ARRAY_SIZE ) then
    call Print("Index is too high: " + I2S(index))
   endif
  endfunction

 function Index2D takes integer value0,integer value1,integer maxValue1 returns integer
  local integer index= ( value0 * maxValue1 ) + value1
   call DebugCheckIndex(index)
		return index
	endfunction

 function Index3D takes integer value0,integer value1,integer value2,integer maxValue1,integer maxValue2 returns integer
  local integer index= ( value0 * ( maxValue1 * maxValue2 ) ) + ( value1 * maxValue2 ) + value2
   call DebugCheckIndex(index)
		return index
	endfunction

 function Index4D takes integer value0,integer value1,integer value2,integer value3,integer maxValue1,integer maxValue2,integer maxValue3 returns integer
  local integer index= ( value0 * ( maxValue1 * maxValue2 * maxValue3 ) ) + ( value1 * ( maxValue2 * maxValue3 ) ) + ( value2 * maxValue3 ) + value3
   call DebugCheckIndex(index)
		return index
	endfunction


//library ALibraryCoreMathsIndex ends
//library ALibraryCoreMathsItem:

	/// Doesn't create locations.
 function SetItemPolarProjectionPosition takes item usedItem,real angle,real distance returns nothing
  local real x= GetItemPolarProjectionX(usedItem , angle , distance)
  local real y= GetItemPolarProjectionY(usedItem , angle , distance)
		call SetItemPosition(usedItem , x , y)
	endfunction


//library ALibraryCoreMathsItem ends
//library ALibraryCoreMathsUnit:

	/// Die Entfernung zwischen zwei Einheiten.
	/// Da es die nativen Funktionen GetUnitX() und GetUnitY() gibt, dürfte es schneller sein, als erst Locations der Einheiten zu erzeugen und diese zu vergleichen.
	/// Achtung: Nur verwenden, wenn man auch wirklich den Z-Wert braucht.
	/// @return The distance between the units.
 function GetDistanceBetweenUnitsWithZ takes unit unit0,unit unit1 returns real
  local location unitLocation0= GetUnitLoc(unit0)
  local location unitLocation1= GetUnitLoc(unit1)
  local real distance=  GetDistanceBetweenUnits(unit0 , unit1 , GetLocationZ(unitLocation0) , GetLocationZ(unitLocation1)) //ALibraryMathsHandle
		call RemoveLocation(unitLocation0)
		set unitLocation0 = null
		call RemoveLocation(unitLocation1)
		set unitLocation1 = null
		return distance
	endfunction

	/// Does not create any locations.
 function SetUnitPolarProjectionPosition takes unit usedUnit,real angle,real distance returns nothing
  local real x= GetUnitPolarProjectionX(usedUnit , angle , distance) //ALibraryMathsHandle
  local real y= GetUnitPolarProjectionY(usedUnit , angle , distance) //ALibraryMathsHandle
		call SetUnitPosition(usedUnit , x , y)
		call SetUnitFacing(usedUnit , angle)
	endfunction

	/// Makes a unit flyable by adding and removing the ability Crow Form.
	/// Thus you can change its high.
 function MakeUnitFlyable takes unit usedUnit returns nothing
		if ( GetUnitAbilityLevel(usedUnit , 'Amrf') == 0 ) then
			call UnitAddAbility(usedUnit , 'Amrf')
			call UnitRemoveAbility(usedUnit , 'Amrf')
		endif
	endfunction

	/// Ändert die Höhe einer Einheit.
	/// Die neue Höhe muss >= der Bodenhöhe an dem Punkt, an dem sich die Einheit befindet, sein.
	/// @author WaterKnight
 function SetUnitZ takes unit usedUnit,real z returns nothing
		call MakeUnitFlyable(usedUnit)
		call SetUnitFlyHeight(usedUnit , z - GetUnitZ(usedUnit) , 0.0) //ALibraryMathsHandle
	endfunction

	/// Beschreibung: Die Funktionen setzen eine Einheit auf angegebene Koordinaten, falls die Einheit
	/// auf diesen stehen könnte. Dabei wird die Betrachtung für jede Koordinate separat ausgeführt.
	/// Das heißt, die Einheit könnte in eine Achsenrichtung bewegt werden, auch wenn sie es in die
	/// Zweite nicht kann. Dadurch slidet sie an Grenzen, wenn die Bewegung in eine Richtung möglich
	/// ist. Die Funktionen returnen, ob die Einheit erfolgreich an die gegebenen Koordinaten bewegt
	/// wurde.
	/// Hinweise: Um zu entscheiden, ob die Einheit geblockt wird, wird ein kleiner Toleranzbereich
	/// genommen. Auf Bewegung bezogene Ereignisse werden ausgeführt, auch wenn die Einheit im
	/// Endeffekt zurückgesetzt wurde. Sowohl das Prüfen als auch das Zurücksetzen der Position
	/// erfolgt über Bewegungsaktionen, die auf die Einheit angewandt werden. Da die Funktionen wohl
	/// im Zusammenhang mit rekursiven Fortbewegungssystemen einer Einheit gebraucht werden (die
	/// vorigen Koordinaten einer Einheit werden ausgelesen, um sie zum Beispiel für die Ermittlung
	/// der Nächsten zu verarbeiten), muss man bei allen drei Funktionen die alten
	/// Positionsinformationen der Einheit mitliefern. Das ist besser für die
	/// Schnelligkeitsperformance, als wenn man es mehrfach ausliest.
	/// @author WaterKnight
 function SetUnitXIfNotBlocked takes unit usedUnit,real oldX,real oldY,real x returns boolean
		call SetUnitPosition(usedUnit , x , oldY)
		if ( ( RAbsBJ(GetUnitX(usedUnit) - x) > 1 ) or ( RAbsBJ(GetUnitY(usedUnit) - oldY) > 1 ) ) then
			call SetUnitX(usedUnit , oldX)
			call SetUnitY(usedUnit , oldY)
			return false
		endif
		return true
	endfunction

	/// @author WaterKnight
 function SetUnitYIfNotBlocked takes unit usedUnit,real oldX,real oldY,real y returns boolean
		call SetUnitPosition(usedUnit , oldX , y)
		if ( ( RAbsBJ(GetUnitX(usedUnit) - oldX) > 1 ) or ( RAbsBJ(GetUnitY(usedUnit) - y) > 1 ) ) then
			call SetUnitX(usedUnit , oldX)
			call SetUnitY(usedUnit , oldY)
			return false
		endif
		return true
	endfunction

	/// @author WaterKnight
 function SetUnitXYIfNotBlocked takes unit usedUnit,real oldX,real oldY,real x,real y returns boolean
		if ( SetUnitXIfNotBlocked(usedUnit , oldX , oldY , x) ) then
			if ( SetUnitYIfNotBlocked(usedUnit , x , oldY , y) ) then
				return true
			endif
		else
			call SetUnitYIfNotBlocked(usedUnit , oldX , oldY , y)
		endif
		return false
	endfunction


//library ALibraryCoreMathsUnit ends
//library ALibraryCoreStringMisc:

	/// Debug for testing over- and underflow.
  function StringPositionDebug takes string usedString,integer position returns nothing
   if ( ( position < 0 ) or ( position >= StringLength(usedString) ) ) then
    call Print("StringPositionDebug: Wrong position value: " + I2S(position) + ".") //ALibraryGeneralDebug
   endif
  endfunction

	/// Searches for the position of string @param searchedString in string @param usedString.
	/// @state checked
	/// If @param searchedString is not contained by @param usedString function will return -1 otherwise it will return the position.
	/// @param usedString String which should contain the searched string.
	/// @param searchedString String which is searched.
	/// @return If the string was found it will return its position otherwise it will return -1.
 function FindString takes string usedString,string searchedString returns integer
  local integer i
  local integer exitvalue
   if ( StringLength(usedString) < StringLength(searchedString) ) then
    call Print("FindString: Used string is lesser than searched string.")
   endif
		//Gleicher Inhalt
		if ( usedString == searchedString ) then
			return 0
		endif
		set exitvalue = StringLength(usedString) - StringLength(searchedString)
		set i = 0
		loop
			exitwhen ( i > exitvalue ) //i ist nicht der zweite Positionsparameter
			if ( SubString(usedString , i , ( i + StringLength(searchedString) )) == searchedString ) then //added -1
				return i
			endif
			set i = i + 1
		endloop
		return - 1
	endfunction

	/// Replaces a part of a string and returns the resulting string.
	/// @state checked
	/// @param usedString String which contains the sub string.
	/// @param position Start position of the sub string.
	/// @param replacingString String which should replace the sub string.
	/// @return Returns the new string with the replaced sub string.
 function ReplaceSubString takes string usedString,integer position,string replacingString returns string
  local string result= ""
   call StringPositionDebug(usedString , position)
		if ( position > 0 ) then
			set result = SubString(usedString , 0 , position)
		endif
		set result = result + replacingString
		if ( StringLength(result) < StringLength(usedString) ) then
			set result = result + SubString(usedString , StringLength(result) , StringLength(usedString))
		endif
		return result
	endfunction

	/// Replaces string @param replacedString in string @param usedString by string @param replacingString and returns the resulting string.
	/// @state checked
	/// @param usedString String which contains the sub string @param replacedString.
	/// @param replacedString Sub string of string @param usedString which should be replaced.
	/// @param replacingString String which should replace @param replacedString.
	/// @return Returns the new string with the replaced sub string.
 function ReplaceString takes string usedString,string replacedString,string replacingString returns string
  local integer position= FindString(usedString , replacedString)
		if ( position != - 1 ) then
			return ReplaceSubString(usedString , position , replacingString)
		endif
		return usedString
	endfunction

	/// Removes the sub string at position @param position with length @param length of string @param usedString and returns the resulting string.
	/// @state checked
	/// @param usedString String which contains the sub string.
	/// @param position Position of the sub string.
	/// @param length Length of the sub string.
	/// @return Returns the new string with the replaced string.
 function RemoveSubString takes string usedString,integer position,integer length returns string
  local string result= "" //Has to be set otherwise usedString + ... doesn't work
   call StringPositionDebug(usedString , position + length - 1)
		if ( position > 0 ) then
			set result = SubString(usedString , 0 , position)
		endif
		if ( ( position + length ) < StringLength(usedString) ) then
			set result = result + SubString(usedString , position + length , StringLength(usedString))
		endif
		return result
	endfunction

	/// Removes string @param removedString from string @param subString and returns the resulting string. 
	/// @state checked
	/// @param usedString String @param subString should be removed from this string.
	/// @param removedString String which should be removed.
	/// @return Returns the new string without the removed string.
 function RemoveString takes string usedString,string removedString returns string
  local integer position= FindString(usedString , removedString)
		if ( position != - 1 ) then
			return RemoveSubString(usedString , position , StringLength(removedString))
		endif
		return usedString
	endfunction

	/// Inserts string @param insertedString into string @param usedString at position @param position and returns the resulting string.
	/// @state checked
	/// @param usedString String into which string @param insertedString should be inserted.
	/// @param position Position where string @param insertedString should be inserted.
	/// @param insertedString String which should be inserted into string @param usedString.
	/// @return Returns the new string with the inserted string.
 function InsertString takes string usedString,integer position,string insertedString returns string
  local string result= ""
   call StringPositionDebug(usedString , position)
		if ( position > 0 ) then
			set result = SubString(usedString , 0 , position)
		endif
		return result + insertedString + SubString(usedString , position , StringLength(usedString))
	endfunction

	/// Moves the sub string of string @param usedString at position @param position and with length @param length to position @param newPosition and returns the resulting string.
	/// @state checked
	/// @param usedString String in which the sub string should be moved.
	/// @param position Start position of the sub string.
	/// @param length Length of the sub string.
	/// @param newPosition Position to which the sub string should be moved.
	/// @return Returns the new string with the moved string.
 function MoveSubString takes string usedString,integer position,integer length,integer newPosition returns string
  local string result= ""
   call StringPositionDebug(usedString , position + length)
   call StringPositionDebug(usedString , newPosition)
		if ( position > 0 ) then
			set result = SubString(usedString , 0 , position)
		endif
		set result = result + SubString(usedString , newPosition , newPosition + length)
		set result = result + SubString(usedString , position , position + length)
		if ( StringLength(result) < StringLength(usedString) ) then
			set result = result + SubString(usedString , StringLength(result) , StringLength(usedString))
		endif
		return result
	endfunction

	/// Moves string @param movedString of string @param usedString to position @param newPosition and returns the resulting string.
	/// @state checked
	/// @param usedString String in which string @param movedString should be moved.
	/// @param movedString String which should be moved.
	/// @param newPosition Position to which string @param movedString should be moved.
	/// @return Returns the new string with the moved string.
 function MoveString takes string usedString,string movedString,integer newPosition returns string
  local integer position= FindString(usedString , movedString)
		if ( position != - 1 ) then
			return MoveSubString(usedString , position , StringLength(movedString) , newPosition)
		endif
		return usedString
	endfunction

	/// Reverses a string that it will be written backwards and returns the resulting string.
	/// @state checked
	/// @param usedString String which should be reversed.
	/// @return Returns the new reversed string.
 function ReverseString takes string usedString returns string
  local integer i
  local string result
		set i = StringLength(usedString)
		loop
			exitwhen ( i == 1 )
			set result = result + SubString(usedString , i - 1 , i)
			set i = i - 1
		endloop
		return result
	endfunction


//library ALibraryCoreStringMisc ends
//library AStructCoreGeneralContainer:

	/// Creates a new AContainer class with type @param ELEMENTTYPE, type name @param ELEMENTTYPENAME and maximum size @param MAXSIZE.
	/// Containers can hold several members of one specified data type like @type unit or @type integer.


//library AStructCoreGeneralContainer ends
//library AStructCoreGeneralHashTable:

	/// Provides access to a single game cache instance.
	/// @author Tamino Dauth
		//static members
		//start members

   function s__AHashTable_checkName takes string name returns integer
    local integer i= 0
    loop
     exitwhen ( i == s__AHashTable_hashTables )
     if ( s__AHashTable_name[(i)] == name ) then
      return (i)
     endif
     set i = i + 1
    endloop
			return 0
   endfunction


//textmacro instance: AHashTableOperationMacro("integer", "Integer")
   function s__AHashTable_storeInteger takes integer this,string key,string label,integer value returns nothing
				call StoreInteger(s__AHashTable_gameCache[this] , key , label , value)
   endfunction

   function s__AHashTable_hasStoredInteger takes integer this,string key,string label returns boolean
				return HaveStoredInteger(s__AHashTable_gameCache[this] , key , label)
   endfunction

   function s__AHashTable_flushStoredInteger takes integer this,string key,string label returns nothing
				call FlushStoredInteger(s__AHashTable_gameCache[this] , key , label)
   endfunction

   function s__AHashTable_getStoredInteger takes integer this,string key,string label returns integer
				return GetStoredInteger(s__AHashTable_gameCache[this] , key , label)
   endfunction

   function s__AHashTable_storeHandleInteger takes integer this,handle usedHandle,string label,integer value returns nothing
				call s__AHashTable_storeInteger(this,I2S(H2I(usedHandle)) , label , value) //ALibraryGeneralConversion
   endfunction

   function s__AHashTable_handleIntegerExists takes integer this,handle usedHandle,string label returns boolean
				return s__AHashTable_hasStoredInteger(this,I2S(H2I(usedHandle)) , label) //ALibraryGeneralConversion
   endfunction

   function s__AHashTable_flushHandleInteger takes integer this,handle usedHandle,string label returns nothing
				call s__AHashTable_flushStoredInteger(this,I2S(H2I(usedHandle)) , label) //ALibraryGeneralConversion
   endfunction

   function s__AHashTable_getHandleInteger takes integer this,handle usedHandle,string label returns integer
				return s__AHashTable_getStoredInteger(this,I2S(H2I(usedHandle)) , label) //ALibraryGeneralConversion
   endfunction
//end of: AHashTableOperationMacro("integer", "Integer")
//textmacro instance: AHashTableOperationMacro("boolean", "Boolean")
   function s__AHashTable_storeBoolean takes integer this,string key,string label,boolean value returns nothing
				call StoreBoolean(s__AHashTable_gameCache[this] , key , label , value)
   endfunction

   function s__AHashTable_hasStoredBoolean takes integer this,string key,string label returns boolean
				return HaveStoredBoolean(s__AHashTable_gameCache[this] , key , label)
   endfunction

   function s__AHashTable_flushStoredBoolean takes integer this,string key,string label returns nothing
				call FlushStoredBoolean(s__AHashTable_gameCache[this] , key , label)
   endfunction

   function s__AHashTable_getStoredBoolean takes integer this,string key,string label returns boolean
				return GetStoredBoolean(s__AHashTable_gameCache[this] , key , label)
   endfunction

   function s__AHashTable_storeHandleBoolean takes integer this,handle usedHandle,string label,boolean value returns nothing
				call s__AHashTable_storeBoolean(this,I2S(H2I(usedHandle)) , label , value) //ALibraryGeneralConversion
   endfunction

   function s__AHashTable_handleBooleanExists takes integer this,handle usedHandle,string label returns boolean
				return s__AHashTable_hasStoredBoolean(this,I2S(H2I(usedHandle)) , label) //ALibraryGeneralConversion
   endfunction

   function s__AHashTable_flushHandleBoolean takes integer this,handle usedHandle,string label returns nothing
				call s__AHashTable_flushStoredBoolean(this,I2S(H2I(usedHandle)) , label) //ALibraryGeneralConversion
   endfunction

   function s__AHashTable_getHandleBoolean takes integer this,handle usedHandle,string label returns boolean
				return s__AHashTable_getStoredBoolean(this,I2S(H2I(usedHandle)) , label) //ALibraryGeneralConversion
   endfunction
//end of: AHashTableOperationMacro("boolean", "Boolean")
//textmacro instance: AHashTableOperationMacro("real", "Real")
   function s__AHashTable_storeReal takes integer this,string key,string label,real value returns nothing
				call StoreReal(s__AHashTable_gameCache[this] , key , label , value)
   endfunction

   function s__AHashTable_hasStoredReal takes integer this,string key,string label returns boolean
				return HaveStoredReal(s__AHashTable_gameCache[this] , key , label)
   endfunction

   function s__AHashTable_flushStoredReal takes integer this,string key,string label returns nothing
				call FlushStoredReal(s__AHashTable_gameCache[this] , key , label)
   endfunction

   function s__AHashTable_getStoredReal takes integer this,string key,string label returns real
				return GetStoredReal(s__AHashTable_gameCache[this] , key , label)
   endfunction

   function s__AHashTable_storeHandleReal takes integer this,handle usedHandle,string label,real value returns nothing
				call s__AHashTable_storeReal(this,I2S(H2I(usedHandle)) , label , value) //ALibraryGeneralConversion
   endfunction

   function s__AHashTable_handleRealExists takes integer this,handle usedHandle,string label returns boolean
				return s__AHashTable_hasStoredReal(this,I2S(H2I(usedHandle)) , label) //ALibraryGeneralConversion
   endfunction

   function s__AHashTable_flushHandleReal takes integer this,handle usedHandle,string label returns nothing
				call s__AHashTable_flushStoredReal(this,I2S(H2I(usedHandle)) , label) //ALibraryGeneralConversion
   endfunction

   function s__AHashTable_getHandleReal takes integer this,handle usedHandle,string label returns real
				return s__AHashTable_getStoredReal(this,I2S(H2I(usedHandle)) , label) //ALibraryGeneralConversion
   endfunction
//end of: AHashTableOperationMacro("real", "Real")
//textmacro instance: AHashTableOperationMacro("string", "String")
   function s__AHashTable_storeString takes integer this,string key,string label,string value returns nothing
				call StoreString(s__AHashTable_gameCache[this] , key , label , value)
   endfunction

   function s__AHashTable_hasStoredString takes integer this,string key,string label returns boolean
				return HaveStoredString(s__AHashTable_gameCache[this] , key , label)
   endfunction

   function s__AHashTable_flushStoredString takes integer this,string key,string label returns nothing
				call FlushStoredString(s__AHashTable_gameCache[this] , key , label)
   endfunction

   function s__AHashTable_getStoredString takes integer this,string key,string label returns string
				return GetStoredString(s__AHashTable_gameCache[this] , key , label)
   endfunction

   function s__AHashTable_storeHandleString takes integer this,handle usedHandle,string label,string value returns nothing
				call s__AHashTable_storeString(this,I2S(H2I(usedHandle)) , label , value) //ALibraryGeneralConversion
   endfunction

   function s__AHashTable_handleStringExists takes integer this,handle usedHandle,string label returns boolean
				return s__AHashTable_hasStoredString(this,I2S(H2I(usedHandle)) , label) //ALibraryGeneralConversion
   endfunction

   function s__AHashTable_flushHandleString takes integer this,handle usedHandle,string label returns nothing
				call s__AHashTable_flushStoredString(this,I2S(H2I(usedHandle)) , label) //ALibraryGeneralConversion
   endfunction

   function s__AHashTable_getHandleString takes integer this,handle usedHandle,string label returns string
				return s__AHashTable_getStoredString(this,I2S(H2I(usedHandle)) , label) //ALibraryGeneralConversion
   endfunction
//end of: AHashTableOperationMacro("string", "String")

  function s__AHashTable_storeUnit takes integer this,string key,string label,unit usedUnit returns boolean
			return StoreUnit(s__AHashTable_gameCache[this] , key , label , usedUnit)
  endfunction

  function s__AHashTable_hasStoredUnit takes integer this,string key,string label returns boolean
			return HaveStoredUnit(s__AHashTable_gameCache[this] , key , label)
  endfunction

  function s__AHashTable_flushStoredUnit takes integer this,string key,string label returns nothing
			call FlushStoredUnit(s__AHashTable_gameCache[this] , key , label)
  endfunction

  function s__AHashTable_getStoredUnit takes integer this,string key,string label,player user,real x,real y,real facing returns unit
			return RestoreUnit(s__AHashTable_gameCache[this] , key , label , user , x , y , facing)
  endfunction

		/// Löscht alle Daten der Tabelle.
  function s__AHashTable_flush takes integer this returns nothing
			call FlushGameCache(s__AHashTable_gameCache[this])
  endfunction

		/// Speichert die Tabelle auf der Festplatte. Nur im Einzelspielermodus möglich.
  function s__AHashTable_save takes integer this returns boolean
			return SaveGameCache(s__AHashTable_gameCache[this])
  endfunction

  function s__AHashTable_flushKey takes integer this,string key returns nothing
			call FlushStoredMission(s__AHashTable_gameCache[this] , key)
  endfunction

  function s__AHashTable_flushHandleValues takes integer this,handle usedHandle returns nothing
			call s__AHashTable_flushKey(this,I2S(H2I(usedHandle))) //ALibraryGeneralConversion
  endfunction


//textmacro instance: AHashTableDestructionMacro("trigger", "Trigger", "Destroy")
   function s__AHashTable_destroyTrigger takes integer this,trigger Trigger returns nothing
				call s__AHashTable_flushHandleValues(this,Trigger)
				call DestroyTrigger(Trigger)
   endfunction
//end of: AHashTableDestructionMacro("trigger", "Trigger", "Destroy")
//textmacro instance: AHashTableDestructionMacro("timer", "Timer", "Destroy")
   function s__AHashTable_destroyTimer takes integer this,timer Timer returns nothing
				call s__AHashTable_flushHandleValues(this,Timer)
				call DestroyTimer(Timer)
   endfunction
//end of: AHashTableDestructionMacro("timer", "Timer", "Destroy")
//textmacro instance: AHashTableDestructionMacro("unit", "Unit", "Remove")
   function s__AHashTable_destroyUnit takes integer this,unit Unit returns nothing
				call s__AHashTable_flushHandleValues(this,Unit)
				call RemoveUnit(Unit)
   endfunction
//end of: AHashTableDestructionMacro("unit", "Unit", "Remove")
//textmacro instance: AHashTableDestructionMacro("item", "Item", "Remove")
   function s__AHashTable_destroyItem takes integer this,item Item returns nothing
				call s__AHashTable_flushHandleValues(this,Item)
				call RemoveItem(Item)
   endfunction
//end of: AHashTableDestructionMacro("item", "Item", "Remove")
//textmacro instance: AHashTableDestructionMacro("destructable", "Destructable", "Remove")
   function s__AHashTable_destroyDestructable takes integer this,destructable Destructable returns nothing
				call s__AHashTable_flushHandleValues(this,Destructable)
				call RemoveDestructable(Destructable)
   endfunction
//end of: AHashTableDestructionMacro("destructable", "Destructable", "Remove")

  function s__AHashTable_create takes string name returns integer
   local integer this= s__AHashTable__allocate()
    local integer instance= 0
    if ( s__AHashTable_hashTables < 256 ) then
     set instance = s__AHashTable_checkName(name)
     if ( instance == 0 ) then
      set s__AHashTable_hashTables=( s__AHashTable_hashTables + 1 )
     else
      set this = 0
      call Print("Hash table name " + name + " is already used by instance " + I2S(instance) + ".")
     endif
    else
     set this = 0
     call Print("Maximum of game caches reached.")
    endif
			//start members
			set s__AHashTable_gameCache[this]=InitGameCache(name)
    set s__AHashTable_name[this]=name

			return this
  endfunction

  function s__AHashTable_onDestroy takes integer this returns nothing
			//start members
			call FlushGameCache(s__AHashTable_gameCache[this])
			set s__AHashTable_gameCache[this]=null
  endfunction

//Generated destructor of AHashTable
function s__AHashTable_destroy takes integer this returns nothing
    if this==null then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: AHashTable")
        return
    elseif (si__AHashTable_V[this]!=-1) then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: AHashTable")
        return
    endif
    call s__AHashTable_onDestroy(this)
    set si__AHashTable_V[this]=si__AHashTable_F
    set si__AHashTable_F=this
endfunction


//library AStructCoreGeneralHashTable ends
//library AStructCoreGeneralStack:


	/// @todo Remove this after testing it.
//textmacro instance: A_STACK("integer", "Integer")
			//start members

			//start members

   function s__AStructCoreGeneralStack__AIntegerDataNode_getData takes integer this returns integer
				return s__AStructCoreGeneralStack__AIntegerDataNode_data[this]
   endfunction

   function s__AStructCoreGeneralStack__AIntegerDataNode_getNext takes integer this returns integer
				return s__AStructCoreGeneralStack__AIntegerDataNode_next[this]
   endfunction

			//methods

   function s__AStructCoreGeneralStack__AIntegerDataNode_create takes integer data,integer next returns integer
    local integer this= s__AStructCoreGeneralStack__AIntegerDataNode__allocate()
				set s__AStructCoreGeneralStack__AIntegerDataNode_data[this]=data
				set s__AStructCoreGeneralStack__AIntegerDataNode_next[this]=next

				return this
   endfunction

			//dynamic members
			//properties

			//dynamic members

   function s__AIntegerStack_setMaxSize takes integer this,integer maxSize returns nothing
				set s__AIntegerStack_maxSize[this]=maxSize
   endfunction

   function s__AIntegerStack_getMaxSize takes integer this returns integer
				return s__AIntegerStack_maxSize[this]
   endfunction

			//methods

			/// Adds a new elment to stack.
   function s__AIntegerStack_push takes integer this,integer data returns nothing
    local integer dataNode
				if ( s__AIntegerStack_objects[this] < s__AIntegerStack_maxSize[this] ) then
					set dataNode = s__AStructCoreGeneralStack__AIntegerDataNode_create(data , s__AIntegerStack_dataNode[this])
      if ( dataNode != 0 ) then
						set s__AIntegerStack_dataNode[this]=dataNode
						set s__AIntegerStack_objects[this]=s__AIntegerStack_objects[this] + 1
      else
       call Print("Stack " + I2S(this) + " is full - By jass limit.") //ALibraryGeneralDebug
      endif
     else
      call Print("Stack " + I2S(this) + " is full - By custom limit.") //ALibraryGeneralDebug
				endif
   endfunction

			/// Returns the supreme element and removes it from stack.
   function s__AIntegerStack_pop takes integer this returns integer
    local integer nodeData= 0
    local integer oldDataNode
     if ( s__AIntegerStack_dataNode[this] != 0 ) then
					set oldDataNode = s__AIntegerStack_dataNode[this]
					set s__AIntegerStack_dataNode[this]=s__AStructCoreGeneralStack__AIntegerDataNode_getNext(s__AIntegerStack_dataNode[this])
					set nodeData = s__AStructCoreGeneralStack__AIntegerDataNode_getData(oldDataNode)
					call s__AStructCoreGeneralStack__AIntegerDataNode_destroy(oldDataNode)
					set s__AIntegerStack_objects[this]=s__AIntegerStack_objects[this] - 1
     else
      call Print("Stack " + I2S(this) + " is empty.") //ALibraryGeneralDebug
     endif
				return nodeData
   endfunction

   function s__AIntegerStack_create takes integer maxSize returns integer
    local integer this= s__AIntegerStack__allocate()
				//dynamic members
				set s__AIntegerStack_maxSize[this]=maxSize
				//members
				set s__AIntegerStack_dataNode[this]=0
				set s__AIntegerStack_objects[this]=0

				return this
   endfunction
//end of: A_STACK("integer", "Integer")


//library AStructCoreGeneralStack ends
//library AStructCoreMathsCircle:

		//dynamic members

		//dynamic members

  function s__ACircle_setRadius takes integer this,real radius returns nothing
			set s__ACircle_radius[this]=radius
  endfunction

  function s__ACircle_getRadius takes integer this returns real
			return s__ACircle_radius[this]
  endfunction

		//methods

  function s__ACircle_getArea takes integer this returns real
			return Pow(s__ACircle_radius[this] , 2.0) * bj_PI
  endfunction

  function s__ACircle_containsPoint takes integer this,real x,real y returns boolean
			return ( GetDistanceBetweenPoints(x , y , 0.0 , s__APoint_getX(this) , s__APoint_getY(this) , 0.0) <= s__ACircle_radius[this] ) //ALibraryMathsPoint
  endfunction

		//instead of getX() and getY() it has to be a protected element
		//but there is no protected keyword...
  function s__ACircle_borderContainsPoint takes integer this,real X,real Y returns boolean
			return ( GetDistanceBetweenPoints(X , Y , 0.0 , s__APoint_getX(this) , s__APoint_getY(this) , 0.0) == s__ACircle_radius[this] ) //ALibraryMathsPoint
  endfunction

	
//textmacro instance: ACircleMacro("location", "Location")
   function s__ACircle_containsLocation takes integer this,location circleLocation returns boolean
				return s__ACircle_containsPoint(this,GetLocationX(circleLocation) , GetLocationY(circleLocation)) //Because of the location type I use the 'Circle' prefix
   endfunction
			
   function s__ACircle_borderContainsLocation takes integer this,location circleLocation returns boolean
				return s__ACircle_borderContainsPoint(this,GetLocationX(circleLocation) , GetLocationY(circleLocation))
   endfunction
//end of: ACircleMacro("location", "Location")
//textmacro instance: ACircleMacro("widget", "Widget")
   function s__ACircle_containsWidget takes integer this,widget circleWidget returns boolean
				return s__ACircle_containsPoint(this,GetWidgetX(circleWidget) , GetWidgetY(circleWidget)) //Because of the location type I use the 'Circle' prefix
   endfunction
			
   function s__ACircle_borderContainsWidget takes integer this,widget circleWidget returns boolean
				return s__ACircle_borderContainsPoint(this,GetWidgetX(circleWidget) , GetWidgetY(circleWidget))
   endfunction
//end of: ACircleMacro("widget", "Widget")
//textmacro instance: ACircleMacro("unit", "Unit")
   function s__ACircle_containsUnit takes integer this,unit circleUnit returns boolean
				return s__ACircle_containsPoint(this,GetUnitX(circleUnit) , GetUnitY(circleUnit)) //Because of the location type I use the 'Circle' prefix
   endfunction
			
   function s__ACircle_borderContainsUnit takes integer this,unit circleUnit returns boolean
				return s__ACircle_borderContainsPoint(this,GetUnitX(circleUnit) , GetUnitY(circleUnit))
   endfunction
//end of: ACircleMacro("unit", "Unit")
//textmacro instance: ACircleMacro("destructable", "Destructable")
   function s__ACircle_containsDestructable takes integer this,destructable circleDestructable returns boolean
				return s__ACircle_containsPoint(this,GetDestructableX(circleDestructable) , GetDestructableY(circleDestructable)) //Because of the location type I use the 'Circle' prefix
   endfunction
			
   function s__ACircle_borderContainsDestructable takes integer this,destructable circleDestructable returns boolean
				return s__ACircle_borderContainsPoint(this,GetDestructableX(circleDestructable) , GetDestructableY(circleDestructable))
   endfunction
//end of: ACircleMacro("destructable", "Destructable")
//textmacro instance: ACircleMacro("item", "Item")
   function s__ACircle_containsItem takes integer this,item circleItem returns boolean
				return s__ACircle_containsPoint(this,GetItemX(circleItem) , GetItemY(circleItem)) //Because of the location type I use the 'Circle' prefix
   endfunction
			
   function s__ACircle_borderContainsItem takes integer this,item circleItem returns boolean
				return s__ACircle_borderContainsPoint(this,GetItemX(circleItem) , GetItemY(circleItem))
   endfunction
//end of: ACircleMacro("item", "Item")

  function s__ACircle_getBorderLocation takes integer this,real angle returns location
			return GetPolarProjectionOfPoint(s__APoint_getX(this) , s__APoint_getY(this) , angle , s__ACircle_radius[this]) //ALibraryMathsPoint
  endfunction
	
  function s__ACircle_getRandomLocation takes integer this returns location
   local real distance= ( SquareRoot(GetRandomReal(0.0 , 1.0)) * s__ACircle_radius[this] )
   local real angle= GetRandomReal(0.0 , ( 2.0 * bj_PI ))
			return Location(( s__APoint_getX(this) + ( distance * Cos(angle) ) ) , ( s__APoint_getY(this) + ( distance * Sin(angle) ) ))
  endfunction

		/// @author Tamino Dauth
		/// @return Added special effect.
  function s__ACircle_addSpecialEffect takes integer this,string modelName,real angle,real distance returns effect
			return AddSpecialEffect(modelName , s__APoint_getPolarProjectionX(this,angle , distance) , s__APoint_getPolarProjectionY(this,angle , distance))
  endfunction

		/// @author Tamino Dauth
		/// @return Added spell effect.
  function s__ACircle_addSpellEffect takes integer this,string abilityString,effecttype effectType,real angle,real distance returns effect
			return AddSpellEffect(abilityString , effectType , s__APoint_getPolarProjectionX(this,angle , distance) , s__APoint_getPolarProjectionY(this,angle , distance))
  endfunction

		/// @author Tamino Dauth
		/// @return Added spell effect.
  function s__ACircle_addSpellEffectById takes integer this,integer abilityId,effecttype effectType,real angle,real distance returns effect
			return AddSpellEffectById(abilityId , effectType , s__APoint_getPolarProjectionX(this,angle , distance) , s__APoint_getPolarProjectionY(this,angle , distance))
  endfunction

		/// @author Tamino Dauth
		/// @return Created unit.
  function s__ACircle_createUnit takes integer this,player user,integer unitType,real angle,real distance,real face returns unit
			return CreateUnit(user , unitType , s__APoint_getPolarProjectionX(this,angle , distance) , s__APoint_getPolarProjectionY(this,angle , distance) , face)
  endfunction

		/// @author Tamino Dauth
		/// @return Created destructable.
  function s__ACircle_createDestructable takes integer this,integer destructableType,real angle,real distance,real face,real scale,integer variation returns destructable
			return CreateDestructable(destructableType , s__APoint_getPolarProjectionX(this,angle , distance) , s__APoint_getPolarProjectionY(this,angle , distance) , face , scale , variation)
  endfunction

		/// @author Tamino Dauth
		/// @return Created destructable.
  function s__ACircle_createDestructableZ takes integer this,integer destructableType,real angle,real distance,real z,real face,real scale,integer variation returns destructable
			return CreateDestructableZ(destructableType , s__APoint_getPolarProjectionX(this,angle , distance) , s__APoint_getPolarProjectionY(this,angle , distance) , z , face , scale , variation)
  endfunction

		/// @author Tamino Dauth
		/// @return Created item.
  function s__ACircle_createItem takes integer this,integer itemType,real angle,real distance returns item
			return CreateItem(itemType , s__APoint_getPolarProjectionX(this,angle , distance) , s__APoint_getPolarProjectionY(this,angle , distance))
  endfunction

		/// @author Tamino Dauth
		/// @return Created trackable.
  function s__ACircle_createTrackable takes integer this,string modelPath,real angle,real distance,real facing returns trackable
			return CreateTrackable(modelPath , s__APoint_getPolarProjectionX(this,angle , distance) , s__APoint_getPolarProjectionY(this,angle , distance) , facing)
  endfunction

  function s__ACircle_create takes real x,real y,real radius returns integer
   local integer this= s__ACircle__allocate(x , y)
			//dynamic members
			set s__ACircle_radius[this]=radius

			return this
  endfunction


//library AStructCoreMathsCircle ends
//library AStructCoreMathsVector:

		//dynamic members

		//dynamic members

  function s__AVector_setX takes integer this,real x returns nothing
			set s__AVector_x[this]=x
  endfunction

  function s__AVector_getX takes integer this returns real
			return s__AVector_x[this]
  endfunction

  function s__AVector_setY takes integer this,real y returns nothing
			set s__AVector_y[this]=y
  endfunction

  function s__AVector_getY takes integer this returns real
			return s__AVector_y[this]
  endfunction

  function s__AVector_setZ takes integer this,real z returns nothing
			set s__AVector_z[this]=z
  endfunction

  function s__AVector_getZ takes integer this returns real
			return s__AVector_z[this]
  endfunction
		
		//convenience methods
		
  function s__AVector_setWidget takes integer this,widget usedWidget returns nothing
			set s__AVector_x[this]=GetWidgetX(usedWidget)
			set s__AVector_y[this]=GetWidgetY(usedWidget)
			set s__AVector_z[this]=GetWidgetZ(usedWidget)
  endfunction
		
  function s__AVector_setUnit takes integer this,unit usedUnit returns nothing
			set s__AVector_x[this]=GetUnitX(usedUnit)
			set s__AVector_y[this]=GetUnitY(usedUnit)
			set s__AVector_z[this]=GetUnitZ(usedUnit)
  endfunction

		//methods

  function s__AVector_setLength takes integer this,real length returns nothing
			call sc__AVector_scale(this,( length / sc__AVector_getLength(this) ))
  endfunction

  function s__AVector_getLength takes integer this returns real
			return SquareRoot(( s__AVector_x[this] * s__AVector_x[this] ) + ( s__AVector_y[this] * s__AVector_y[this] ) + ( s__AVector_z[this] * s__AVector_z[this] ))
  endfunction

		/// Copys all data from vector @param vector.
  function s__AVector_copy takes integer this,integer vector returns nothing
			set s__AVector_x[this]=s__AVector_x[vector]
			set s__AVector_y[this]=s__AVector_y[vector]
			set s__AVector_z[this]=s__AVector_z[vector]
  endfunction

		/// Adds all data from vector @param vector.
		/// Das Ergebnis ist ein Vektor, der vom Punkt 0 zur Spitze vom Vektor "this" verläuft, wenn man diesen an die Spitze des Vektors "vector" legt.
  function s__AVector_add takes integer this,integer vector returns nothing
			set s__AVector_x[this]=s__AVector_x[this] + s__AVector_x[vector]
			set s__AVector_y[this]=s__AVector_y[this] + s__AVector_y[vector]
			set s__AVector_z[this]=s__AVector_z[this] + s__AVector_z[vector]
  endfunction


		/// Subtracts all data from vector @param vector.
		/// Das Ergebnis ist ein Vektor, der von der Spitze des Vektors "vector" zur Spitze des Vektors "this" verläuft.
		/// Achtung: Der Vektor verläuft immer vom 2. Wert zum 1. Wert der Subtraktion.
  function s__AVector_subtract takes integer this,integer vector returns nothing
			set s__AVector_x[this]=s__AVector_x[this] - s__AVector_x[vector]
			set s__AVector_y[this]=s__AVector_y[this] - s__AVector_y[vector]
			set s__AVector_z[this]=s__AVector_z[this] - s__AVector_z[vector]
  endfunction

		/// Multiplies each value from vector @param vector and returns the sum of all results.
		/// Ist das Ergebnis 0, so entsteht ein rechter Winkel, wenn man die beiden Vektoren mit ihren Spitzen aneinander legt.
  function s__AVector_multiply takes integer this,integer vector returns real
			return ( ( s__AVector_x[this] * s__AVector_x[vector] ) + ( s__AVector_y[this] * s__AVector_y[vector] ) + ( s__AVector_z[this] * s__AVector_z[vector] ) )
  endfunction

		/// Multiplies all values with the value of @param factor.
		/// Ist der Betrag des Wertes grer oder gleich 1 oder kleiner als 0, so verlängert sich der Vektor.
		/// Anderenfalls wird der Vektor kürzer.
  function s__AVector_scale takes integer this,real factor returns nothing
			set s__AVector_x[this]=s__AVector_x[this] * factor
			set s__AVector_y[this]=s__AVector_y[this] * factor
			set s__AVector_z[this]=s__AVector_z[this] * factor
  endfunction

		/// Adds scaled vector @param vector which is scaled by value @param factor.
		/// Note that vector @param vector won't be changed!
		/// @author peq
  function s__AVector_addScaled takes integer this,integer vector,real factor returns nothing
			set s__AVector_x[this]=s__AVector_x[this] + s__AVector_x[vector] * factor
			set s__AVector_y[this]=s__AVector_y[this] + s__AVector_y[vector] * factor
			set s__AVector_z[this]=s__AVector_z[this] + s__AVector_z[vector] * factor
  endfunction

		/// Projects vector @param vector.
		/// Passt die Richtung des Vektors "this" an die Richtung des Vektors "vector" an ohne dabei die Länge des Vektors "this" zu verändern. 
  function s__AVector_project takes integer this,integer vector returns nothing
   local real factor= s__AVector_getLength(this) / s__AVector_getLength(vector)
			set s__AVector_x[this]=s__AVector_x[vector] * factor
			set s__AVector_y[this]=s__AVector_y[vector] * factor
			set s__AVector_z[this]=s__AVector_z[vector] * factor
  endfunction

		/// Rotates a vector through @param angle.
		/// Only x and y will be changed. Rotation on z axis is not possible yet.		
  function s__AVector_rotate takes integer this,real angle returns nothing
   local real beta= ( Asin(s__AVector_y[this] / s__AVector_getLength(this)) - ( angle * bj_DEGTORAD ) )
			set s__AVector_x[this]=s__AVector_getLength(this) * Cos(beta)
			set s__AVector_y[this]=s__AVector_getLength(this) * Sin(beta)
  endfunction


		// Gets the normal vector of the terrain at given coordinates. @param sampleRadius defines
		// how far apart the reference points will be, if they are further apart, the result will
		// be an impression of smoother terrain; normaly the value should be between 0 and 128.
		/// @todo Not tested yet.
  function s__AVector_getTerrainNormal takes integer this,real x,real y,real sampleRadius returns nothing
   local real array z
   local integer vectorX= sc__AVector_create(0.0 , 0.0 , 0.0)
   local integer vectorY= sc__AVector_create(0.0 , 0.0 , 0.0)
			//Z
			set z[0]=GetTerrainZ(( x - sampleRadius ) , y)
			set z[1]=GetTerrainZ(( x + sampleRadius ) , y)
			set z[2]=GetTerrainZ(( y - sampleRadius ) , y)
			set z[3]=GetTerrainZ(( y + sampleRadius ) , y)
			//Vector X
			set s__AVector_x[vectorX]=( 2.0 * sampleRadius )
			//set VectorX.Y = 0.00
			set s__AVector_z[vectorX]=( z[1] - z[0] )
			//Vector Y
			//set VectorY.X = 0.00
			set s__AVector_y[vectorY]=( 2.0 * sampleRadius )
			set s__AVector_z[vectorY]=( z[3] - z[2] )
			//Add
			call s__AVector_add(vectorX,vectorY)
			//Copy
			call s__AVector_copy(this,vectorX)
			//Destroy
			call s__AVector_destroy(vectorX)
			call s__AVector_destroy(vectorY)
  endfunction

  function s__AVector_create takes real x,real y,real z returns integer
   local integer this= s__AVector__allocate()
			//dynamic members
			set s__AVector_x[this]=x
			set s__AVector_y[this]=y
			set s__AVector_z[this]=z

			return this
  endfunction

		/// Returns the product of the two vectors @param vector0 and @vector1 in a new vector instance.
  function s__AVector_product takes integer vector0,integer vector1 returns integer
   local integer result= s__AVector_create(0.0 , 0.0 , 0.0)
			call s__AVector_copy(result,vector0)
			call s__AVector_add(result,vector1)
			return result
  endfunction

		/// Returns the difference of the two vectors @param vector0 and @vector1 in a new vector instance.
  function s__AVector_difference takes integer vector0,integer vector1 returns integer
   local integer result= s__AVector_create(0.0 , 0.0 , 0.0)
			call s__AVector_copy(result,vector0)
			call s__AVector_subtract(result,vector1)
			return result
  endfunction

		/// Returns the multiplication of the two vectors @param vector0 and @vector1 in a new vector instance.
		/// @author Tamino Dauth
		/// @state untested
  function s__AVector_multiplication takes integer this,integer vector0,integer vector1 returns integer
   local integer result= s__AVector_create(0.0 , 0.0 , 0.0)
			call s__AVector_copy(result,vector0)
			call s__AVector_multiply(result,vector1)
			return result
  endfunction

		/// Returns the projection of the two vectors @param vector0 and @vector1 in a new vector instance.
		/// @author Tamino Dauth
		/// @state untested
  function s__AVector_projection takes integer this,integer vector0,integer vector1 returns integer
   local integer result= s__AVector_create(0.0 , 0.0 , 0.0)
			call s__AVector_copy(result,vector0)
			call s__AVector_project(result,vector1)
			return result
  endfunction


//library AStructCoreMathsVector ends
//library ACoreGeneral:

//library ACoreGeneral ends
//library ALibraryCoreMathsConversion:

	/// Converts an integer into any numeral system
	/// The A in I2A stands for alpha-numeric.
 function I2A takes integer value,string chars returns string
  local string alphanumeric= ""
  local integer index= 0
   if ( ( value >= 0 ) or ( value <= 0x7FFFFFFF ) ) then
			loop
				set index = ( ModuloInteger(value , StringLength(chars)) + 1 )
				set value = ( value / StringLength(chars) )
				set alphanumeric = ( SubStringBJ(chars , index , index) + alphanumeric )
				exitwhen ( value == 0 )
			endloop
   else
    call Print("Invalid integer.")
   endif
		return alphanumeric
	endfunction

	/// Converts a number from any numeral system into an integer.
	/// The A in A2I stands for alpha-numeric.
 function A2I takes string alphanumeric,string chars returns integer
  local integer value= 0
  local integer index= 1
		loop
			set value = value + ( ( FindString(chars , SubString(alphanumeric , ( StringLength(alphanumeric) - 1 ) , StringLength(alphanumeric))) ) * index )
			exitwhen ( StringLength(alphanumeric) == 1 )
			set alphanumeric = SubString(alphanumeric , 0 , ( StringLength(alphanumeric) - 1 ))
			set index = index * StringLength(chars)
		endloop
		return value
	endfunction


//textmacro instance: AMathsConversionMacro("Binary", "01")
		/// @state untested
  function I2Binary takes integer Integer returns string
			return I2A(Integer , "01")
		endfunction

		/// @state untested
  function Binary2I takes string Binary returns integer
			return A2I(Binary , "01")
		endfunction
//end of: AMathsConversionMacro("Binary", "01")
//textmacro instance: AMathsConversionMacro("Octal", "01234567")
		/// @state untested
  function I2Octal takes integer Integer returns string
			return I2A(Integer , "01234567")
		endfunction

		/// @state untested
  function Octal2I takes string Octal returns integer
			return A2I(Octal , "01234567")
		endfunction
//end of: AMathsConversionMacro("Octal", "01234567")
//textmacro instance: AMathsConversionMacro("Hexadecimal", "0123456789ABCDEF")
		/// @state untested
  function I2Hexadecimal takes integer Integer returns string
			return I2A(Integer , "0123456789ABCDEF")
		endfunction

		/// @state untested
  function Hexadecimal2I takes string Hexadecimal returns integer
			return A2I(Hexadecimal , "0123456789ABCDEF")
		endfunction
//end of: AMathsConversionMacro("Hexadecimal", "0123456789ABCDEF")


//library ALibraryCoreMathsConversion ends
//library ALibraryCoreStringConversion:

	/// Converts an ASCII char to an integer.
	/// ASCII is the American Keyboard Standard.
	/// Conversion of a char to ASCII works with the integer type: 'a' = 97.
	/// @author Peppar
	/// @source http://www.wc3jass.com/
	/// @todo Syntax error?!
 function AsciiToChar takes integer i returns string
		if ( i == 0 ) then
        		return null
		elseif ( ( i >= 8 ) and ( i <= 10 ) ) then
			return SubString("\b\t\n" , i - 8 , i - 7)
		elseif ( ( i >= 12 ) and ( i <= 13 ) ) then
			return SubString("\f\r" , i - 12 , i - 11)
		elseif ( ( i >= 32 ) and ( i <= 127 ) ) then
			//return SubString(" !\"#$%%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~", i - 32, i - 31) //syntax error?
		endif
		return ""
	endfunction

	/// Converts a specific number of seconds to a string with minutes.
	/// Example: 120 seconds - 02:00.
 function GetTimeString takes integer seconds returns string
  local integer i
  local integer endMinutes= 0
  local integer endSeconds= 0
  local string timeString
		if ( seconds >= 60 ) then
			set i = 1
			loop
				exitwhen ( seconds < ( i * 60 ) )
				set endMinutes = endMinutes + 1
				set i = i + 1
			endloop
		endif
		set endSeconds = seconds - endMinutes * 60
		if ( endMinutes >= 10 ) then
			set timeString = I2S(endMinutes)
		else
			set timeString = "0" + I2S(endMinutes)
		endif
		set timeString = timeString + ":"
		if ( endSeconds >= 10 ) then
			set timeString = timeString + I2S(endSeconds)
		else
			set timeString = timeString + "0" + I2S(endSeconds)
		endif
		return timeString
	endfunction

	/// Converts string @param colorString to a player color.
 function StringToPlayerColor takes string colorString returns playercolor
		if ( colorString == "ff0000" ) then
			return PLAYER_COLOR_RED
		elseif ( colorString == "0000ff" ) then
			return PLAYER_COLOR_BLUE
		elseif ( colorString == "" ) then //Fehlt noch
			return PLAYER_COLOR_CYAN
		elseif ( colorString == "800080" ) then
			return PLAYER_COLOR_PURPLE
		elseif ( colorString == "ffff00" ) then
			return PLAYER_COLOR_YELLOW
		elseif ( colorString == "ff8000" ) then
			return PLAYER_COLOR_ORANGE
		elseif ( colorString == "00ff00" ) then
			return PLAYER_COLOR_GREEN
		elseif ( colorString == "ff80C0" ) then
			return PLAYER_COLOR_PINK
		elseif ( colorString == "C0C0C0" ) then
			return PLAYER_COLOR_LIGHT_GRAY
		elseif ( colorString == "0080ff" ) then
			return PLAYER_COLOR_LIGHT_BLUE
		elseif ( colorString == "" ) then //Fehlt noch
			return PLAYER_COLOR_AQUA
		elseif ( colorString == "804000" ) then
			return PLAYER_COLOR_BROWN
		endif
		return null
	endfunction

	/// Converts player color @param playerColor to a string.
 function PlayerColorToString takes playercolor playerColor returns string
		if ( playerColor == PLAYER_COLOR_RED ) then
			return "ff0000"
		elseif ( playerColor == PLAYER_COLOR_BLUE ) then
			return "0000ff"
		elseif ( playerColor == PLAYER_COLOR_CYAN ) then /// @todo missing
		elseif ( playerColor == PLAYER_COLOR_PURPLE ) then
			return "800080"
		elseif ( playerColor == PLAYER_COLOR_YELLOW ) then
			return "ffff00"
		elseif ( playerColor == PLAYER_COLOR_ORANGE ) then
			return "ff8000"
		elseif ( playerColor == PLAYER_COLOR_GREEN ) then
			return "00ff00"
		elseif ( playerColor == PLAYER_COLOR_PINK ) then
			return "ff80c0"
		elseif ( playerColor == PLAYER_COLOR_LIGHT_GRAY ) then
			return "c0c0c0"
		elseif ( playerColor == PLAYER_COLOR_LIGHT_BLUE ) then
			return "0080ff"
		elseif ( playerColor == PLAYER_COLOR_AQUA ) then /// @todo missing
		elseif ( playerColor == PLAYER_COLOR_BROWN ) then
			return "804000"
		endif
		return "ffffff"
	endfunction

	/// I changed the function and called my own string functions.
	/// @author Peppar
	/// @source http://www.wc3jass.com/
 function HighlightShortcut takes string usedString,integer shortcut,string colour returns string
  local string result
  local string newShortcut= AsciiToChar(shortcut)
  local integer shortcutPosition= FindString(usedString , newShortcut)
		if ( shortcutPosition != - 1 ) then
			if ( colour == null ) then
				set colour = "ffffcc00"
			endif
			set result = InsertString(usedString , shortcutPosition + 1 , "|r")
			set result = InsertString(usedString , shortcutPosition , ( "|c" + colour ))
			return result
		endif
		return ""
	endfunction

	//DOES WORK YEAAHHHH, DO NOT CHANGE
	//Hinter jedem Argument muss ein Leerzeichen sein.
	//Auch hinter dem letzten.
	//Diese Funktion dient der Mehrsprachenfhigkeit, ist aber nicht ganz so umfangreich wie in C (printf).
	//Hier gibt es keine Elipse und keine Typenerkennung, dafr ist die Funktion relativ schnell.
	//call Format("Herzlich Willkommen lieber %. Es ist %:% Uhr", "Barade " + I2S(10) + " " + I2S(30) + " ")
	//call DisplayTimedTextToPlayer(GetTriggerPlayer(), 0.0, 0.0, 100.0, Format("Herzlich Willkommen lieber %. Es ist %:% Uhr", "Barade " + I2S(10) + " " + I2S(30) + " "))
	//function Format takes string usedString, string arguments returns string
		//local integer charPosition
		//local integer argumentEnd
		//local string argument
		//local string result = usedString
		//loop
			//set charPosition = FindString(result, "%")
			//exitwhen (charPosition == -1)
			//set argumentEnd = FindString(arguments, " ")
			//set argument = SubString(arguments, 0, argumentEnd)
			//set arguments = SubString(arguments, (argumentEnd + 1), StringLength(arguments)) //Der Parameter muss gekrzt werden.
			//set result = RemoveSubString(result, charPosition, 1)
			//set result = InsertString(result, charPosition, argument)
			//set usedString = SubString(usedString, charPosition + 1, StringLength(usedString)) //Der benutzte String muss gekrzt werden
		//endloop
		//return result
	//endfunction

	//This function uses a string from the wts string file of the map.
	//Use it if you want translate your map in a language and you need arguments.
	//function FormatLocalized takes string usedString, string arguments returns string
		//return GetLocalizedString(Format(usedString, arguments))
	//endfunction

	/// New argument function.
	/// Is much faster because you don't have to filter all the arguments and don't have to convert the types by yourself.
	/// Usage example: StringArg(StringArg(IntegerArg(Text("You're %i years old and you're called %s. Besides you're %s."), 0), "Peter"), "gay")

//textmacro instance: AStringArgumentMacro("integer", "Integer", "i", "I2S")
  function IntegerArg takes string usedString,integer value returns string
   local string result= usedString
   local integer charPosition= FindString(result , "%i")
			if ( charPosition != - 1 ) then
				set result = RemoveSubString(result , charPosition , 2)
				set result = InsertString(result , charPosition , I2S(value))
			endif
			return result
		endfunction
//end of: AStringArgumentMacro("integer", "Integer", "i", "I2S")
//textmacro instance: AStringArgumentMacro("real", "Real", "r", "R2S")
  function RealArg takes string usedString,real value returns string
   local string result= usedString
   local integer charPosition= FindString(result , "%r")
			if ( charPosition != - 1 ) then
				set result = RemoveSubString(result , charPosition , 2)
				set result = InsertString(result , charPosition , R2S(value))
			endif
			return result
		endfunction
//end of: AStringArgumentMacro("real", "Real", "r", "R2S")
//textmacro instance: AStringArgumentMacro("string", "String", "s", "")
  function StringArg takes string usedString,string value returns string
   local string result= usedString
   local integer charPosition= FindString(result , "%s")
			if ( charPosition != - 1 ) then
				set result = RemoveSubString(result , charPosition , 2)
				set result = InsertString(result , charPosition , ( value ))
			endif
			return result
		endfunction
//end of: AStringArgumentMacro("string", "String", "s", "")

	/// @author Extrarius
	/// @source http://www.wc3jass.com/
 function GetExternalString takes integer index returns string
		if ( index < 0 ) then
			return ""
		elseif ( index < 10 ) then
			return GetLocalizedString("TRIGSTR_00" + I2S(index))
		elseif ( index < 100 ) then
			return GetLocalizedString("TRIGSTR_0" + I2S(index))
		else
			return GetLocalizedString("TRIGSTR_" + I2S(index))
		endif
	endfunction

	/// Searches for the string in the map string file.
	/// It is also possible to search in the string files in the mpq directory "ui/FrameDef".
	/// There are some general string files.
	/// tr means translation.
	/// native GetLocalizedString takes string source returns string
 function tr takes string source returns string
		return GetLocalizedString(source)
	endfunction


	/// native GetLocalizedHotkey takes string source returns integer
 function hk takes string source returns integer
		return GetLocalizedHotkey(source)
	endfunction

	/// Not checked yet.
	/// @todo Bugged!
 function InsertLineBreaks takes string usedString,integer maxLineLength returns string
  local integer i
  local string result
		if ( StringLength(usedString) <= maxLineLength ) then
			return usedString
		endif
		set i = maxLineLength
		loop
			exitwhen ( i >= StringLength(usedString) )
				set result = result + SubString(usedString , i , maxLineLength) + "|n"
			set i = i + maxLineLength
		endloop
		
		set i = i - maxLineLength
		if ( i > StringLength(usedString) ) then
			set result = result + SubString(usedString , i , StringLength(usedString))
		endif
		
		return result
	endfunction


//library ALibraryCoreStringConversion ends
//library ALibraryCoreStringPool:


	/// Generates a random character from the character pool @param charPool.
	/// @param charPool Character pool which is used for generation of the random character.
	/// @param capitalisationChance The percental chance for returning a capitalised character.
	/// @return A random character from the character pool @param charPool.
 function GetRandomChar takes string charPool,real capitalisationChance returns string
  local integer randomInteger= GetRandomInt(1 , StringLength(charPool))
  local string result= SubString(charPool , ( randomInteger - 1 ) , randomInteger)
  local real chance
		if ( capitalisationChance > 0.0 ) then
			set chance = GetRandomReal(1.0 , 100.0)
			if ( chance <= capitalisationChance ) then
				return StringCase(result , true)
			endif
		endif
		return StringCase(result , false)
	endfunction
	
	/// Generates a random alphabetical character.
	/// @param capitalisationChance The percental chance for returning a capitalised character.
	/// @return A random alphabetical character.
 function GetRandomAlphabeticalChar takes real capitalisationChance returns string
		return GetRandomChar(ALibraryCoreStringPool___ALPHABETICAL_CHARS , capitalisationChance)
	endfunction
	
	/// Generates a random numeral character.
	/// @return A random numeral character.
 function GetRandomNumeralChar takes nothing returns string
		return I2S(GetRandomInt(0 , 9))
		//return GetRandomChar(NUMERAL_CHARS, 0.0) //Theoretisch auch durch I2S(GetRandomInt(0, 9)) lösbar. Brauche den StringPool aber vielleicht noch für IsStringNumeral
	endfunction
	
	/// Generates a random special character.
	/// @return A random special character.
 function GetRandomSpecialChar takes nothing returns string
		return GetRandomChar(ALibraryCoreStringPool___SPECIAL_CHARS , 0.0)
	endfunction
	
	/// Generates a random special character of the selected map or player language.
	/// @param capitalisationChance The percental chance for returning a capitalised character.
	/// @return A random special character of the selected map or player language.
 function GetRandomLanguageSpecialChar takes real capitalisationChance returns string
		return GetRandomChar(ALibraryCoreStringPool___LANGUAGE_SPECIAL_CHARS , capitalisationChance)
	endfunction

	/// Generats a random string with the length @param length.
	/// Is able to include various other characters.
	/// @param length The length of the returned value.
	/// @param capitalisationChance The percental chance for returnsing a capitalised character.
	/// @param includeNumbers If this value is true number charactes will be added into the string pool.
	/// @param includeSpecialChars If this value is true special characters will be added into the string pool.
	/// @param includeLanguageSpecialChars If this value is true special characts of the selected map or player language will be added into the string pool.
	/// @return A random string generated from the selected string pool.
 function GetRandomString takes integer length,real capitalisationChance,boolean includeNumbers,boolean includeSpecialChars,boolean includeLanguageSpecialChars returns string
  local integer i
  local string chars= ALibraryCoreStringPool___ALPHABETICAL_CHARS
  local string result= ""
		//case sensitivity shouldn't do anything here
		if ( includeNumbers ) then
			set chars = chars + ALibraryCoreStringPool___NUMERAL_CHARS
		endif
		//case sensitivity shouldn't do anything here
		if ( includeSpecialChars ) then
			set chars = chars + ALibraryCoreStringPool___SPECIAL_CHARS
		endif
		if ( includeLanguageSpecialChars ) then
			set chars = chars + ALibraryCoreStringPool___LANGUAGE_SPECIAL_CHARS
		endif
		set i = 0
		loop
			exitwhen ( i == length )
			set result = result + GetRandomChar(chars , capitalisationChance)
			set i = i + 1
		endloop
		return result
	endfunction

	/// Checks if string @param usedString contains only characters from string pool @param stringPool.
	/// Checks each single character.
	/// @param usedString String which should be checked.
	/// @param stringPool String pool which will be used for comparing all characters.
	/// @return Returns if all characters from string @param usedString are contained by string pool @param stringPool.
 function IsStringFromStringPool takes string usedString,string stringPool returns boolean
  local integer i
		set i = 1
		loop
			exitwhen ( i > StringLength(usedString) )
			if ( FindString(stringPool , StringCase(usedString , false)) == - 1 ) then //ALibraryStringMisc
				return false
			endif
			set i = ( i + 1 )
		endloop
		return true
	endfunction

	/// Checks if string @param usedString is alphabetical.
	/// @param usedString Checked string.
	/// @return Returns true if string @param usedString contains only alphabetical characters.
 function IsStringAlphabetical takes string usedString returns boolean
		return IsStringFromStringPool(usedString , ALibraryCoreStringPool___ALPHABETICAL_CHARS)
	endfunction

	/// Checks if string @param usedString is numeral.
	/// @param usedString Checked string.
	/// @return Returns true if string @param usedString contains only numeral characters.
 function IsStringNumeral takes string usedString returns boolean
		return IsStringFromStringPool(usedString , ALibraryCoreStringPool___NUMERAL_CHARS)
	endfunction

	/// Checks if string @param usedString contains only special characters.
	/// @param usedString Checked string.
	/// @return Returns true if string @param usedString contains only special characters.
 function IsStringSpecialChar takes string usedString returns boolean
		return IsStringFromStringPool(usedString , ALibraryCoreStringPool___SPECIAL_CHARS)
	endfunction
	
	/// Checks if string @param usedString contains only special characters from the selected map or player language.
	/// @param usedString Checked string.
	/// @return Returns true if string @param usedString contains only special characters from the selected map or player language.
 function IsStringLanguageSpecialChar takes string usedString returns boolean
		return IsStringFromStringPool(usedString , ALibraryCoreStringPool___LANGUAGE_SPECIAL_CHARS)
	endfunction

	/// Checks if string @param usedString is a signature.
	/// @param usedString Checked string.
	/// @return Returns true if string @param usedString is a signature.
 function IsStringSignature takes string usedString returns boolean
		return IsStringFromStringPool(usedString , ALibraryCoreStringPool___SIGNATURE_CHARS)
	endfunction

	/// Checks if string @param usedString is an integer.
	/// @param usedString Checked string.
	/// @return Returns true if string @param usedString is an integer.
 function IsStringInteger takes string usedString returns boolean
		if ( IsStringSignature(SubString(usedString , 0 , 1)) ) then
			return IsStringNumeral(SubString(usedString , 1 , StringLength(usedString)))
		endif
		return IsStringNumeral(SubString(usedString , 0 , StringLength(usedString)))
	endfunction

	/// Bei den folgenden Zahlentypen muss die Zahl immer mit einer bestimmten Ziffernfolge beginnen.
	/// Ansonsten wird sie NICHT als eine solche Zahl erkannt.
	/// Dies ist eine Anlehnung an C++ und wahrscheinlich auch an vielen andere Sprachen:
	/// - 0% binär
	/// - 0 oktal
	/// - 0x hexadezimal
	/// Checks if string @param usedString is binary.
	/// @param usedString Checked string.
	/// @return Returns true if string @param usedString is binary.
 function IsStringBinary takes string usedString returns boolean
		if ( SubString(usedString , 0 , 2) == "0%" ) then
			return IsStringFromStringPool(SubString(usedString , 2 , StringLength(usedString)) , ALibraryCoreStringPool___BINARY_CHARS)
		endif
		return false
	endfunction

	/// Bei den folgenden Zahlentypen muss die Zahl immer mit einer bestimmten Ziffernfolge beginnen.
	/// Ansonsten wird sie NICHT als eine solche Zahl erkannt.
	/// Dies ist eine Anlehnung an C++ und wahrscheinlich auch an vielen andere Sprachen:
	/// - 0% binär
	/// - 0 oktal
	/// - 0x hexadezimal
	/// Checks if string @param usedString is octal.
	/// @param usedString Checked string.
	/// @return Returns true if string @param usedString is octal.
 function IsStringOctal takes string usedString returns boolean
		if ( SubString(usedString , 0 , 1) == "0" ) then
			return IsStringFromStringPool(SubString(usedString , 1 , StringLength(usedString)) , ALibraryCoreStringPool___OCTAL_CHARS)
		endif
		return false
	endfunction

	/// Bei den folgenden Zahlentypen muss die Zahl immer mit einer bestimmten Ziffernfolge beginnen.
	/// Ansonsten wird sie NICHT als eine solche Zahl erkannt.
	/// Dies ist eine Anlehnung an C++ und wahrscheinlich auch an vielen andere Sprachen:
	/// - 0% binär
	/// - 0 oktal
	/// - 0x hexadezimal
	/// Checks if string @param usedString is hexadecimal.
	/// @param usedString Checked string.
	/// @return Returns true if string @param usedString is hexadecimal.
 function IsStringHexadecimal takes string usedString returns boolean
		if ( SubString(usedString , 0 , 2) == "0x" ) then
			return IsStringFromStringPool(SubString(usedString , 2 , StringLength(usedString)) , ALibraryCoreStringPool___HEXADECIMAL_CHARS)
		endif
		return false
	endfunction


//library ALibraryCoreStringPool ends
//library AStructCoreDebugDebugHashTable:

	//Just one instance
	//Does not extend AHashTable!

  function s__AStructCoreDebugDebugHashTable__ADebugHashTable_create takes nothing returns integer
			return 0
  endfunction

  function s__AStructCoreDebugDebugHashTable__ADebugHashTable_onDestroy takes integer this returns nothing
  endfunction

//Generated destructor of AStructCoreDebugDebugHashTable__ADebugHashTable
function s__AStructCoreDebugDebugHashTable__ADebugHashTable_destroy takes integer this returns nothing
    if this==null then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: AStructCoreDebugDebugHashTable__ADebugHashTable")
        return
    elseif (si__AStructCoreDebugDebugHashTable__ADebugHashTable_V[this]!=-1) then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: AStructCoreDebugDebugHashTable__ADebugHashTable")
        return
    endif
    call s__AStructCoreDebugDebugHashTable__ADebugHashTable_onDestroy(this)
    set si__AStructCoreDebugDebugHashTable__ADebugHashTable_V[this]=si__AStructCoreDebugDebugHashTable__ADebugHashTable_F
    set si__AStructCoreDebugDebugHashTable__ADebugHashTable_F=this
endfunction

  function s__AStructCoreDebugDebugHashTable__ADebugHashTable_onInit takes nothing returns nothing
			set s__AStructCoreDebugDebugHashTable__ADebugHashTable_instance=s__AHashTable_create("ADebugHashTable")
  endfunction

  function s__AStructCoreDebugDebugHashTable__ADebugHashTable_getInstance takes nothing returns integer
			return s__AStructCoreDebugDebugHashTable__ADebugHashTable_instance
  endfunction

 function AGetDebugHashTable takes nothing returns integer
		return s__AStructCoreDebugDebugHashTable__ADebugHashTable_getInstance()
	endfunction


//library AStructCoreDebugDebugHashTable ends
//library AStructCoreEnvironmentMissile:

	/// Required by static convenience methods.
//textmacro instance: A_CONTAINER("AMissile", "Missile", "100") /// @todo FIXME - size

		/// @state untested
		/// An operation function interface with two elements.
		/// The return value is the result of the operation.
		/// Examples are addition and subtraction etc.
//processed: 		function interface AMissileContainerOperation takes AMissile element0, AMissile element1 returns AMissile

		/// @state untested
		/// Unary predicate.
		/// A comparision function interface for one element.
//processed: 		function interface AMissileContainerUnaryPredicate takes AMissile element returns boolean

		/// @state untested
		/// Binary predicate.
		/// A comparisan function interface for two elements.
//processed: 		function interface AMissileContainerBinaryPredicate takes AMissile element0, AMissile element1 returns boolean

		/// @state works
		/// Unary function.
		/// Allows the call of an user-definied function for each element.
//processed: 		function interface AMissileContainerUnaryFunction takes AMissile element returns nothing //Rückgabewert wurde vorerst rausgenommen, bis ich weiß, was er bringt

		/// Generator.
		/// Allows filling some elements with the return value.
//processed: 		function interface AMissileContainerGenerator takes nothing returns AMissile

			//dynamic members
			//Quicksort statics

			//dynamic members

   function s__AMissileContainer_setElement takes integer this,integer index,integer element returns nothing
     call sc__AMissileContainer_debugCheckIndex(this,index)
				set s___AMissileContainer_element[s__AMissileContainer_element[this]+index]=element
   endfunction

   function s__AMissileContainer_getElement takes integer this,integer index returns integer
     call sc__AMissileContainer_debugCheckIndex(this,index)
				return s___AMissileContainer_element[s__AMissileContainer_element[this]+index]
   endfunction

			//start members

   function s__AMissileContainer_getSize takes integer this returns integer
				return s___AMissileContainer_element_size
   endfunction

			//methods

			/// Checks the start position.
    function s__AMissileContainer_debugCheckStart takes integer this,integer start returns nothing
     if ( ( start < 0 ) or ( start >= 100 ) ) then
      call Print("Wrong start value of container " + I2S(this) + ": start " + I2S(start) + ".")
     endif
    endfunction

			/// Checks the number.
    function s__AMissileContainer_debugCheckNumber takes integer this,integer number returns nothing
     if ( ( number > 100 ) or ( number <= 0 ) ) then
      call Print("Wrong number value of container " + I2S(this) + ": number " + I2S(number) + ".")
     endif
    endfunction

			/// Checks both values.
    function s__AMissileContainer_debugCheckStartAndNumber takes integer this,integer start,integer number returns nothing
     call s__AMissileContainer_debugCheckStart(this,start)
     call s__AMissileContainer_debugCheckNumber(this,number)
     if ( start + number > 100 ) then
      call Print("Wrong start or number value of container " + I2S(this) + ": start " + I2S(start) + " number " + I2S(number) + ".")
     endif
    endfunction

			/// Checks over- and underflow of the size.
    function s__AMissileContainer_debugCheckSize takes integer this,integer size returns nothing
     if ( size > 100 ) then
      call Print("Wrong size of container " + I2S(this) + ": " + I2S(size) + ".")
     endif
    endfunction
	
			/// Checks over- and underflow of the index.
    function s__AMissileContainer_debugCheckIndex takes integer this,integer index returns nothing
     if ( ( index < 0 ) or ( index >= 100 ) ) then
      call Print("Wrong index of container " + I2S(this) + ": " + I2S(index) + ".")
     endif
    endfunction

			/// Common quick sort algorithm.
   function s__AMissileContainer_quickSort takes integer this,integer left,integer right,integer binaryPredicate returns nothing
    local integer i
    local integer temp
				if ( right > left ) then
					set s__AMissileContainer_m[this]=s___AMissileContainer_element[s__AMissileContainer_element[this]+right]
					set i = left - 1
					set s__AMissileContainer_j[this]=right
					loop
						loop
							set i = i + 1
							exitwhen ( not sc___prototype821_evaluate(binaryPredicate,s___AMissileContainer_element[s__AMissileContainer_element[this]+i] , s__AMissileContainer_m[this]) )
						endloop
						
						loop
							set s__AMissileContainer_j[this]=s__AMissileContainer_j[this] - 1
							exitwhen ( sc___prototype821_evaluate(binaryPredicate,s___AMissileContainer_element[s__AMissileContainer_element[this]+s__AMissileContainer_j[this]] , s__AMissileContainer_m[this]) )
						endloop
		
						exitwhen ( i >= s__AMissileContainer_j[this] )
						set temp = s___AMissileContainer_element[s__AMissileContainer_element[this]+i]
						set s___AMissileContainer_element[s__AMissileContainer_element[this]+i]=s___AMissileContainer_element[s__AMissileContainer_element[this]+s__AMissileContainer_j[this]]
						set s___AMissileContainer_element[s__AMissileContainer_element[this]+s__AMissileContainer_j[this]]=temp
					endloop
					
					set temp = s___AMissileContainer_element[s__AMissileContainer_element[this]+i]
					set s___AMissileContainer_element[s__AMissileContainer_element[this]+i]=s___AMissileContainer_element[s__AMissileContainer_element[this]+right]
					set s___AMissileContainer_element[s__AMissileContainer_element[this]+right]=temp
					
					call s__AMissileContainer_quickSort(this,left , i - 1 , binaryPredicate)
					call s__AMissileContainer_quickSort(this,i + 1 , right , binaryPredicate)
				endif
   endfunction

			/// Sorts elements by using the quick sort algorithm in ascending order.
			/// @param start Index of first element.
			/// @param number Number of elements.
			/// @param binaryPredicate Binary comparison function.
   function s__AMissileContainer_sort takes integer this,integer start,integer number,integer binaryPredicate returns nothing
     call s__AMissileContainer_debugCheckStartAndNumber(this,start , number)
				call s__AMissileContainer_quickSort(this,start , start + number - 1 , binaryPredicate)
   endfunction

			/// Reverses elements.
			/// @param start Index of first element.
			/// @param number Number of elements.
			/// @todo I'm not sure if this is best solution.
   function s__AMissileContainer_reverse takes integer this,integer start,integer number returns nothing
    local integer i= start
    local integer exitValue= start + ( number / 2 )
    local integer temp
    local integer swapindex
     call s__AMissileContainer_debugCheckStartAndNumber(this,start , number)
				loop
					exitwhen ( i == exitValue )
					set swapindex = ( ( 2 * start ) + number - i - 1 )
					set temp = s___AMissileContainer_element[s__AMissileContainer_element[this]+i]
					set s___AMissileContainer_element[s__AMissileContainer_element[this]+i]=s___AMissileContainer_element[s__AMissileContainer_element[this]+swapindex]
					set s___AMissileContainer_element[s__AMissileContainer_element[this]+swapindex]=temp
					set i = i + 1
				endloop
   endfunction

			//C++ algorithm

			/// @state untested
			/// Orientiert sich an accumulate und adjacent_difference.
			/// Man kann allerdings nicht jeden Datentyp addieren oder subtrahieren.
			/// Führt eine Operation mit allen Elementen in einem Bereich durch.
			/// @param start Startposition
			/// @param number Anzahl der Elemente
			/// @param value Der Startwert des Ergebnis
			/// @param operation Operationsfunktion
			/// @return Ergebnis aller Operationen
   function s__AMissileContainer_operation takes integer this,integer start,integer number,integer value,integer operation returns integer
    local integer i= start
    local integer exitValue= start + number
    local integer result= value
     call s__AMissileContainer_debugCheckStartAndNumber(this,start , number)
				loop
					exitwhen ( i == exitValue )
					set result = sc___prototype819_evaluate(operation,result , s___AMissileContainer_element[s__AMissileContainer_element[this]+i]) //Returns something
					set i = i + 1
				endloop
				return result
   endfunction

			/// @state untested
			/// Sucht nach zwei aneinander liegenden gleichen Elementen.
			/// @param start Startposition
			/// @param number Anzahl der Elemente
			/// @return Index des ersten Treffers oder -1
   function s__AMissileContainer_adjacentFind takes integer this,integer start,integer number returns integer
    local integer i= start
    local integer exitValue= start + number - 1 //-1 da beim Vergleich + 1 angewendet wird
     call s__AMissileContainer_debugCheckStartAndNumber(this,start , number)
				loop
					exitwhen ( i == exitValue )
					if ( s___AMissileContainer_element[s__AMissileContainer_element[this]+i] == s___AMissileContainer_element[s__AMissileContainer_element[this]+i + 1] ) then
						return i
					endif
					set i = i + 1
				endloop
				return - 1
   endfunction

			/// @state untested
			/// Sucht mit Hilfe einer benutzerdefinierten Vergleichsfunktion nach zwei aneinander liegenden gleichen Elementen.
			/// @param start Startposition
			/// @param number Anzahl der Elemente
			/// @param binaryPredicate Vergleichsfunktion
			/// @return Index des ersten Treffers oder -1
   function s__AMissileContainer_adjacentFindIf takes integer this,integer start,integer number,integer binaryPredicate returns integer
    local integer i= start
    local integer exitValue= start + number - 1 //-1 da beim Vergleich + 1 angewendet wird
     call s__AMissileContainer_debugCheckStartAndNumber(this,start , number)
				loop
					exitwhen ( i == exitValue )
					if ( sc___prototype821_evaluate(binaryPredicate,s___AMissileContainer_element[s__AMissileContainer_element[this]+i] , s___AMissileContainer_element[s__AMissileContainer_element[this]+i + 1]) ) then
						return i
					endif
					set i = i + 1
				endloop
				return - 1
   endfunction

			/// @state untested
			/// Die binäre Suche funktioniert nur wenn die Elemente in Reihenfolge sortiert sind.
			/// @todo Noch implementieren.
			/// @todo bool binary_search( iterator start, iterator end, const TYPE& val );
			/// @todo bool binary_search( iterator start, iterator end, const TYPE& val, Comp f );
   function s__AMissileContainer_binarySearch takes integer this returns nothing
   endfunction

			/// @state untested
			/// Kopiert einen Elementebereich des Containers in einen Ziel-Container.
			/// @param start0 Index of first element.
			/// @param number0 Number of elements.
			/// @param start1 Index of first element in container @param desitination.
			/// @param destination Container where elements are copied to.
   function s__AMissileContainer_copy takes integer this,integer start0,integer number0,integer start1,integer destination returns nothing
    local integer i= start0
    local integer j= start1
    local integer exitValue= start0 + number0
     call s__AMissileContainer_debugCheckStartAndNumber(this,start0 , number0)
     call s__AMissileContainer_debugCheckStart(destination,start1)
				loop
					exitwhen ( i == exitValue )
					set s___AMissileContainer_element[s__AMissileContainer_element[destination]+j]=s___AMissileContainer_element[s__AMissileContainer_element[this]+i]
					set i = i + 1
					set j = j + 1
				endloop
   endfunction

			/// @state untested
			/// Kopiert einen Elementebereich des Containers in einen Ziel-Container.
			/// Im Gegensatz zur copy-Methode fängt diese Methode beim letzten zu kopierenden Wert an.
			/// @param start0 Startposition
			/// @param number0 Anzahl der Elemente
			/// @param start1 Startposition im Ziel-Container
			/// @param destination Ziel-Container
   function s__AMissileContainer_copyBackward takes integer this,integer start0,integer number0,integer start1,integer destination returns nothing
    local integer i= start0 + number0 - 1
    local integer j= start1 + number0 - 1
    local integer exitValue= start0 - 1
     call s__AMissileContainer_debugCheckStartAndNumber(this,start0 , number0)
     call s__AMissileContainer_debugCheckStart(destination,start1)
				loop
					exitwhen ( i == exitValue )
					set s___AMissileContainer_element[s__AMissileContainer_element[destination]+j]=s___AMissileContainer_element[s__AMissileContainer_element[this]+i]
					set i = i - 1
					set j = j - 1
				endloop
   endfunction

			/// Diese Methode tut das, was die Methoden dieses Containers von C++-Containern unterscheidet.
			/// Sie verwendet als zweiten Parameter die Anzahl der Elemente und keinen Ziel-Iterator.
			/// Sie ist daher überflüssig.
			/// iterator copy_n( iterator from, size_t num, iterator to );
   function s__AMissileContainer_copyN takes integer this returns nothing
   endfunction

			/// @state untested
			/// Vergleicht einen Elementebereich mit einem Wert.
			/// @param start Startposition
			/// @param number Anzahl der Elemente
			/// @param value Vergleichswert
			/// @return Anzahl der Treffer
   function s__AMissileContainer_count takes integer this,integer start,integer number,integer value returns integer
    local integer i= start
    local integer exitValue= start + number
    local integer result= 0
     call s__AMissileContainer_debugCheckStartAndNumber(this,start , number)
				loop
					exitwhen ( i == exitValue )
					if ( s___AMissileContainer_element[s__AMissileContainer_element[this]+i] == value ) then
						set result = result + 1
					endif
					set i = i + 1
				endloop
				return result
   endfunction

			/// @state untested
			/// Vergleicht einen Elementebereich mit Hilfe einer benutzerdefinierten Funktion.
			/// @param start Startposition
			/// @param number Anzahl der Elemente
			/// @param unaryPredicate Vergleichsfunktion
			/// @return Anzahl der Treffer
   function s__AMissileContainer_countIf takes integer this,integer start,integer number,integer unaryPredicate returns integer
    local integer i= start
    local integer exitValue= start + number
    local integer result= 0
     call s__AMissileContainer_debugCheckStartAndNumber(this,start , number)
				loop
					exitwhen ( i == exitValue )
					if ( sc___prototype820_evaluate(unaryPredicate,s___AMissileContainer_element[s__AMissileContainer_element[this]+i]) ) then
						set result = result + 1
					endif
					set i = i + 1
				endloop
				return result
   endfunction

			/// @state untested
			/// Prüft ob ein Elementebereich einem anderen entspricht.
			/// Verwendet dabei den Standard ==-Operator, der normalerweise bei allen Datentypen anwendbar ist.
			/// @param start1 Startposition
			/// @param number1 Anzahl der Elemente
			/// @param start2 Startposition im Vergleichs-Container
			/// @param destination Vergleichs-Container
			/// @return Übereinstimmung aller Elemente
   function s__AMissileContainer_equal takes integer this,integer start1,integer number1,integer start2,integer destination returns boolean
    local integer i= start1
    local integer j= start2
    local integer exitValue= start1 + number1
     call s__AMissileContainer_debugCheckStartAndNumber(this,start1 , number1)
     call s__AMissileContainer_debugCheckStart(destination,start2)
				loop
					exitwhen ( i == exitValue )
						if ( not ( s___AMissileContainer_element[s__AMissileContainer_element[this]+i] == s___AMissileContainer_element[s__AMissileContainer_element[destination]+j] ) ) then
							return false
						endif
					set i = i + 1
					set j = j + 1
				endloop
				return true
   endfunction

			/// @state untested
			/// Prüft mit Hilfe einer benutzerdefinierten Vergleichsfunktion ob ein Elementebereich einem anderen entspricht.
			/// @param start0 Startposition
			/// @param number0 Anzahl der Elemente
			/// @param start1 Startposition im Vergleichs-Container
			/// @param destination Vergleichs-Container
			/// @param binaryPredicate Vergleichsfunktion
			/// @return Übereinstimmung aller Elemente
   function s__AMissileContainer_equalIf takes integer this,integer start0,integer number0,integer start1,integer destination,integer binaryPredicate returns boolean
    local integer i= start0
    local integer j= start1
    local integer exitValue= start0 + number0
     call s__AMissileContainer_debugCheckStartAndNumber(this,start0 , number0)
     call s__AMissileContainer_debugCheckStart(destination,start1)
				loop
					exitwhen ( i == exitValue )
						if ( not sc___prototype821_evaluate(binaryPredicate,s___AMissileContainer_element[s__AMissileContainer_element[this]+i] , s___AMissileContainer_element[s__AMissileContainer_element[destination]+j]) ) then
							return false
						endif
					set i = i + 1
					set j = j + 1
				endloop
				return true
   endfunction

			/// @state untested
			/// Füllt einen Elementebereich mit einem Wert.
			/// @param start Startposition
			/// @param number Anzahl der Elemente
			/// @param value Zu füllender Wert
   function s__AMissileContainer_fill takes integer this,integer start,integer number,integer value returns nothing
    local integer i= start
    local integer exitValue= start + number
     call s__AMissileContainer_debugCheckStartAndNumber(this,start , number)
				loop
					exitwhen ( i == exitValue )
						set s___AMissileContainer_element[s__AMissileContainer_element[this]+i]=value
					set i = i + 1
				endloop
   endfunction

			/// Diese Methode tut das, was die Methoden dieses Containers von C++-Containern unterscheidet.
			/// Sie verwendet als zweiten Parameter die Anzahl der Elemente und keinen Ziel-Iterator.
			/// Sie ist daher überflüssig.
			/// iterator fill_n( iterator start, size_t n, const TYPE& val );
   function s__AMissileContainer_fillN takes integer this returns nothing
   endfunction

			/// @state untested
			/// Sucht im Container nach einem Element mit einem bestimmten Wert.
			/// @param start Index of first element which is checked for the searched value.
			/// @param number Number of elements which are checked for the searched value.
			/// @param value Searched value.
			/// @return Returns the index of the first hit. If there was no hit it returns -1.
   function s__AMissileContainer_find takes integer this,integer start,integer number,integer value returns integer
    local integer i= start
    local integer exitValue= start + number
     call s__AMissileContainer_debugCheckStartAndNumber(this,start , number)
				loop
					exitwhen ( i == exitValue )
					if ( s___AMissileContainer_element[s__AMissileContainer_element[this]+i] == value ) then
						return i
					endif
					set i = i + 1
				endloop
				return - 1
   endfunction

			/// @todo iterator find_end( iterator start, iterator end, iterator seq_start, iterator seq_end );
			/// @todo iterator find_end( iterator start, iterator end, iterator seq_start, iterator seq_end, BinPred bp );
   function s__AMissileContainer_findEnd takes integer this returns nothing
   endfunction

			/// @todo iterator find_first_of( iterator start, iterator end, iterator find_start, iterator find_end );
			/// @todo iterator find_first_of( iterator start, iterator end, iterator find_start, iterator find_end, BinPred bp );
   function s__AMissileContainer_findFirstOf takes integer this returns nothing
   endfunction

			/// @state untested
			/// Sucht mit Hilfe einer benutzerdefinierten Funktion ein Element im Container.
			/// @param start Startposition
			/// @param number Anzahl der Elemente
			/// @param unaryPredicate Vergleichsfunktion
			/// @return Index des ersten Treffers oder -1
   function s__AMissileContainer_findIf takes integer this,integer start,integer number,integer unaryPredicate returns integer
    local integer i= start
    local integer exitValue= start + number
     call s__AMissileContainer_debugCheckStartAndNumber(this,start , number)
				loop
					exitwhen ( i == exitValue )
						if ( sc___prototype820_evaluate(unaryPredicate,s___AMissileContainer_element[s__AMissileContainer_element[this]+i]) ) then
							return i
						endif
					set i = i + 1
				endloop
				return - 1
   endfunction

			/// @state untested
			/// Führt eine benutzerdefinierte Funktion für einen Elementebereich aus.
			/// @param start Startposition
			/// @param number Anzahl der Elemente
			/// @param unaryFunction Benutzerdefinierte Funktion
   function s__AMissileContainer_forEach takes integer this,integer start,integer number,integer unaryFunction returns nothing
    local integer i= start
    local integer exitValue= start + number
     call s__AMissileContainer_debugCheckStartAndNumber(this,start , number)
				loop
					exitwhen ( i == exitValue )
						call sc___prototype822_execute(unaryFunction,s___AMissileContainer_element[s__AMissileContainer_element[this]+i])
					set i = i + 1
				endloop
   endfunction

			/// void generate( iterator start, iterator end, Generator g );
			/// @state untested
			/// Füllt einen Elementebereich mit dem Rückgabewert einer benutzerdefinierten Funktion.
			/// Funktion wurde so in Quell-Code des GCCs nachgeschlagen.
			/// @param start Startposition
			/// @param number Anzahl der Elemente
			/// @param generator Benutzerdefinierte Funktion
   function s__AMissileContainer_generate takes integer this,integer start,integer number,integer generator returns nothing
    local integer i= start
    local integer exitValue= start + number
     call s__AMissileContainer_debugCheckStartAndNumber(this,start , number)
				loop
					exitwhen ( i == exitValue )
						set s___AMissileContainer_element[s__AMissileContainer_element[this]+i]=sc___prototype823_evaluate(generator)
					set i = i + 1
				endloop
   endfunction

			/// Diese Methode tut das, was die Methoden dieses Containers von C++-Containern unterscheidet.
			/// Sie verwendet als zweiten Parameter die Anzahl der Elemente und keinen Ziel-Iterator.
			/// Sie ist daher überflüssig.
			/// iterator generate_n( iterator result, size_t num, Generator g );
   function s__AMissileContainer_generate_n takes integer this returns nothing
   endfunction

			/// @todo bool includes( iterator start1, iterator end1, iterator start2, iterator end2 );
			/// @todo bool includes( iterator start1, iterator end1, iterator start2, iterator end2, StrictWeakOrdering cmp );
			/// @todo The includes() algorithm returns true if every element in [start2,end2) is also in [start1,end1). Both of the given ranges must be sorted in ascending order.
			/// @todo By default, the < operator is used to compare elements. If the strict weak ordering function object cmp is given, then it is used instead.
   function s__AMissileContainer_includes takes integer this returns nothing
   endfunction

			/// @todo TYPE inner_product( iterator start1, iterator end1, iterator start2, TYPE val );
			/// @todo TYPE inner_product( iterator start1, iterator end1, iterator start2, TYPE val, BinaryFunction f1, BinaryFunction f2 );
			/// @todo The inner_product() function computes the inner product of [start1,end1) and a range of the same size starting at start2.
   function s__AMissileContainer_inner_product takes integer this returns nothing
   endfunction

			/// @todo inline void inplace_merge( iterator start, iterator middle, iterator end );
			/// @todo inline void inplace_merge( iterator start, iterator middle, iterator end, StrictWeakOrdering cmp );
			/// @todo The inplace_merge() function is similar to the merge() function, but instead of creating a new sorted range of elements, inplace_merge() alters the existing ranges to perform the merge in-place.
   function s__AMissileContainer_inplace_merge takes integer this returns nothing
   endfunction

			/// @state untested
			/// iterator max_element( iterator start, iterator end );
			/// iterator max_element( iterator start, iterator end, BinPred p );
			/// Sucht mit Hilfe einer benutzerdefinierten Vergleichsfunktion nach dem größten Element in einem Elementebereich.
			/// Das Prädikat stellt in diesem Fall den <-Operator dar.
			/// @param start Startposition
			/// @param number Anzahl der Elemente
			/// @param binaryPredicate Benutzerdefinierte Vergleichsfunktion
			/// @return Index des größten Elements
   function s__AMissileContainer_max_element takes integer this,integer start,integer number,integer binaryPredicate returns integer
    local integer i= start + 1
    local integer exitValue= start + number
    local integer result= start
     call s__AMissileContainer_debugCheckStartAndNumber(this,start , number)
				loop
					exitwhen ( i == exitValue )
						//x < y
						if ( sc___prototype821_evaluate(binaryPredicate,s___AMissileContainer_element[s__AMissileContainer_element[this]+result] , s___AMissileContainer_element[s__AMissileContainer_element[this]+i]) ) then
							set result = i
						endif
					set i = i + 1
				endloop
				return result
   endfunction

			//iterator min_element( iterator start, iterator end );
			//iterator min_element( iterator start, iterator end, BinPred p );
			/// Sucht mit Hilfe einer benutzerdefinierten Vergleichsfunktion nach dem kleinsten Element in einem Elementebereich.
			/// Das Prädikat stellt in diesem Fall den <-Operator dar.
			/// @param start Startposition
			/// @param number Anzahl der Elemente
			/// @param binaryPredicate Benutzerdefinierte Vergleichsfunktion
			/// @return Index des kleinsten Elements
   function s__AMissileContainer_min_element takes integer this,integer start,integer number,integer binaryPredicate returns integer
    local integer i= start + 1
    local integer exitValue= start + number
    local integer result= start
     call s__AMissileContainer_debugCheckStartAndNumber(this,start , number)
				loop
					exitwhen ( i == exitValue )
						//x < y
						if ( sc___prototype821_evaluate(binaryPredicate,s___AMissileContainer_element[s__AMissileContainer_element[this]+i] , s___AMissileContainer_element[s__AMissileContainer_element[this]+result]) ) then
							set result = i
						endif
					set i = i + 1
				endloop
				return result
   endfunction

			/// Mit dem []-Operator kann man auf ein Element des Containers zugreifen.
			/// @param index Index des Elements
			/// @return Das Element
   function s__AMissileContainer__getindex takes integer this,integer index returns integer
				return s__AMissileContainer_getElement(this,index)
   endfunction

			/// Mit dem []=-Operator kann man einem Element des Containers einen Wert zuweisen.
			/// @param index Index des Elements
			/// @param value Zuzuweisender Wert
   function s__AMissileContainer__setindex takes integer this,integer index,integer value returns nothing
				call s__AMissileContainer_setElement(this,index , value)
   endfunction

			/// Mit dem <-Operator kann man prüfen, ob der Container eine kleinere Größe als ein anderer hat.
			/// @param destination Vergleichs-Container
			/// @return Gibt wahr zurück, wenn der Container eine kleinere Größe als der Ziel-Container hat.
   function s__AMissileContainer__lessthan takes integer this,integer destination returns boolean
				return s___AMissileContainer_element_size < s___AMissileContainer_element_size
   endfunction

			// Mit dem >-Operator kann man prüfen, ob der Container eine größere Größe als ein anderer hat.
			// @param destination Vergleichs-Container
			// @return Gibt wahr zurück, wenn der Container eine kleinere Größe als der Ziel-Container hat.
			//public method operator> takes AMissileContainer destination returns boolean
				//return this.size > destionation.size
			//endmethod

		//Basic algorithm

		//The binary predicate represents the < operator.
		//function AMax takes AMissile x, AMissile y, AMissileContainerBinaryPredicate binaryPredicate returns $ELEMENTTYPE
		//	if (binaryPredicate.evaluate(x, y)) then
		//		return y
		//	endif
		//	return x
		//endfunction

		//function AMin takes AMissile x, AMissile y, AMissileContainerBinaryPredicate binaryPredicate returns $ELEMENTTYPE
		//	if (binaryPredicate.evaluate(x, y)) then
		//		return x
		//	endif
		//	return y
		//endfunction
//end of: A_CONTAINER("AMissile", "Missile", "100") /// @todo FIXME - size

//processed: 	function interface AMissileOnCollisionFunction takes AMissile missile returns nothing

//processed: 	function interface AMissileOnDeathFunction takes AMissile missile returns nothing

	/// Provides the functionality of a single physical missile which is able to cause damage and to have a widget source and target or three coordinate values (x, y and z).
	/// @todo Incompleted!
	/// @todo Add static method for missile containers.
	/// @todo Collision between missiles?!
	/// @author Draculark
	/// @author Tamino Dauth
	/// @source http://warcraft.ingame.de/forum/showthread.php?s=6f44abe813a621c950b94373b91ed929&threadid=186184
		//static start members
		//static members
		//dynamic members
		//members
		
//textmacro instance: A_STRUCT_DEBUG("\"AMissile\"") //ALibraryGeneralDebug
   function s__AMissile_print takes integer this,string message returns nothing
    call Print("AMissile" + " - " + I2S(this) + ": " + message)
   endfunction

   function s__AMissile_staticPrint takes string message returns nothing
    call Print("AMissile" + ": " + message)
   endfunction
//end of: A_STRUCT_DEBUG("\"AMissile\"") //ALibraryGeneralDebug
		
		//dynamic member methods
		
  function s__AMissile_setOwner takes integer this,player owner returns nothing
			set s__AMissile_m_owner[this]=owner
  endfunction
		
  function s__AMissile_owner takes integer this returns player
			return s__AMissile_m_owner[this]
  endfunction
		
  function s__AMissile_setUnitType takes integer this,integer unitType returns nothing
			set s__AMissile_m_unitType[this]=unitType
  endfunction
		
  function s__AMissile_unitType takes integer this returns integer
			return s__AMissile_m_unitType[this]
  endfunction
		
  function s__AMissile_setSpeed takes integer this,real speed returns nothing
			set s__AMissile_m_speed[this]=speed * s__AMissile_refreshTime
  endfunction
		
  function s__AMissile_speed takes integer this returns real
			return s__AMissile_m_speed[this]
  endfunction
		
  function s__AMissile_setDamage takes integer this,real damage returns nothing
			set s__AMissile_m_damage[this]=damage
  endfunction
		
  function s__AMissile_damage takes integer this returns real
			return s__AMissile_m_damage[this]
  endfunction
		
  function s__AMissile_setDamageRange takes integer this,real damageRange returns nothing
			set s__AMissile_m_damageRange[this]=damageRange
  endfunction
		
  function s__AMissile_damageRange takes integer this returns real
			return s__AMissile_m_damageRange[this]
  endfunction
		
  function s__AMissile_setTargetX takes integer this,real targetX returns nothing
			set s__AMissile_m_targetX[this]=targetX
  endfunction
		
  function s__AMissile_targetX takes integer this returns real
			return s__AMissile_m_targetX[this]
  endfunction
		
  function s__AMissile_setTargetY takes integer this,real targetY returns nothing
			set s__AMissile_m_targetY[this]=targetY
  endfunction
		
  function s__AMissile_targetY takes integer this returns real
			return s__AMissile_m_targetY[this]
  endfunction
		
  function s__AMissile_setTargetWidget takes integer this,widget targetWidget returns nothing
			set s__AMissile_m_targetWidget[this]=targetWidget
  endfunction
		
  function s__AMissile_targetWidget takes integer this returns widget
			return s__AMissile_m_targetWidget[this]
  endfunction
		
  function s__AMissile_setCollides takes integer this,boolean collides returns nothing
			set s__AMissile_m_collides[this]=collides
  endfunction
		
  function s__AMissile_collides takes integer this returns boolean
			return s__AMissile_m_collides[this]
  endfunction
		
  function s__AMissile_setDeathEffectPath takes integer this,string deathEffectPath returns nothing
			set s__AMissile_m_deathEffectPath[this]=deathEffectPath
  endfunction
		
  function s__AMissile_deathEffectPath takes integer this returns string
			return s__AMissile_m_deathEffectPath[this]
  endfunction
		
  function s__AMissile_setDeathSoundPath takes integer this,string deathSoundPath returns nothing
			set s__AMissile_m_deathSoundPath[this]=deathSoundPath
  endfunction
		
  function s__AMissile_deathSoundPath takes integer this returns string
			return s__AMissile_m_deathSoundPath[this]
  endfunction
		
  function s__AMissile_setOnCollisionFunction takes integer this,integer onCollisionFunction returns nothing
			set s__AMissile_m_onCollisionFunction[this]=onCollisionFunction
  endfunction
		
  function s__AMissile_onCollisionFunction takes integer this returns integer
			return s__AMissile_m_onCollisionFunction[this]
  endfunction
		
  function s__AMissile_setOnDeathFunction takes integer this,integer onDeathFunction returns nothing
			set s__AMissile_m_onDeathFunction[this]=onDeathFunction
  endfunction
		
  function s__AMissile_onDeathFunction takes integer this returns integer
			return s__AMissile_m_onDeathFunction[this]
  endfunction
		
		//convenience methods
		
  function s__AMissile_startFromUnit takes integer this,unit usedUnit returns nothing
			call sc__AMissile_start(this,GetUnitX(usedUnit) , GetUnitY(usedUnit) , GetUnitZ(usedUnit) , GetUnitFacing(usedUnit)) //ALibraryMathsHandle
  endfunction
		
		/// Makes the missile unpaused which means that it will be moved next time when the periodic trigger moves all unpaused missiles.
  function s__AMissile_continue takes integer this returns nothing
			set s__AMissile_paused[this]=true
  endfunction

		/// A paused missile won't be moved until it gets unpaused.
  function s__AMissile_pause takes integer this returns nothing
			set s__AMissile_paused[this]=false
  endfunction
		
		//public methods

		/// Starts the missile from coordinates @param x, @param y, and @param z with angle @param angle.
  function s__AMissile_start takes integer this,real x,real y,real z,real angle returns nothing
    if ( s__AMissile_usedUnit[this] != null ) then
     call s__AMissile_print(this,"Missile has already been started.")
     return 
    endif

			set s__AMissile_usedUnit[this]=CreateUnit(s__AMissile_m_owner[this] , s__AMissile_m_unitType[this] , x , y , angle)
			call SetUnitInvulnerable(s__AMissile_usedUnit[this] , true)
			call MakeUnitSelectable(s__AMissile_usedUnit[this] , false) //ALibraryInterfaceSelection
			call SetUnitZ(s__AMissile_usedUnit[this] , z) //ALibraryMathsHandle
			set s__AMissile_paused[this]=false
  endfunction

		/// Stops the missile. This means that the missile will be destroyed, damage will be distributed, a death effect will be shown, a death sound will be played and the death function will be executed.
  function s__AMissile_stop takes integer this returns nothing
			call sc__AMissile_causeDamage(this)
			call sc__AMissile_showDeathEffect(this)
			call sc__AMissile_playDeathSound(this)
			call RemoveUnit(s__AMissile_usedUnit[this])
			set s__AMissile_usedUnit[this]=null
			set s__AMissile_paused[this]=true
			if ( s__AMissile_m_onDeathFunction[this] != 0 ) then
				call sc___prototype822_execute(s__AMissile_m_onDeathFunction[this],this)
			endif
  endfunction
		
  function s__AMissile_setPaused takes integer this,boolean paused returns nothing
			set s__AMissile_paused[this]=paused
  endfunction
		
  function s__AMissile_isPaused takes integer this returns boolean
			return s__AMissile_paused[this]
  endfunction
		
		//private methods

  function s__AMissile_move takes integer this returns nothing
   local rect mapRect= GetPlayableMapRect()
   local real currentX= GetUnitX(s__AMissile_usedUnit[this])
   local real currentY= GetUnitY(s__AMissile_usedUnit[this])
   local real angle
   local real newX
   local real newY
			
			if ( s__AMissile_m_targetWidget[this] != null ) then
				set angle = Atan2(GetWidgetY(s__AMissile_m_targetWidget[this]) - currentY , GetWidgetX(s__AMissile_m_targetWidget[this]) - currentX)
			else
				set angle = Atan2(s__AMissile_m_targetY[this] - currentY , s__AMissile_m_targetX[this] - currentX)
			endif
			set s__AMissile_cos[this]=Cos(angle)
			set s__AMissile_sin[this]=Sin(angle)
			call SetUnitFacing(s__AMissile_usedUnit[this] , angle)
			set newX = currentX + s__AMissile_m_speed[this] * s__AMissile_cos[this]
			set newY = currentY + s__AMissile_m_speed[this] * s__AMissile_sin[this]
			
			if ( s__AMissile_m_collides[this] ) then
				
			endif
			
			if ( RectContainsCoords(mapRect , newX , newY) and not IsTerrainPathable(newX , newY , PATHING_TYPE_WALKABILITY) ) then
				call SetUnitX(s__AMissile_usedUnit[this] , newX)
				call SetUnitY(s__AMissile_usedUnit[this] , newY)
			else
				call s__AMissile_stop(this)
			endif
  endfunction
		
  function s__AMissile_causeDamage takes integer this returns nothing
			if ( s__AMissile_m_damage[this] <= 0.0 ) then
				return 
			endif
		
			if ( s__AMissile_m_damageRange[this] > 0.0 ) then
				//cause area damage to units who aren't allies of the source unit
			elseif ( s__AMissile_m_targetWidget[this] != null ) then
				//cause single target damage if missile hits widget otherwise show floating text?
			endif
  endfunction
		
  function s__AMissile_showDeathEffect takes integer this returns nothing
   local effect createdEffect
			if ( s__AMissile_m_deathEffectPath[this] != null ) then
				set createdEffect = AddSpecialEffect(s__AMissile_m_deathEffectPath[this] , GetUnitX(s__AMissile_usedUnit[this]) , GetUnitY(s__AMissile_usedUnit[this]))
				call DestroyEffect(createdEffect)
				set createdEffect = null
			endif
  endfunction
		
  function s__AMissile_playDeathSound takes integer this returns nothing
			if ( s__AMissile_m_deathSoundPath[this] != null ) then
				call PlaySound(s__AMissile_m_deathSoundPath[this]) /// @todo use coordinates!
			endif
  endfunction

  function s__AMissile_create takes nothing returns integer
   local integer this= s__AMissile__allocate()
			//members
			set s__AMissile_paused[this]=true

			set s__s__AMissile_missiles[s__AMissile_missileCount]= this
			set s__AMissile_missileCount=s__AMissile_missileCount + 1
			return this
  endfunction

  function s__AMissile_onDestroy takes integer this returns nothing
			if ( s__AMissile_usedUnit[this] != null ) then
				call RemoveUnit(s__AMissile_usedUnit[this])
			endif
			set s__AMissile_usedUnit[this]=null
  endfunction

//Generated destructor of AMissile
function s__AMissile_destroy takes integer this returns nothing
    if this==null then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: AMissile")
        return
    elseif (si__AMissile_V[this]!=-1) then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: AMissile")
        return
    endif
    call s__AMissile_onDestroy(this)
    set si__AMissile_V[this]=si__AMissile_F
    set si__AMissile_F=this
endfunction

  function s__AMissile_refreshTriggerAction takes nothing returns nothing
   local integer i= 0
			loop
				exitwhen ( i == s__AMissile_missileCount )
				if ( not s__AMissile_paused[s__s__AMissile_missiles[i]] ) then
					call s__AMissile_move(s__s__AMissile_missiles[i])
				endif
				set i = i + 1
			endloop
  endfunction

  function s__AMissile_createRefreshTrigger takes nothing returns nothing
   local event triggerEvent
   local triggeraction triggerAction
			set s__AMissile_refreshTrigger=CreateTrigger()
			set triggerEvent = TriggerRegisterTimerEvent(s__AMissile_refreshTrigger , s__AMissile_refreshTime , true)
			set triggerAction = TriggerAddAction(s__AMissile_refreshTrigger , function s__AMissile_refreshTriggerAction)
			set triggerEvent = null
			set triggerAction = null
  endfunction

  function s__AMissile_init takes real refreshTime,boolean enableCollisions returns nothing
    if ( refreshTime <= 0.0 ) then
     call Print("Wrong value refresh time value in AMissile struct initialization: " + R2S(refreshTime) + ".")
    endif
			set s__AMissile_refreshTime=refreshTime
			set s__AMissile_enableCollisions=enableCollisions
			set s__AMissile_missileCount=0
			call s__AMissile_createRefreshTrigger()
  endfunction

  function s__AMissile_cleanUp takes nothing returns nothing
   local integer i= 0
			call DestroyTrigger(s__AMissile_refreshTrigger)
			set s__AMissile_refreshTrigger=null
			//remove all missiles
			loop
				exitwhen ( i == s__AMissile_missileCount )
				call s__AMissile_destroy(s__s__AMissile_missiles[i])
				set i = i + 1
			endloop
  endfunction

  function s__AMissile_enable takes nothing returns nothing
			call EnableTrigger(s__AMissile_refreshTrigger)
  endfunction

  function s__AMissile_disable takes nothing returns nothing
			call DisableTrigger(s__AMissile_refreshTrigger)
  endfunction
		
		//convenience methods
		
		//public static method createCircle takes real sourceX, real sourceY, real sourceZ, real radius, integer count, boolean start, integer unitType, real speed, real damage, real damageRange, string deathEffectPath, string deathSoundPath, AMissileOnDeathFunction onDeathFunction returns AMissileContainer
		//	local integer i = 0
		//	local AMissileContainer container = AContainer.create()
		//	local AMissile missile
		//	loop
		//		exitwhen (i == count)
		//		set missile = AMissile.create()
		//		call missile.setUnitType(unitType)
		//		call missile.setSpeed(speed)
		//		call missile.setDamage(damage)
		//		call missile.setDamageRange(damageRange)
		//		call missile.setDeathEffectPath(deathEffectPath)
		//		call missile.setDeathSoundPath(deathSoundPath)
		//		call missile.onDeathFunction(onDeathFunction)
				//etc.
		//		set container[i] = missile
		//		set i = i + 1
		//	endloop
		//	if (start) then
		//		set i = 0
		//		loop
		//			exitwhen (i == count)
		//			call container[i].start()
		//			set i = i + 1
		//		endloop
		//	endif
		//	return container
		//endmethod


//library AStructCoreEnvironmentMissile ends
//library AStructCoreInterfaceInterfaceHashTable:


  function s__AStructCoreInterfaceInterfaceHashTable___AInterfaceHashTable_create takes nothing returns integer
			return 0
  endfunction

  function s__AStructCoreInterfaceInterfaceHashTable___AInterfaceHashTable_onDestroy takes integer this returns nothing
  endfunction

//Generated destructor of AStructCoreInterfaceInterfaceHashTable___AInterfaceHashTable
function s__AStructCoreInterfaceInterfaceHashTable___AInterfaceHashTable_destroy takes integer this returns nothing
    if this==null then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: AStructCoreInterfaceInterfaceHashTable___AInterfaceHashTable")
        return
    elseif (si__AStructCoreInterfaceInterfaceHashTable___AInterfaceHashTable_V[this]!=-1) then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: AStructCoreInterfaceInterfaceHashTable___AInterfaceHashTable")
        return
    endif
    call s__AStructCoreInterfaceInterfaceHashTable___AInterfaceHashTable_onDestroy(this)
    set si__AStructCoreInterfaceInterfaceHashTable___AInterfaceHashTable_V[this]=si__AStructCoreInterfaceInterfaceHashTable___AInterfaceHashTable_F
    set si__AStructCoreInterfaceInterfaceHashTable___AInterfaceHashTable_F=this
endfunction

  function s__AStructCoreInterfaceInterfaceHashTable___AInterfaceHashTable_getInstance takes nothing returns integer
			if ( s__AStructCoreInterfaceInterfaceHashTable___AInterfaceHashTable_instance == 0 ) then
				set s__AStructCoreInterfaceInterfaceHashTable___AInterfaceHashTable_instance=s__AHashTable_create("AInterfaceHashTable")
			endif
			return s__AStructCoreInterfaceInterfaceHashTable___AInterfaceHashTable_instance
  endfunction

 function AGetInterfaceHashTable takes nothing returns integer
		return s__AStructCoreInterfaceInterfaceHashTable___AInterfaceHashTable_getInstance()
	endfunction


//library AStructCoreInterfaceInterfaceHashTable ends
//library AStructSystemsCharacterCharacterHashTable:


  function s__AStructSystemsCharacterCharacterHashTable___ACharacterHashTable_create takes nothing returns integer
			return 0
  endfunction

  function s__AStructSystemsCharacterCharacterHashTable___ACharacterHashTable_onDestroy takes integer this returns nothing
  endfunction

//Generated destructor of AStructSystemsCharacterCharacterHashTable___ACharacterHashTable
function s__AStructSystemsCharacterCharacterHashTable___ACharacterHashTable_destroy takes integer this returns nothing
    if this==null then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: AStructSystemsCharacterCharacterHashTable___ACharacterHashTable")
        return
    elseif (si__AStructSystemsCharacterCharacterHashTable___ACharacterHashTable_V[this]!=-1) then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: AStructSystemsCharacterCharacterHashTable___ACharacterHashTable")
        return
    endif
    call s__AStructSystemsCharacterCharacterHashTable___ACharacterHashTable_onDestroy(this)
    set si__AStructSystemsCharacterCharacterHashTable___ACharacterHashTable_V[this]=si__AStructSystemsCharacterCharacterHashTable___ACharacterHashTable_F
    set si__AStructSystemsCharacterCharacterHashTable___ACharacterHashTable_F=this
endfunction

  function s__AStructSystemsCharacterCharacterHashTable___ACharacterHashTable_getInstance takes nothing returns integer
			if ( s__AStructSystemsCharacterCharacterHashTable___ACharacterHashTable_instance == 0 ) then
				set s__AStructSystemsCharacterCharacterHashTable___ACharacterHashTable_instance=s__AHashTable_create("ACharacterHashTable")
			endif
			return s__AStructSystemsCharacterCharacterHashTable___ACharacterHashTable_instance
  endfunction

 function AGetCharacterHashTable takes nothing returns integer
		return s__AStructSystemsCharacterCharacterHashTable___ACharacterHashTable_getInstance()
	endfunction


//library AStructSystemsCharacterCharacterHashTable ends
//library AStructSystemsWorldWorldHashTable:


  function s__AStructSystemsWorldWorldHashTable__AWorldHashTable_create takes nothing returns integer
			return 0
  endfunction

  function s__AStructSystemsWorldWorldHashTable__AWorldHashTable_onDestroy takes integer this returns nothing
  endfunction

//Generated destructor of AStructSystemsWorldWorldHashTable__AWorldHashTable
function s__AStructSystemsWorldWorldHashTable__AWorldHashTable_destroy takes integer this returns nothing
    if this==null then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: AStructSystemsWorldWorldHashTable__AWorldHashTable")
        return
    elseif (si__AStructSystemsWorldWorldHashTable__AWorldHashTable_V[this]!=-1) then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: AStructSystemsWorldWorldHashTable__AWorldHashTable")
        return
    endif
    call s__AStructSystemsWorldWorldHashTable__AWorldHashTable_onDestroy(this)
    set si__AStructSystemsWorldWorldHashTable__AWorldHashTable_V[this]=si__AStructSystemsWorldWorldHashTable__AWorldHashTable_F
    set si__AStructSystemsWorldWorldHashTable__AWorldHashTable_F=this
endfunction

  function s__AStructSystemsWorldWorldHashTable__AWorldHashTable_getInstance takes nothing returns integer
			if ( s__AStructSystemsWorldWorldHashTable__AWorldHashTable_instance == 0 ) then
				set s__AStructSystemsWorldWorldHashTable__AWorldHashTable_instance=s__AHashTable_create("AWorldHashTable")
			endif
			return s__AStructSystemsWorldWorldHashTable__AWorldHashTable_instance
  endfunction

 function AGetWorldHashTable takes nothing returns integer
		return s__AStructSystemsWorldWorldHashTable__AWorldHashTable_getInstance()
	endfunction


//library AStructSystemsWorldWorldHashTable ends
//library ACoreEnvironment:

//library ACoreEnvironment ends
//library ACoreMaths:

//library ACoreMaths ends
//library ACoreString:

//library ACoreString ends
//library ALibraryCoreDebugContainer:

//textmacro instance: A_CONTAINER("integer", "Integer", "1000")

		/// @state untested
		/// An operation function interface with two elements.
		/// The return value is the result of the operation.
		/// Examples are addition and subtraction etc.
//processed: 		function interface AIntegerContainerOperation takes integer element0, integer element1 returns integer

		/// @state untested
		/// Unary predicate.
		/// A comparision function interface for one element.
//processed: 		function interface AIntegerContainerUnaryPredicate takes integer element returns boolean

		/// @state untested
		/// Binary predicate.
		/// A comparisan function interface for two elements.
//processed: 		function interface AIntegerContainerBinaryPredicate takes integer element0, integer element1 returns boolean

		/// @state works
		/// Unary function.
		/// Allows the call of an user-definied function for each element.
//processed: 		function interface AIntegerContainerUnaryFunction takes integer element returns nothing //Rückgabewert wurde vorerst rausgenommen, bis ich weiß, was er bringt

		/// Generator.
		/// Allows filling some elements with the return value.
//processed: 		function interface AIntegerContainerGenerator takes nothing returns integer

			//dynamic members
			//Quicksort statics

			//dynamic members

   function s__AIntegerContainer_setElement takes integer this,integer index,integer element returns nothing
     call sc__AIntegerContainer_debugCheckIndex(this,index)
				set s___AIntegerContainer_element[s__AIntegerContainer_element[this]+index]=element
   endfunction

   function s__AIntegerContainer_getElement takes integer this,integer index returns integer
     call sc__AIntegerContainer_debugCheckIndex(this,index)
				return s___AIntegerContainer_element[s__AIntegerContainer_element[this]+index]
   endfunction

			//start members

   function s__AIntegerContainer_getSize takes integer this returns integer
				return s___AIntegerContainer_element_size
   endfunction

			//methods

			/// Checks the start position.
    function s__AIntegerContainer_debugCheckStart takes integer this,integer start returns nothing
     if ( ( start < 0 ) or ( start >= 1000 ) ) then
      call Print("Wrong start value of container " + I2S(this) + ": start " + I2S(start) + ".")
     endif
    endfunction

			/// Checks the number.
    function s__AIntegerContainer_debugCheckNumber takes integer this,integer number returns nothing
     if ( ( number > 1000 ) or ( number <= 0 ) ) then
      call Print("Wrong number value of container " + I2S(this) + ": number " + I2S(number) + ".")
     endif
    endfunction

			/// Checks both values.
    function s__AIntegerContainer_debugCheckStartAndNumber takes integer this,integer start,integer number returns nothing
     call s__AIntegerContainer_debugCheckStart(this,start)
     call s__AIntegerContainer_debugCheckNumber(this,number)
     if ( start + number > 1000 ) then
      call Print("Wrong start or number value of container " + I2S(this) + ": start " + I2S(start) + " number " + I2S(number) + ".")
     endif
    endfunction

			/// Checks over- and underflow of the size.
    function s__AIntegerContainer_debugCheckSize takes integer this,integer size returns nothing
     if ( size > 1000 ) then
      call Print("Wrong size of container " + I2S(this) + ": " + I2S(size) + ".")
     endif
    endfunction
	
			/// Checks over- and underflow of the index.
    function s__AIntegerContainer_debugCheckIndex takes integer this,integer index returns nothing
     if ( ( index < 0 ) or ( index >= 1000 ) ) then
      call Print("Wrong index of container " + I2S(this) + ": " + I2S(index) + ".")
     endif
    endfunction

			/// Common quick sort algorithm.
   function s__AIntegerContainer_quickSort takes integer this,integer left,integer right,integer binaryPredicate returns nothing
    local integer i
    local integer temp
				if ( right > left ) then
					set s__AIntegerContainer_m[this]=s___AIntegerContainer_element[s__AIntegerContainer_element[this]+right]
					set i = left - 1
					set s__AIntegerContainer_j[this]=right
					loop
						loop
							set i = i + 1
							exitwhen ( not sc___prototype826_evaluate(binaryPredicate,s___AIntegerContainer_element[s__AIntegerContainer_element[this]+i] , s__AIntegerContainer_m[this]) )
						endloop
						
						loop
							set s__AIntegerContainer_j[this]=s__AIntegerContainer_j[this] - 1
							exitwhen ( sc___prototype826_evaluate(binaryPredicate,s___AIntegerContainer_element[s__AIntegerContainer_element[this]+s__AIntegerContainer_j[this]] , s__AIntegerContainer_m[this]) )
						endloop
		
						exitwhen ( i >= s__AIntegerContainer_j[this] )
						set temp = s___AIntegerContainer_element[s__AIntegerContainer_element[this]+i]
						set s___AIntegerContainer_element[s__AIntegerContainer_element[this]+i]=s___AIntegerContainer_element[s__AIntegerContainer_element[this]+s__AIntegerContainer_j[this]]
						set s___AIntegerContainer_element[s__AIntegerContainer_element[this]+s__AIntegerContainer_j[this]]=temp
					endloop
					
					set temp = s___AIntegerContainer_element[s__AIntegerContainer_element[this]+i]
					set s___AIntegerContainer_element[s__AIntegerContainer_element[this]+i]=s___AIntegerContainer_element[s__AIntegerContainer_element[this]+right]
					set s___AIntegerContainer_element[s__AIntegerContainer_element[this]+right]=temp
					
					call s__AIntegerContainer_quickSort(this,left , i - 1 , binaryPredicate)
					call s__AIntegerContainer_quickSort(this,i + 1 , right , binaryPredicate)
				endif
   endfunction

			/// Sorts elements by using the quick sort algorithm in ascending order.
			/// @param start Index of first element.
			/// @param number Number of elements.
			/// @param binaryPredicate Binary comparison function.
   function s__AIntegerContainer_sort takes integer this,integer start,integer number,integer binaryPredicate returns nothing
     call s__AIntegerContainer_debugCheckStartAndNumber(this,start , number)
				call s__AIntegerContainer_quickSort(this,start , start + number - 1 , binaryPredicate)
   endfunction

			/// Reverses elements.
			/// @param start Index of first element.
			/// @param number Number of elements.
			/// @todo I'm not sure if this is best solution.
   function s__AIntegerContainer_reverse takes integer this,integer start,integer number returns nothing
    local integer i= start
    local integer exitValue= start + ( number / 2 )
    local integer temp
    local integer swapindex
     call s__AIntegerContainer_debugCheckStartAndNumber(this,start , number)
				loop
					exitwhen ( i == exitValue )
					set swapindex = ( ( 2 * start ) + number - i - 1 )
					set temp = s___AIntegerContainer_element[s__AIntegerContainer_element[this]+i]
					set s___AIntegerContainer_element[s__AIntegerContainer_element[this]+i]=s___AIntegerContainer_element[s__AIntegerContainer_element[this]+swapindex]
					set s___AIntegerContainer_element[s__AIntegerContainer_element[this]+swapindex]=temp
					set i = i + 1
				endloop
   endfunction

			//C++ algorithm

			/// @state untested
			/// Orientiert sich an accumulate und adjacent_difference.
			/// Man kann allerdings nicht jeden Datentyp addieren oder subtrahieren.
			/// Führt eine Operation mit allen Elementen in einem Bereich durch.
			/// @param start Startposition
			/// @param number Anzahl der Elemente
			/// @param value Der Startwert des Ergebnis
			/// @param operation Operationsfunktion
			/// @return Ergebnis aller Operationen
   function s__AIntegerContainer_operation takes integer this,integer start,integer number,integer value,integer operation returns integer
    local integer i= start
    local integer exitValue= start + number
    local integer result= value
     call s__AIntegerContainer_debugCheckStartAndNumber(this,start , number)
				loop
					exitwhen ( i == exitValue )
					set result = sc___prototype824_evaluate(operation,result , s___AIntegerContainer_element[s__AIntegerContainer_element[this]+i]) //Returns something
					set i = i + 1
				endloop
				return result
   endfunction

			/// @state untested
			/// Sucht nach zwei aneinander liegenden gleichen Elementen.
			/// @param start Startposition
			/// @param number Anzahl der Elemente
			/// @return Index des ersten Treffers oder -1
   function s__AIntegerContainer_adjacentFind takes integer this,integer start,integer number returns integer
    local integer i= start
    local integer exitValue= start + number - 1 //-1 da beim Vergleich + 1 angewendet wird
     call s__AIntegerContainer_debugCheckStartAndNumber(this,start , number)
				loop
					exitwhen ( i == exitValue )
					if ( s___AIntegerContainer_element[s__AIntegerContainer_element[this]+i] == s___AIntegerContainer_element[s__AIntegerContainer_element[this]+i + 1] ) then
						return i
					endif
					set i = i + 1
				endloop
				return - 1
   endfunction

			/// @state untested
			/// Sucht mit Hilfe einer benutzerdefinierten Vergleichsfunktion nach zwei aneinander liegenden gleichen Elementen.
			/// @param start Startposition
			/// @param number Anzahl der Elemente
			/// @param binaryPredicate Vergleichsfunktion
			/// @return Index des ersten Treffers oder -1
   function s__AIntegerContainer_adjacentFindIf takes integer this,integer start,integer number,integer binaryPredicate returns integer
    local integer i= start
    local integer exitValue= start + number - 1 //-1 da beim Vergleich + 1 angewendet wird
     call s__AIntegerContainer_debugCheckStartAndNumber(this,start , number)
				loop
					exitwhen ( i == exitValue )
					if ( sc___prototype826_evaluate(binaryPredicate,s___AIntegerContainer_element[s__AIntegerContainer_element[this]+i] , s___AIntegerContainer_element[s__AIntegerContainer_element[this]+i + 1]) ) then
						return i
					endif
					set i = i + 1
				endloop
				return - 1
   endfunction

			/// @state untested
			/// Die binäre Suche funktioniert nur wenn die Elemente in Reihenfolge sortiert sind.
			/// @todo Noch implementieren.
			/// @todo bool binary_search( iterator start, iterator end, const TYPE& val );
			/// @todo bool binary_search( iterator start, iterator end, const TYPE& val, Comp f );
   function s__AIntegerContainer_binarySearch takes integer this returns nothing
   endfunction

			/// @state untested
			/// Kopiert einen Elementebereich des Containers in einen Ziel-Container.
			/// @param start0 Index of first element.
			/// @param number0 Number of elements.
			/// @param start1 Index of first element in container @param desitination.
			/// @param destination Container where elements are copied to.
   function s__AIntegerContainer_copy takes integer this,integer start0,integer number0,integer start1,integer destination returns nothing
    local integer i= start0
    local integer j= start1
    local integer exitValue= start0 + number0
     call s__AIntegerContainer_debugCheckStartAndNumber(this,start0 , number0)
     call s__AIntegerContainer_debugCheckStart(destination,start1)
				loop
					exitwhen ( i == exitValue )
					set s___AIntegerContainer_element[s__AIntegerContainer_element[destination]+j]=s___AIntegerContainer_element[s__AIntegerContainer_element[this]+i]
					set i = i + 1
					set j = j + 1
				endloop
   endfunction

			/// @state untested
			/// Kopiert einen Elementebereich des Containers in einen Ziel-Container.
			/// Im Gegensatz zur copy-Methode fängt diese Methode beim letzten zu kopierenden Wert an.
			/// @param start0 Startposition
			/// @param number0 Anzahl der Elemente
			/// @param start1 Startposition im Ziel-Container
			/// @param destination Ziel-Container
   function s__AIntegerContainer_copyBackward takes integer this,integer start0,integer number0,integer start1,integer destination returns nothing
    local integer i= start0 + number0 - 1
    local integer j= start1 + number0 - 1
    local integer exitValue= start0 - 1
     call s__AIntegerContainer_debugCheckStartAndNumber(this,start0 , number0)
     call s__AIntegerContainer_debugCheckStart(destination,start1)
				loop
					exitwhen ( i == exitValue )
					set s___AIntegerContainer_element[s__AIntegerContainer_element[destination]+j]=s___AIntegerContainer_element[s__AIntegerContainer_element[this]+i]
					set i = i - 1
					set j = j - 1
				endloop
   endfunction

			/// Diese Methode tut das, was die Methoden dieses Containers von C++-Containern unterscheidet.
			/// Sie verwendet als zweiten Parameter die Anzahl der Elemente und keinen Ziel-Iterator.
			/// Sie ist daher überflüssig.
			/// iterator copy_n( iterator from, size_t num, iterator to );
   function s__AIntegerContainer_copyN takes integer this returns nothing
   endfunction

			/// @state untested
			/// Vergleicht einen Elementebereich mit einem Wert.
			/// @param start Startposition
			/// @param number Anzahl der Elemente
			/// @param value Vergleichswert
			/// @return Anzahl der Treffer
   function s__AIntegerContainer_count takes integer this,integer start,integer number,integer value returns integer
    local integer i= start
    local integer exitValue= start + number
    local integer result= 0
     call s__AIntegerContainer_debugCheckStartAndNumber(this,start , number)
				loop
					exitwhen ( i == exitValue )
					if ( s___AIntegerContainer_element[s__AIntegerContainer_element[this]+i] == value ) then
						set result = result + 1
					endif
					set i = i + 1
				endloop
				return result
   endfunction

			/// @state untested
			/// Vergleicht einen Elementebereich mit Hilfe einer benutzerdefinierten Funktion.
			/// @param start Startposition
			/// @param number Anzahl der Elemente
			/// @param unaryPredicate Vergleichsfunktion
			/// @return Anzahl der Treffer
   function s__AIntegerContainer_countIf takes integer this,integer start,integer number,integer unaryPredicate returns integer
    local integer i= start
    local integer exitValue= start + number
    local integer result= 0
     call s__AIntegerContainer_debugCheckStartAndNumber(this,start , number)
				loop
					exitwhen ( i == exitValue )
					if ( sc___prototype825_evaluate(unaryPredicate,s___AIntegerContainer_element[s__AIntegerContainer_element[this]+i]) ) then
						set result = result + 1
					endif
					set i = i + 1
				endloop
				return result
   endfunction

			/// @state untested
			/// Prüft ob ein Elementebereich einem anderen entspricht.
			/// Verwendet dabei den Standard ==-Operator, der normalerweise bei allen Datentypen anwendbar ist.
			/// @param start1 Startposition
			/// @param number1 Anzahl der Elemente
			/// @param start2 Startposition im Vergleichs-Container
			/// @param destination Vergleichs-Container
			/// @return Übereinstimmung aller Elemente
   function s__AIntegerContainer_equal takes integer this,integer start1,integer number1,integer start2,integer destination returns boolean
    local integer i= start1
    local integer j= start2
    local integer exitValue= start1 + number1
     call s__AIntegerContainer_debugCheckStartAndNumber(this,start1 , number1)
     call s__AIntegerContainer_debugCheckStart(destination,start2)
				loop
					exitwhen ( i == exitValue )
						if ( not ( s___AIntegerContainer_element[s__AIntegerContainer_element[this]+i] == s___AIntegerContainer_element[s__AIntegerContainer_element[destination]+j] ) ) then
							return false
						endif
					set i = i + 1
					set j = j + 1
				endloop
				return true
   endfunction

			/// @state untested
			/// Prüft mit Hilfe einer benutzerdefinierten Vergleichsfunktion ob ein Elementebereich einem anderen entspricht.
			/// @param start0 Startposition
			/// @param number0 Anzahl der Elemente
			/// @param start1 Startposition im Vergleichs-Container
			/// @param destination Vergleichs-Container
			/// @param binaryPredicate Vergleichsfunktion
			/// @return Übereinstimmung aller Elemente
   function s__AIntegerContainer_equalIf takes integer this,integer start0,integer number0,integer start1,integer destination,integer binaryPredicate returns boolean
    local integer i= start0
    local integer j= start1
    local integer exitValue= start0 + number0
     call s__AIntegerContainer_debugCheckStartAndNumber(this,start0 , number0)
     call s__AIntegerContainer_debugCheckStart(destination,start1)
				loop
					exitwhen ( i == exitValue )
						if ( not sc___prototype826_evaluate(binaryPredicate,s___AIntegerContainer_element[s__AIntegerContainer_element[this]+i] , s___AIntegerContainer_element[s__AIntegerContainer_element[destination]+j]) ) then
							return false
						endif
					set i = i + 1
					set j = j + 1
				endloop
				return true
   endfunction

			/// @state untested
			/// Füllt einen Elementebereich mit einem Wert.
			/// @param start Startposition
			/// @param number Anzahl der Elemente
			/// @param value Zu füllender Wert
   function s__AIntegerContainer_fill takes integer this,integer start,integer number,integer value returns nothing
    local integer i= start
    local integer exitValue= start + number
     call s__AIntegerContainer_debugCheckStartAndNumber(this,start , number)
				loop
					exitwhen ( i == exitValue )
						set s___AIntegerContainer_element[s__AIntegerContainer_element[this]+i]=value
					set i = i + 1
				endloop
   endfunction

			/// Diese Methode tut das, was die Methoden dieses Containers von C++-Containern unterscheidet.
			/// Sie verwendet als zweiten Parameter die Anzahl der Elemente und keinen Ziel-Iterator.
			/// Sie ist daher überflüssig.
			/// iterator fill_n( iterator start, size_t n, const TYPE& val );
   function s__AIntegerContainer_fillN takes integer this returns nothing
   endfunction

			/// @state untested
			/// Sucht im Container nach einem Element mit einem bestimmten Wert.
			/// @param start Index of first element which is checked for the searched value.
			/// @param number Number of elements which are checked for the searched value.
			/// @param value Searched value.
			/// @return Returns the index of the first hit. If there was no hit it returns -1.
   function s__AIntegerContainer_find takes integer this,integer start,integer number,integer value returns integer
    local integer i= start
    local integer exitValue= start + number
     call s__AIntegerContainer_debugCheckStartAndNumber(this,start , number)
				loop
					exitwhen ( i == exitValue )
					if ( s___AIntegerContainer_element[s__AIntegerContainer_element[this]+i] == value ) then
						return i
					endif
					set i = i + 1
				endloop
				return - 1
   endfunction

			/// @todo iterator find_end( iterator start, iterator end, iterator seq_start, iterator seq_end );
			/// @todo iterator find_end( iterator start, iterator end, iterator seq_start, iterator seq_end, BinPred bp );
   function s__AIntegerContainer_findEnd takes integer this returns nothing
   endfunction

			/// @todo iterator find_first_of( iterator start, iterator end, iterator find_start, iterator find_end );
			/// @todo iterator find_first_of( iterator start, iterator end, iterator find_start, iterator find_end, BinPred bp );
   function s__AIntegerContainer_findFirstOf takes integer this returns nothing
   endfunction

			/// @state untested
			/// Sucht mit Hilfe einer benutzerdefinierten Funktion ein Element im Container.
			/// @param start Startposition
			/// @param number Anzahl der Elemente
			/// @param unaryPredicate Vergleichsfunktion
			/// @return Index des ersten Treffers oder -1
   function s__AIntegerContainer_findIf takes integer this,integer start,integer number,integer unaryPredicate returns integer
    local integer i= start
    local integer exitValue= start + number
     call s__AIntegerContainer_debugCheckStartAndNumber(this,start , number)
				loop
					exitwhen ( i == exitValue )
						if ( sc___prototype825_evaluate(unaryPredicate,s___AIntegerContainer_element[s__AIntegerContainer_element[this]+i]) ) then
							return i
						endif
					set i = i + 1
				endloop
				return - 1
   endfunction

			/// @state untested
			/// Führt eine benutzerdefinierte Funktion für einen Elementebereich aus.
			/// @param start Startposition
			/// @param number Anzahl der Elemente
			/// @param unaryFunction Benutzerdefinierte Funktion
   function s__AIntegerContainer_forEach takes integer this,integer start,integer number,integer unaryFunction returns nothing
    local integer i= start
    local integer exitValue= start + number
     call s__AIntegerContainer_debugCheckStartAndNumber(this,start , number)
				loop
					exitwhen ( i == exitValue )
						call sc___prototype789_execute(unaryFunction,s___AIntegerContainer_element[s__AIntegerContainer_element[this]+i])
					set i = i + 1
				endloop
   endfunction

			/// void generate( iterator start, iterator end, Generator g );
			/// @state untested
			/// Füllt einen Elementebereich mit dem Rückgabewert einer benutzerdefinierten Funktion.
			/// Funktion wurde so in Quell-Code des GCCs nachgeschlagen.
			/// @param start Startposition
			/// @param number Anzahl der Elemente
			/// @param generator Benutzerdefinierte Funktion
   function s__AIntegerContainer_generate takes integer this,integer start,integer number,integer generator returns nothing
    local integer i= start
    local integer exitValue= start + number
     call s__AIntegerContainer_debugCheckStartAndNumber(this,start , number)
				loop
					exitwhen ( i == exitValue )
						set s___AIntegerContainer_element[s__AIntegerContainer_element[this]+i]=sc___prototype731_evaluate(generator)
					set i = i + 1
				endloop
   endfunction

			/// Diese Methode tut das, was die Methoden dieses Containers von C++-Containern unterscheidet.
			/// Sie verwendet als zweiten Parameter die Anzahl der Elemente und keinen Ziel-Iterator.
			/// Sie ist daher überflüssig.
			/// iterator generate_n( iterator result, size_t num, Generator g );
   function s__AIntegerContainer_generate_n takes integer this returns nothing
   endfunction

			/// @todo bool includes( iterator start1, iterator end1, iterator start2, iterator end2 );
			/// @todo bool includes( iterator start1, iterator end1, iterator start2, iterator end2, StrictWeakOrdering cmp );
			/// @todo The includes() algorithm returns true if every element in [start2,end2) is also in [start1,end1). Both of the given ranges must be sorted in ascending order.
			/// @todo By default, the < operator is used to compare elements. If the strict weak ordering function object cmp is given, then it is used instead.
   function s__AIntegerContainer_includes takes integer this returns nothing
   endfunction

			/// @todo TYPE inner_product( iterator start1, iterator end1, iterator start2, TYPE val );
			/// @todo TYPE inner_product( iterator start1, iterator end1, iterator start2, TYPE val, BinaryFunction f1, BinaryFunction f2 );
			/// @todo The inner_product() function computes the inner product of [start1,end1) and a range of the same size starting at start2.
   function s__AIntegerContainer_inner_product takes integer this returns nothing
   endfunction

			/// @todo inline void inplace_merge( iterator start, iterator middle, iterator end );
			/// @todo inline void inplace_merge( iterator start, iterator middle, iterator end, StrictWeakOrdering cmp );
			/// @todo The inplace_merge() function is similar to the merge() function, but instead of creating a new sorted range of elements, inplace_merge() alters the existing ranges to perform the merge in-place.
   function s__AIntegerContainer_inplace_merge takes integer this returns nothing
   endfunction

			/// @state untested
			/// iterator max_element( iterator start, iterator end );
			/// iterator max_element( iterator start, iterator end, BinPred p );
			/// Sucht mit Hilfe einer benutzerdefinierten Vergleichsfunktion nach dem größten Element in einem Elementebereich.
			/// Das Prädikat stellt in diesem Fall den <-Operator dar.
			/// @param start Startposition
			/// @param number Anzahl der Elemente
			/// @param binaryPredicate Benutzerdefinierte Vergleichsfunktion
			/// @return Index des größten Elements
   function s__AIntegerContainer_max_element takes integer this,integer start,integer number,integer binaryPredicate returns integer
    local integer i= start + 1
    local integer exitValue= start + number
    local integer result= start
     call s__AIntegerContainer_debugCheckStartAndNumber(this,start , number)
				loop
					exitwhen ( i == exitValue )
						//x < y
						if ( sc___prototype826_evaluate(binaryPredicate,s___AIntegerContainer_element[s__AIntegerContainer_element[this]+result] , s___AIntegerContainer_element[s__AIntegerContainer_element[this]+i]) ) then
							set result = i
						endif
					set i = i + 1
				endloop
				return result
   endfunction

			//iterator min_element( iterator start, iterator end );
			//iterator min_element( iterator start, iterator end, BinPred p );
			/// Sucht mit Hilfe einer benutzerdefinierten Vergleichsfunktion nach dem kleinsten Element in einem Elementebereich.
			/// Das Prädikat stellt in diesem Fall den <-Operator dar.
			/// @param start Startposition
			/// @param number Anzahl der Elemente
			/// @param binaryPredicate Benutzerdefinierte Vergleichsfunktion
			/// @return Index des kleinsten Elements
   function s__AIntegerContainer_min_element takes integer this,integer start,integer number,integer binaryPredicate returns integer
    local integer i= start + 1
    local integer exitValue= start + number
    local integer result= start
     call s__AIntegerContainer_debugCheckStartAndNumber(this,start , number)
				loop
					exitwhen ( i == exitValue )
						//x < y
						if ( sc___prototype826_evaluate(binaryPredicate,s___AIntegerContainer_element[s__AIntegerContainer_element[this]+i] , s___AIntegerContainer_element[s__AIntegerContainer_element[this]+result]) ) then
							set result = i
						endif
					set i = i + 1
				endloop
				return result
   endfunction

			/// Mit dem []-Operator kann man auf ein Element des Containers zugreifen.
			/// @param index Index des Elements
			/// @return Das Element
   function s__AIntegerContainer__getindex takes integer this,integer index returns integer
				return s__AIntegerContainer_getElement(this,index)
   endfunction

			/// Mit dem []=-Operator kann man einem Element des Containers einen Wert zuweisen.
			/// @param index Index des Elements
			/// @param value Zuzuweisender Wert
   function s__AIntegerContainer__setindex takes integer this,integer index,integer value returns nothing
				call s__AIntegerContainer_setElement(this,index , value)
   endfunction

			/// Mit dem <-Operator kann man prüfen, ob der Container eine kleinere Größe als ein anderer hat.
			/// @param destination Vergleichs-Container
			/// @return Gibt wahr zurück, wenn der Container eine kleinere Größe als der Ziel-Container hat.
   function s__AIntegerContainer__lessthan takes integer this,integer destination returns boolean
				return s___AIntegerContainer_element_size < s___AIntegerContainer_element_size
   endfunction

			// Mit dem >-Operator kann man prüfen, ob der Container eine größere Größe als ein anderer hat.
			// @param destination Vergleichs-Container
			// @return Gibt wahr zurück, wenn der Container eine kleinere Größe als der Ziel-Container hat.
			//public method operator> takes AIntegerContainer destination returns boolean
				//return this.size > destionation.size
			//endmethod

		//Basic algorithm

		//The binary predicate represents the < operator.
		//function AMax takes integer x, integer y, AIntegerContainerBinaryPredicate binaryPredicate returns $ELEMENTTYPE
		//	if (binaryPredicate.evaluate(x, y)) then
		//		return y
		//	endif
		//	return x
		//endfunction

		//function AMin takes integer x, integer y, AIntegerContainerBinaryPredicate binaryPredicate returns $ELEMENTTYPE
		//	if (binaryPredicate.evaluate(x, y)) then
		//		return x
		//	endif
		//	return y
		//endfunction
//end of: A_CONTAINER("integer", "Integer", "1000")

 function ALibraryCoreDebugContainer___Compare takes integer element,integer comparedElement returns boolean
		return ( element < comparedElement )
	endfunction

 function ALibraryCoreDebugContainer___Show takes integer element returns nothing
		call Print("Show " + I2S(element))
	endfunction

 function ALibraryCoreDebugContainer___SearchForTen takes integer element returns boolean
		return ( element == 10 )
	endfunction

 function ALibraryCoreDebugContainer___Operation takes integer element0,integer element1 returns integer
		return element0 + element1
	endfunction

 function ALibraryCoreDebugContainer___SearchForBiggerElement takes integer element0,integer element1 returns boolean
		return ( element0 == element1 )
	endfunction

	/// @todo Add tests for all container methods.
 function GetContainerDebug takes nothing returns nothing
  local integer i
  local integer Container1= s__AIntegerContainer__allocate()
  local integer Container2= s__AIntegerContainer__allocate()
  local integer Container3= s__AIntegerContainer__allocate() //overloading
		//Operator overloading - Works
   call Print("operator overloading")
		set i = 0
		loop
			exitwhen ( i == s__AIntegerContainer_getSize(Container1) )
			call s__AIntegerContainer__setindex(Container1,i, GetRandomInt(0 , 1000))
			set i = ( i + 1 )
		endloop
		call s__AIntegerContainer_forEach(Container1,0 , s__AIntegerContainer_getSize(Container1) , (1))
		//sort - Works
		call Print("sort")
		call s__AIntegerContainer_sort(Container1,0 , s__AIntegerContainer_getSize(Container1) , (1))
		call s__AIntegerContainer_forEach(Container1,0 , s__AIntegerContainer_getSize(Container1) , (1))
		//fill - Works
		call Print("fill")
		call s__AIntegerContainer_fill(Container2,0 , s__AIntegerContainer_getSize(Container2) , 100)
		call s__AIntegerContainer_forEach(Container2,0 , s__AIntegerContainer_getSize(Container2) , (1))
		//reverse - Works
		call Print("reverse")
		call s__AIntegerContainer_reverse(Container1,5 , ( s__AIntegerContainer_getSize(Container1) - 5 ))
		call s__AIntegerContainer_forEach(Container1,5 , ( s__AIntegerContainer_getSize(Container1) - 5 ) , (1))
		//find - Works
		call Print("find")
		call s__AIntegerContainer__setindex(Container1,0, 10)
		if ( s__AIntegerContainer_find(Container1,0 , s__AIntegerContainer_getSize(Container1) , 10) != - 1 ) then
			call Print("find does work")
		endif
		//find_if - Works
		call Print("find_if")
		call s__AIntegerContainer__setindex(Container2,0, 10)
		if ( s__AIntegerContainer_findIf(Container2,0 , s__AIntegerContainer_getSize(Container2) , (1)) != - 1 ) then
			call Print("findIf does work.")
		endif
		//equal - Works
		call Print("equal")
		call s__AIntegerContainer_fill(Container1,0 , s__AIntegerContainer_getSize(Container1) , 10)
		call s__AIntegerContainer_fill(Container2,0 , s__AIntegerContainer_getSize(Container1) , 10) //Using the size of container1
		if ( s__AIntegerContainer_equal(Container1,0 , s__AIntegerContainer_getSize(Container1) , 0 , Container2) ) then
			call Print("equal does work.")
		endif
		//copy - Works
		call Print("copy")
		call s__AIntegerContainer_fill(Container2,0 , s__AIntegerContainer_getSize(Container2) , 20)
		call s__AIntegerContainer_copy(Container2,0 , s__AIntegerContainer_getSize(Container1) , 0 , Container1)
		call s__AIntegerContainer_forEach(Container1,0 , s__AIntegerContainer_getSize(Container1) , (1))
		//fill number test - Works
		call Print("fill number test")
		call s__AIntegerContainer_fill(Container2,4 , ( s__AIntegerContainer_getSize(Container2) - 4 ) , 120)
		call s__AIntegerContainer_forEach(Container2,4 , ( s__AIntegerContainer_getSize(Container2) - 4 ) , (1))
		//operation - Untested
		call Print("operation")
		call Print("Result: " + I2S(s__AIntegerContainer_operation(Container2,0 , s__AIntegerContainer_getSize(Container2) , 10 , (1))) + ".")
		//adjacent find - Untested
		call Print("adjacent find")
		call s__AIntegerContainer__setindex(Container2,0, 10)
		call s__AIntegerContainer__setindex(Container2,1, 10)
		call Print("Result: " + I2S(s__AIntegerContainer_adjacentFind(Container2,0 , s__AIntegerContainer_getSize(Container2))) + ".")
		//adjacent find if - Untested
		call Print("adjacent find if")
		call Print("Result: " + I2S(s__AIntegerContainer_adjacentFindIf(Container2,0 , s__AIntegerContainer_getSize(Container2) , (2))) + ".")
	endfunction


//library ALibraryCoreDebugContainer ends
//library ALibraryCoreInterfaceMisc:


 function TriggerRegisterKeyEventForPlayer takes player user,trigger usedTrigger,integer key,boolean press returns event
		if ( key == KEY_ESCAPE ) then
			return TriggerRegisterPlayerEvent(usedTrigger , user , EVENT_PLAYER_END_CINEMATIC)
		elseif ( key == KEY_UP ) then
			if ( press ) then
				return TriggerRegisterPlayerEvent(usedTrigger , user , EVENT_PLAYER_ARROW_UP_DOWN)
			else
				return TriggerRegisterPlayerEvent(usedTrigger , user , EVENT_PLAYER_ARROW_UP_UP)
			endif
		elseif ( key == KEY_DOWN ) then
			if ( press ) then
				return TriggerRegisterPlayerEvent(usedTrigger , user , EVENT_PLAYER_ARROW_DOWN_DOWN)
			else
				return TriggerRegisterPlayerEvent(usedTrigger , user , EVENT_PLAYER_ARROW_DOWN_UP)
			endif
		elseif ( key == KEY_RIGHT ) then
			if ( press ) then
				return TriggerRegisterPlayerEvent(usedTrigger , user , EVENT_PLAYER_ARROW_RIGHT_DOWN)
			else
				return TriggerRegisterPlayerEvent(usedTrigger , user , EVENT_PLAYER_ARROW_RIGHT_UP)
			endif
		elseif ( key == KEY_LEFT ) then
			if ( press ) then
				return TriggerRegisterPlayerEvent(usedTrigger , user , EVENT_PLAYER_ARROW_LEFT_DOWN)
			else
				return TriggerRegisterPlayerEvent(usedTrigger , user , EVENT_PLAYER_ARROW_LEFT_UP)
			endif
		endif
		return null
	endfunction

 function GetModifiedPlayerName takes player user returns string
  local playercolor playerColor= GetPlayerColor(user)
  local string modifiedPlayerName= ( PlayerColorToString(playerColor) + GetPlayerName(user) + " |c00ffffff[" + I2S(GetPlayerId(user) + 1) + "]|r" ) //ALibraryStringConversion
		set playerColor = null
		return modifiedPlayerName
	endfunction

 function GetBar takes real value,real maxValue,integer length,string colour returns string
  local integer i
  local integer colouredPart= 0
  local string result= ""
		if ( maxValue != 0.0 ) then
			set colouredPart = R2I(( value / maxValue ) * I2R(length))
			//coloured part exists
			if ( colouredPart > 0.0 ) then
				set result = ( "|c00" + colour )
			endif
			//set bar
			set i = 0
			loop
			exitwhen ( i == length )
				set result = ( result + "|" )
				//set end of coloured part
				if ( ( i == colouredPart ) and ( colouredPart > 0.0 ) and ( colouredPart != length ) ) then
					set result = ( result + "I|c00ffffff" ) //I ist ein notwendiges Trennzeichen   
				endif
			set i = ( i + 1 )
			endloop
		endif
		return result
	endfunction

	/// @state untested
 function SetUnitVertexColourForPlayer takes player user,unit usedUnit,real red,real green,real blue,real transparency returns nothing
  local player localPlayer= GetLocalPlayer()
		if ( user == localPlayer ) then
			call SetUnitVertexColorBJ(usedUnit , red , green , blue , transparency)
		endif
		set localPlayer = null
	endfunction


//library ALibraryCoreInterfaceMisc ends
//library AStructCoreDebugCheat:

	/// @todo Should be a part of @struct ACheat, vJass bug.
//processed: 	function interface ACheatOnCheatAction takes nothing returns nothing

		//start members
		//members
		
//textmacro instance: A_STRUCT_DEBUG("\"ACheat\"") //ALibraryGeneralDebug
   function s__ACheat_print takes integer this,string message returns nothing
    call Print("ACheat" + " - " + I2S(this) + ": " + message)
   endfunction

   function s__ACheat_staticPrint takes string message returns nothing
    call Print("ACheat" + ": " + message)
   endfunction
//end of: A_STRUCT_DEBUG("\"ACheat\"") //ALibraryGeneralDebug
		
  function s__ACheat_triggerActionCheat takes nothing returns nothing
   local trigger triggeringTrigger= GetTriggeringTrigger()
   local integer this= s__AHashTable_getHandleInteger(AGetDebugHashTable(),triggeringTrigger , "this") //AStructCoreDebugDebugHashTable
			call sc___prototype765_execute(s__ACheat_m_action[this])
			set triggeringTrigger = null
  endfunction
		
  function s__ACheat_createCheatTrigger takes integer this returns nothing
   local integer i
   local player user
   local event triggerEvent
   local triggeraction triggerAction
			set s__ACheat_cheatTrigger[this]=CreateTrigger()
			set i = 0
			loop
					exitwhen ( i == bj_MAX_PLAYERS )
					set user = Player(i)
					if ( IsPlayerPlayingUser(user) ) then //ALibraryCoreGeneralPlayer
						set triggerEvent = TriggerRegisterPlayerChatEvent(s__ACheat_cheatTrigger[this] , user , s__ACheat_m_cheat[this] , true)
					endif
					set user = null
					set i = i + 1
			endloop
			set triggerAction = TriggerAddAction(s__ACheat_cheatTrigger[this] , function s__ACheat_triggerActionCheat)
			set triggerAction = null
			call s__AHashTable_storeHandleInteger(AGetDebugHashTable(),s__ACheat_cheatTrigger[this] , "this" , this) //AStructCoreDebugDebugHashTable
  endfunction
		
  function s__ACheat_create takes string cheat,integer action returns integer
   local integer this= s__ACheat__allocate()
    if ( cheat == null ) then
     call s__ACheat_print(this,"cheat is empty.")
    endif
    if ( action == 0 ) then
     call s__ACheat_print(this,"action is 0.")
    endif
			//start members
			set s__ACheat_m_cheat[this]=cheat
			set s__ACheat_m_action[this]=action
			
			call s__ACheat_createCheatTrigger(this)
			return this
  endfunction
		
  function s__ACheat_onDestroy takes integer this returns nothing
			call s__AHashTable_destroyTrigger(AGetDebugHashTable(),s__ACheat_cheatTrigger[this]) //AStructCoreDebugDebugHashTable
			set s__ACheat_cheatTrigger[this]=null
  endfunction

//Generated destructor of ACheat
function s__ACheat_destroy takes integer this returns nothing
    if this==null then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: ACheat")
        return
    elseif (si__ACheat_V[this]!=-1) then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: ACheat")
        return
    endif
    call s__ACheat_onDestroy(this)
    set si__ACheat_V[this]=si__ACheat_F
    set si__ACheat_F=this
endfunction


//library AStructCoreDebugCheat ends
//library AStructCoreInterfaceIndicator:

		//static constant members
		//dynamic members
		//members

		//dynamic member methods

  function s__AIndicator_setObject takes integer this,handle object returns nothing
			set s__AIndicator_object[this]=object
  endfunction

  function s__AIndicator_getObject takes integer this returns handle
			return s__AIndicator_object[this]
  endfunction

  function s__AIndicator_setObjectType takes integer this,integer objectType returns nothing
			set s__AIndicator_objectType[this]=objectType
  endfunction

  function s__AIndicator_getObjectType takes integer this returns integer
			return s__AIndicator_objectType[this]
  endfunction

  function s__AIndicator_setRate takes integer this,real rate returns nothing
			set s__AIndicator_rate[this]=rate
  endfunction

  function s__AIndicator_getRate takes integer this returns real
			return s__AIndicator_rate[this]
  endfunction

  function s__AIndicator_setTime takes integer this,real time returns nothing
			set s__AIndicator_time[this]=time
  endfunction

  function s__AIndicator_getTime takes integer this returns real
			return s__AIndicator_time[this]
  endfunction

  function s__AIndicator_setRed takes integer this,real red returns nothing
			set s__AIndicator_red[this]=red
  endfunction

  function s__AIndicator_getRed takes integer this returns real
			return s__AIndicator_red[this]
  endfunction

  function s__AIndicator_setGreen takes integer this,real green returns nothing
			set s__AIndicator_green[this]=green
  endfunction

  function s__AIndicator_getGreen takes integer this returns real
			return s__AIndicator_green[this]
  endfunction

  function s__AIndicator_setBlue takes integer this,real blue returns nothing
			set s__AIndicator_blue[this]=blue
  endfunction

  function s__AIndicator_getBlue takes integer this returns real
			return s__AIndicator_blue[this]
  endfunction

  function s__AIndicator_setTransparency takes integer this,real transparency returns nothing
			set s__AIndicator_transparency[this]=transparency
  endfunction

  function s__AIndicator_getTransparency takes integer this returns real
			return s__AIndicator_transparency[this]
  endfunction

		//public methods

		/// Flash restarts when enabling the indicator.
  function s__AIndicator_enable takes integer this,boolean enable returns nothing
			set s__AIndicator_elapsedTime[this]=0.0
			call EnableTrigger(s__AIndicator_refreshTrigger[this])
  endfunction

  function s__AIndicator_disable takes integer this returns nothing
			call DisableTrigger(s__AIndicator_refreshTrigger[this])
			call sc__AIndicator_reset(this)
  endfunction

		//private methods

  function s__AIndicator_indicateImage takes integer this returns nothing
			call SetImageColorBJ(I2Image(H2I(s__AIndicator_object[this])) , s__AIndicator_red[this] , s__AIndicator_green[this] , s__AIndicator_blue[this] , s__AIndicator_transparency[this]) //ALibraryGeneralConversion
			call TriggerSleepAction(s__AIndicator_rate[this] / 2.0)
			call SetImageColorBJ(I2Image(H2I(s__AIndicator_object[this])) , 100.0 , 100.0 , 100.0 , 0.0) //ALibraryGeneralConversion
  endfunction

  function s__AIndicator_indicateTextTag takes integer this returns nothing
			call SetTextTagColorBJ(I2TextTag(H2I(s__AIndicator_object[this])) , s__AIndicator_red[this] , s__AIndicator_green[this] , s__AIndicator_blue[this] , s__AIndicator_transparency[this]) //ALibraryGeneralConversion
			call TriggerSleepAction(s__AIndicator_rate[this] / 2.00)
			call SetTextTagColorBJ(I2TextTag(H2I(s__AIndicator_object[this])) , 100.0 , 100.0 , 100.0 , 0.0) //ALibraryGeneralConversion
  endfunction

  function s__AIndicator_indicateUnit takes integer this returns nothing
			call SetUnitVertexColorBJ(I2Unit(H2I(s__AIndicator_object[this])) , s__AIndicator_red[this] , s__AIndicator_green[this] , s__AIndicator_blue[this] , s__AIndicator_transparency[this]) //ALibraryGeneralConversion
			call TriggerSleepAction(s__AIndicator_rate[this] / 2.00)
			call SetUnitVertexColorBJ(I2Unit(H2I(s__AIndicator_object[this])) , 100.0 , 100.0 , 100.0 , 0.0) //ALibraryGeneralConversion
  endfunction

  function s__AIndicator_indicateObject takes integer this returns nothing
			if ( s__AIndicator_objectType[this] == s__AIndicator_objectTypeImage ) then
				call s__AIndicator_indicateImage(this)
			elseif ( s__AIndicator_objectType[this] == s__AIndicator_objectTypeTextTag ) then
				call s__AIndicator_indicateTextTag(this)
			else
				call s__AIndicator_indicateUnit(this)
			endif
  endfunction

  function s__AIndicator_inrcreaseElapsedTime takes integer this returns nothing
			set s__AIndicator_elapsedTime[this]=( s__AIndicator_elapsedTime[this] + s__AIndicator_rate[this] )
			if ( s__AIndicator_elapsedTime[this] >= s__AIndicator_time[this] ) then
				call s__AIndicator_enable(this,false)
			endif
  endfunction

  function s__AIndicator_triggerActionIndicateObject takes nothing returns nothing
   local trigger triggeringTrigger= GetTriggeringTrigger()
   local integer indicator= s__AHashTable_getHandleInteger(AGetInterfaceHashTable(),triggeringTrigger , "indicator") //AClassInterfaceInterfaceHashTable
			if ( s__AIndicator_object[indicator] != null ) then
				call s__AIndicator_indicateObject(indicator)
				call s__AIndicator_inrcreaseElapsedTime(indicator)
			else
				call s__AIndicator_enable(indicator,false)
			endif
        		set triggeringTrigger = null
  endfunction

  function s__AIndicator_reset takes integer this returns nothing
			if ( s__AIndicator_objectType[this] == s__AIndicator_objectTypeImage ) then
				call SetImageColorBJ(I2Image(H2I(s__AIndicator_object[this])) , 100.0 , 100.0 , 100.0 , 0.0) //ALibraryGeneralConversion
			elseif ( s__AIndicator_objectType[this] == s__AIndicator_objectTypeTextTag ) then
				call SetTextTagColorBJ(I2TextTag(H2I(s__AIndicator_object[this])) , 100.0 , 100.0 , 100.0 , 0.0) //ALibraryGeneralConversion
			elseif ( s__AIndicator_objectType[this] == s__AIndicator_objectTypeUnit ) then
				call SetUnitVertexColorBJ(I2Unit(H2I(s__AIndicator_object[this])) , 100.0 , 100.0 , 100.0 , 0.0) //ALibraryGeneralConversion
			endif
  endfunction

  function s__AIndicator_createRefreshTrigger takes integer this returns nothing
   local event triggerEvent
              local triggeraction triggerAction
			set s__AIndicator_refreshTrigger[this]=CreateTrigger()
			set triggerEvent = TriggerRegisterTimerEvent(s__AIndicator_refreshTrigger[this] , s__AIndicator_rate[this] , true)
			set triggerAction = TriggerAddAction(s__AIndicator_refreshTrigger[this] , function s__AIndicator_triggerActionIndicateObject)
			call s__AHashTable_storeHandleInteger(AGetInterfaceHashTable(),s__AIndicator_refreshTrigger[this] , "indicator" , this) //AClassInterfaceInterfaceHashTable
			set triggerEvent = null
			set triggerAction = null
  endfunction

  function s__AIndicator_create takes handle object,integer objectType,real rate,real time,real red,real green,real blue,real transparency returns integer
   local integer this= s__AIndicator__allocate()
			//dynamic members
			set s__AIndicator_object[this]=object
			set s__AIndicator_objectType[this]=objectType
			set s__AIndicator_rate[this]=rate
			set s__AIndicator_time[this]=time
			set s__AIndicator_red[this]=red
			set s__AIndicator_green[this]=green
			set s__AIndicator_blue[this]=blue
			set s__AIndicator_transparency[this]=transparency
			//members
			set s__AIndicator_elapsedTime[this]=0.00
			set s__AIndicator_firstTime[this]=true

			call s__AIndicator_createRefreshTrigger(this)
			return this
  endfunction

  function s__AIndicator_destroyRefreshTrigger takes integer this returns nothing
			call s__AHashTable_destroyTrigger(AGetInterfaceHashTable(),s__AIndicator_refreshTrigger[this]) //AClassInterfaceInterfaceHashTable
			set s__AIndicator_refreshTrigger[this]=null
  endfunction

  function s__AIndicator_onDestroy takes integer this returns nothing
			//dynamic members
			set s__AIndicator_object[this]=null

			call s__AIndicator_destroyRefreshTrigger(this)
  endfunction

//Generated destructor of AIndicator
function s__AIndicator_destroy takes integer this returns nothing
    if this==null then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: AIndicator")
        return
    elseif (si__AIndicator_V[this]!=-1) then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: AIndicator")
        return
    endif
    call s__AIndicator_onDestroy(this)
    set si__AIndicator_V[this]=si__AIndicator_F
    set si__AIndicator_F=this
endfunction


//library AStructCoreInterfaceIndicator ends
//library AStructCoreInterfaceMultiboardBar:

	/// @todo vJass bug, should be a part of @struct AMultiboardBar.
	/// This represents the function which controls both MultiboardBar values:
	/// Value and maximum value.
//processed: 	function interface AMultiboardBarValueFunction takes AMultiboardBar multiboardBar returns real

		//static constant members
		//start members
		//dynamic members
		//members

		//dynamic member methods

  function s__AMultiboardBar_setValue takes integer this,real value returns nothing
			set s__AMultiboardBar_value[this]=value
  endfunction

  function s__AMultiboardBar_getValue takes integer this returns real
			return s__AMultiboardBar_value[this]
  endfunction

  function s__AMultiboardBar_setMaxValue takes integer this,real maxValue returns nothing
			set s__AMultiboardBar_maxValue[this]=maxValue
  endfunction

  function s__AMultiboardBar_getMaxValue takes integer this returns real
			return s__AMultiboardBar_maxValue[this]
  endfunction

  function s__AMultiboardBar_setValueIcon takes integer this,integer length,string valueIcon returns nothing
			set s___AMultiboardBar_valueIcon[s__AMultiboardBar_valueIcon[this]+length]=valueIcon
  endfunction

  function s__AMultiboardBar_getValueIcon takes integer this,integer length returns string
			return s___AMultiboardBar_valueIcon[s__AMultiboardBar_valueIcon[this]+length]
  endfunction

  function s__AMultiboardBar_setEmptyIcon takes integer this,integer length,string emptyIcon returns nothing
			set s___AMultiboardBar_emptyIcon[s__AMultiboardBar_emptyIcon[this]+length]=emptyIcon
  endfunction

  function s__AMultiboardBar_getEmptyIcon takes integer this,integer length returns string
			return s___AMultiboardBar_emptyIcon[s__AMultiboardBar_emptyIcon[this]+length]
  endfunction

		/// Sets the function which should return the value of the multiboard bar when it refreshs.
  function s__AMultiboardBar_setValueFunction takes integer this,integer valueFunction returns nothing
			set s__AMultiboardBar_valueFunction[this]=valueFunction
  endfunction

  function s__AMultiboardBar_getValueFunction takes integer this returns integer
			return s__AMultiboardBar_valueFunction[this]
  endfunction

  function s__AMultiboardBar_setMaxValueFunction takes integer this,integer maxValueFunction returns nothing
			set s__AMultiboardBar_maxValueFunction[this]=maxValueFunction
  endfunction

  function s__AMultiboardBar_getMaxValueFunction takes integer this returns integer
			return s__AMultiboardBar_maxValueFunction[this]
  endfunction

		//methods
		
		/// Die Farbe des Feldes mit Wert wird je nach Anteil des Wertes vom Maximalwert gesetzt.
  function s__AMultiboardBar_refresh takes integer this returns nothing
   local integer i
   local multiboarditem multiboardItem
			set s__AMultiboardBar_colouredPart[this]=R2I(( s__AMultiboardBar_value[this] / s__AMultiboardBar_maxValue[this] ) * I2R(s__AMultiboardBar_length[this]))
			set i = 0
			loop
                		exitwhen ( i == s__AMultiboardBar_length[this] )
				if ( s__AMultiboardBar_horizontal[this] ) then
					set multiboardItem = MultiboardGetItem(s__AMultiboardBar_usedMultiboard[this] , s__AMultiboardBar_row[this] , s__AMultiboardBar_column[this] + i)
				else
					set multiboardItem = MultiboardGetItem(s__AMultiboardBar_usedMultiboard[this] , s__AMultiboardBar_row[this] + i , s__AMultiboardBar_column[this])
				endif
				//coloured part
				if ( i < s__AMultiboardBar_colouredPart[this] ) then
					call MultiboardSetItemIcon(multiboardItem , s___AMultiboardBar_valueIcon[s__AMultiboardBar_valueIcon[this]+i])
				//plain Part
				else
					call MultiboardSetItemIcon(multiboardItem , s___AMultiboardBar_emptyIcon[s__AMultiboardBar_emptyIcon[this]+i])
				endif
				call MultiboardReleaseItem(multiboardItem) //TEST
				set multiboardItem = null
				set i = i + 1
			endloop
  endfunction

		/// First call after setting the length.
  function s__AMultiboardBar_setIcons takes integer this,integer start,integer end,string icon,boolean valueIcon returns nothing
   local integer i
    if ( ( start >= 0 ) and ( start < s__AMultiboardBar_length[this] ) ) then
     if ( ( end > 0 ) and ( end < s__AMultiboardBar_length[this] ) ) then
					set i = start
					loop
						exitwhen ( i == ( end + 1 ) )
						if ( valueIcon ) then
							set s___AMultiboardBar_valueIcon[s__AMultiboardBar_valueIcon[this]+i]=icon
						else
							set s___AMultiboardBar_emptyIcon[s__AMultiboardBar_emptyIcon[this]+i]=icon
						endif
						set i = ( i + 1 )
					endloop
     else
      call Print("The value 'End' has an invalid size.") //ALibraryGeneralDebug
     endif
    else
     call Print("The value 'Start' has an invalid size.") //ALibraryGeneralDebug
    endif
  endfunction
		
		//comfort methods

		/// Erst aufrufen, nachdem man die Länge gesetzt hat.
  function s__AMultiboardBar_setAllIcons takes integer this,string icon,boolean valueIcon returns nothing
			call s__AMultiboardBar_setIcons(this,0 , ( s__AMultiboardBar_length[this] - 1 ) , icon , valueIcon)
  endfunction
		
		/// @return The index of the first field (column or row) which is not used by the bar (alignment is left to right and up to bottom).
  function s__AMultiboardBar_getFirstFreeField takes integer this returns integer
			if ( s__AMultiboardBar_horizontal[this] ) then
				return s__AMultiboardBar_column[this] + s__AMultiboardBar_length[this]
			endif
			return s__AMultiboardBar_row[this] + s__AMultiboardBar_length[this]
  endfunction

  function s__AMultiboardBar_resizeMultiboard takes integer this returns nothing
			if ( s__AMultiboardBar_horizontal[this] ) then
				if ( MultiboardGetColumnCount(s__AMultiboardBar_usedMultiboard[this]) < ( s__AMultiboardBar_column[this] + s__AMultiboardBar_length[this] ) ) then
					call MultiboardSetColumnCount(s__AMultiboardBar_usedMultiboard[this] , ( s__AMultiboardBar_column[this] + s__AMultiboardBar_length[this] ))
				endif
				if ( MultiboardGetRowCount(s__AMultiboardBar_usedMultiboard[this]) <= s__AMultiboardBar_row[this] ) then
					call MultiboardSetRowCount(s__AMultiboardBar_usedMultiboard[this] , ( s__AMultiboardBar_row[this] + 1 ))
				endif
			else
				if ( MultiboardGetColumnCount(s__AMultiboardBar_usedMultiboard[this]) <= s__AMultiboardBar_column[this] ) then
					call MultiboardSetColumnCount(s__AMultiboardBar_usedMultiboard[this] , ( s__AMultiboardBar_column[this] + 1 ))
				endif
				if ( MultiboardGetRowCount(s__AMultiboardBar_usedMultiboard[this]) < ( s__AMultiboardBar_row[this] + s__AMultiboardBar_length[this] ) ) then
					call MultiboardSetRowCount(s__AMultiboardBar_usedMultiboard[this] , ( s__AMultiboardBar_row[this] + s__AMultiboardBar_length[this] ))
				endif
			endif
  endfunction

  function s__AMultiboardBar_setupMultiboardItems takes integer this returns nothing
   local integer i
   local multiboarditem multiboardItem
			set i = 0
			loop
				exitwhen ( i == s__AMultiboardBar_length[this] )
				if ( s__AMultiboardBar_horizontal[this] ) then
					set multiboardItem = MultiboardGetItem(s__AMultiboardBar_usedMultiboard[this] , s__AMultiboardBar_row[this] , s__AMultiboardBar_column[this] + i)
				else
					set multiboardItem = MultiboardGetItem(s__AMultiboardBar_usedMultiboard[this] , s__AMultiboardBar_row[this] + i , s__AMultiboardBar_column[this])
				endif
				call MultiboardSetItemStyle(multiboardItem , false , true)
				call MultiboardSetItemWidth(multiboardItem , 0.01) //Einzeln einstellen, um nicht das ganze Multiboard zu verndern
				call MultiboardReleaseItem(multiboardItem)
				set multiboardItem = null
				set i = i + 1
			endloop
  endfunction

  function s__AMultiboardBar_triggerActionRefresh takes nothing returns nothing
   local trigger triggeringTrigger= GetTriggeringTrigger()
   local integer multiboardBar= s__AHashTable_getHandleInteger(AGetInterfaceHashTable(),triggeringTrigger , "multiboardBar") //AClassInterfaceInterfaceHashTable
			set s__AMultiboardBar_value[multiboardBar]=sc___prototype830_evaluate(s__AMultiboardBar_valueFunction[multiboardBar],multiboardBar) //Man braucht evaluate, da die Funktion einen Wert zurckliefert.
			set s__AMultiboardBar_maxValue[multiboardBar]=sc___prototype830_evaluate(s__AMultiboardBar_maxValueFunction[multiboardBar],multiboardBar)
			call s__AMultiboardBar_refresh(multiboardBar) //Das false ist egal, da Horizontal nur beim ersten Erschaffen gesetzt wird
			set triggeringTrigger = null
  endfunction

  function s__AMultiboardBar_createRefreshTrigger takes integer this returns nothing
   local event triggerEvent
   local triggeraction triggerAction
			if ( s__AMultiboardBar_refreshRate[this] > 0.0 ) then
				set s__AMultiboardBar_refreshTrigger[this]=CreateTrigger()
				set triggerEvent = TriggerRegisterTimerEvent(s__AMultiboardBar_refreshTrigger[this] , s__AMultiboardBar_refreshRate[this] , true)
				set triggerAction = TriggerAddAction(s__AMultiboardBar_refreshTrigger[this] , function s__AMultiboardBar_triggerActionRefresh)
				call s__AHashTable_storeHandleInteger(AGetInterfaceHashTable(),s__AMultiboardBar_refreshTrigger[this] , "multiboardBar" , this) //ALibraryInterfaceHashTable
				set triggerEvent = null
				set triggerAction = null
			endif
  endfunction
		
		/// If there aren't enough items in multiboard yet required onces will be added automatically.
		/// @param refreshRate If this value is bigger than 0 multiboard bar will be refreshed.
		/// @param horizontal This value is not dynamic.
  function s__AMultiboardBar_create takes multiboard usedMultiboard,integer column,integer row,integer length,real refreshRate,boolean horizontal,real value,real maxValue,integer valueFunction,integer maxValueFunction returns integer
   local integer this= s__AMultiboardBar__allocate()
			//start members
			set s__AMultiboardBar_usedMultiboard[this]=usedMultiboard
			set s__AMultiboardBar_column[this]=column
			set s__AMultiboardBar_row[this]=row
			set s__AMultiboardBar_length[this]=length
			set s__AMultiboardBar_refreshRate[this]=refreshRate
			set s__AMultiboardBar_horizontal[this]=horizontal
			//dynamic members
			set s__AMultiboardBar_value[this]=value
			set s__AMultiboardBar_maxValue[this]=maxValue
			set s__AMultiboardBar_valueFunction[this]=valueFunction
			set s__AMultiboardBar_maxValueFunction[this]=maxValueFunction
			//members
			set s__AMultiboardBar_colouredPart[this]=0

			call s__AMultiboardBar_resizeMultiboard(this)
			call s__AMultiboardBar_setupMultiboardItems(this)
			call s__AMultiboardBar_createRefreshTrigger(this)
			return this
  endfunction

  function s__AMultiboardBar_destroyRefreshTrigger takes integer this returns nothing
			if ( s__AMultiboardBar_refreshRate[this] > 0.0 ) then
				call s__AHashTable_destroyTrigger(AGetInterfaceHashTable(),s__AMultiboardBar_refreshTrigger[this]) //AClassInterfaceInterfaceHashTable
				set s__AMultiboardBar_refreshTrigger[this]=null
			endif
  endfunction

  function s__AMultiboardBar_onDestroy takes integer this returns nothing
			//start members
			set s__AMultiboardBar_usedMultiboard[this]=null

			call s__AMultiboardBar_destroyRefreshTrigger(this)
  endfunction

//Generated destructor of AMultiboardBar
function s__AMultiboardBar_destroy takes integer this returns nothing
    if this==null then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: AMultiboardBar")
        return
    elseif (si__AMultiboardBar_V[this]!=-1) then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: AMultiboardBar")
        return
    endif
    call s__AMultiboardBar_onDestroy(this)
    set si__AMultiboardBar_V[this]=si__AMultiboardBar_F
    set si__AMultiboardBar_F=this
endfunction


//library AStructCoreInterfaceMultiboardBar ends
//library AStructSystemsCharacterCharacter:

	/// This struct represents a single RPG character. Each player can own exactly one character.
	/// You can configure the character systems and enable or disable the several character system modules.
	/// Each module makes the system requiring more memory, so clearly think of which system modules are required and which aren't.
		//static constant members
		//static start members
		//static members
		//dynamic members
		//start members
		//members
		//insert the character systems here

		//dynamic members

		/// If the character is set unmovable he will be stopped immediatly and can not move until he will be set movable.
		/// This method is used for dialogs or cinematic sequences. It also disables all character systems.
  function s__ACharacter_setMovable takes integer this,boolean movable returns nothing
			//Don't make him movable if he is already!
			//If he talks with another NPC he is already unmovable.
    if ( s__ACharacter_movable[this] == movable ) then
     call Print("Character " + I2S(this) + ": setMovable() error.")
     return 
    endif
			set s__ACharacter_movable[this]=movable
			call PauseUnit(s__ACharacter_usedUnit[this] , not movable)
			call SetUnitInvulnerable(s__ACharacter_usedUnit[this] , not movable)
			if ( movable ) then
				//call this.enableSystems()
			else
				//call this.disableSystems()
			endif
  endfunction

  function s__ACharacter_getMovable takes integer this returns boolean
			return s__ACharacter_movable[this]
  endfunction

		/// Friend relation to AClassSelection, don't use.
  function s__ACharacter_setClass takes integer this,integer class returns nothing
			set s__ACharacter_class[this]=class
  endfunction

  function s__ACharacter_getClass takes integer this returns integer
			return s__ACharacter_class[this]
  endfunction

		/// Friend relation to ATalk, don't use.
  function s__ACharacter_setTalk takes integer this,integer talk returns nothing
			set s__ACharacter_talk[this]=talk
  endfunction

		/// Friend relation to ATalk, don't use.
  function s__ACharacter_getTalk takes integer this returns integer
			return s__ACharacter_talk[this]
  endfunction

		/// Friend relation to AShrine, don't use.
  function s__ACharacter_setShrine takes integer this,integer shrine returns nothing
			set s__ACharacter_shrine[this]=shrine
  endfunction

		/// Friend relation to AShrine, don't use.
  function s__ACharacter_getShrine takes integer this returns integer
			return s__ACharacter_shrine[this]
  endfunction

		//start members

  function s__ACharacter_getUser takes integer this returns player
			return s__ACharacter_user[this]
  endfunction

  function s__ACharacter_getUsedUnit takes integer this returns unit
			return s__ACharacter_usedUnit[this]
  endfunction

		//members

		/// Friend relation to AShrine.
		/// Use it to setup the time.
  function s__ACharacter_getRevival takes integer this returns integer
			return s__ACharacter_revival[this]
  endfunction
		
		//convenience methods

  function s__ACharacter_getName takes integer this returns string
			return GetPlayerName(s__ACharacter_user[this])
  endfunction

		/// Displays a message to the owner of the character.
		/// @todo Change this method.
		/// @param messageType The message type.
		/// @param message The message text.
  function s__ACharacter_displayMessage takes integer this,integer messageType,string message returns nothing
			call DisplayTimedTextToPlayer(s__ACharacter_user[this] , 0.0 , 0.0 , 6.0 , message)
  endfunction

		/// Displays a message to the owners of all other characters.
  function s__ACharacter_displayMessageToAllOthers takes integer this,integer messageType,string message returns nothing
   local integer i
   local player user
			set i = 0
			loop
				exitwhen ( i == bj_MAX_PLAYERS )
				set user = Player(i)
				if ( user != s__ACharacter_user[this] ) then
					call s__ACharacter_displayMessage(sc__ACharacter_getPlayerCharacter(user),messageType , message)
				endif
				set user = null
				set i = i + 1
			endloop
  endfunction

  function s__ACharacter_addLevels takes integer this,integer levels,boolean showEffect returns nothing
			call SetHeroLevel(s__ACharacter_usedUnit[this] , GetHeroLevel(s__ACharacter_usedUnit[this]) + levels , showEffect)
  endfunction

  function s__ACharacter_addSkillPoints takes integer this,integer skillPoints returns boolean
			return UnitModifySkillPoints(s__ACharacter_usedUnit[this] , skillPoints)
  endfunction

  function s__ACharacter_addExperience takes integer this,integer experience,boolean showEffect returns nothing
			call AddHeroXP(s__ACharacter_usedUnit[this] , experience , showEffect)
  endfunction

  function s__ACharacter_addStrength takes integer this,integer strength returns nothing
			call SetHeroStr(s__ACharacter_usedUnit[this] , GetHeroStr(s__ACharacter_usedUnit[this] , false) + strength , true)
  endfunction

  function s__ACharacter_addAgility takes integer this,integer agility returns nothing
			call SetHeroAgi(s__ACharacter_usedUnit[this] , GetHeroAgi(s__ACharacter_usedUnit[this] , false) + agility , true)
  endfunction

  function s__ACharacter_addIntelligence takes integer this,integer intelligence returns nothing
			call SetHeroInt(s__ACharacter_usedUnit[this] , GetHeroInt(s__ACharacter_usedUnit[this] , false) + intelligence , true)
  endfunction

  function s__ACharacter_addGold takes integer this,integer gold returns nothing
			call SetPlayerState(s__ACharacter_user[this] , PLAYER_STATE_RESOURCE_GOLD , GetPlayerState(s__ACharacter_user[this] , PLAYER_STATE_RESOURCE_GOLD) + gold)
  endfunction

  function s__ACharacter_addLumber takes integer this,integer lumber returns nothing
			call SetPlayerState(s__ACharacter_user[this] , PLAYER_STATE_RESOURCE_LUMBER , GetPlayerState(s__ACharacter_user[this] , PLAYER_STATE_RESOURCE_LUMBER) + lumber)
  endfunction
		
  function s__ACharacter_showCinematicFilter takes integer this,real duration,blendmode blendMode,string texture,real red0,real green0,real blue0,real transparency0,real red1,real green1,real blue1,real transparency1 returns nothing
			call ShowGenericCinematicFilterForPlayer(s__ACharacter_user[this] , duration , blendMode , texture , red0 , green0 , blue0 , transparency0 , red1 , green1 , blue1 , transparency1)
  endfunction

  function s__ACharacter_showBlackScreenCinematicFilter takes integer this,real duration returns nothing
			call ShowBlackScreenCinematicFilterForPlayer(s__ACharacter_user[this] , duration)
  endfunction
		
  function s__ACharacter_setX takes integer this,real x returns nothing
			call SetUnitX(s__ACharacter_usedUnit[this] , x)
  endfunction
		
  function s__ACharacter_setY takes integer this,real y returns nothing
			call SetUnitY(s__ACharacter_usedUnit[this] , y)
  endfunction
		
  function s__ACharacter_setRect takes integer this,rect usedRect returns nothing
			call s__ACharacter_setX(this,GetRectCenterX(usedRect))
			call s__ACharacter_setY(this,GetRectCenterY(usedRect))
  endfunction

		//methods

  function s__ACharacter_enableSystems takes integer this returns nothing
			if ( s__ACharacter_useViewSystem ) then
				call sc__AView_enable(s__ACharacter_view[this])
			endif
			if ( s__ACharacter_useFocusSystem ) then
				call sc__AFocus_enable(s__ACharacter_focus[this])
			endif
			if ( s__ACharacter_useMovementSystem ) then
				call sc__AMovement_enable(s__ACharacter_movement[this])
			endif
			if ( s__ACharacter_useFightSystem ) then
				call sc__AFight_enable(s__ACharacter_fight[this])
			endif
			if ( s__ACharacter_useRevivalSystem ) then
				call sc__ARevival_enable(s__ACharacter_revival[this])
			endif
			if ( s__ACharacter_useInventorySystem ) then
				call sc__AInventory_enable(s__ACharacter_inventory[this])
			endif
  endfunction

  function s__ACharacter_disableSystems takes integer this returns nothing
			if ( s__ACharacter_useViewSystem ) then
				call sc__AView_disable(s__ACharacter_view[this])
			endif
			if ( s__ACharacter_useFocusSystem ) then
				call sc__AFocus_disable(s__ACharacter_focus[this])
			endif
			if ( s__ACharacter_useMovementSystem ) then
				call sc__AMovement_disable(s__ACharacter_movement[this])
			endif
			if ( s__ACharacter_useFightSystem ) then
				call sc__AFight_disable(s__ACharacter_fight[this])
			endif
			if ( s__ACharacter_useRevivalSystem ) then
				call sc__ARevival_disable(s__ACharacter_revival[this])
			endif
			if ( s__ACharacter_useInventorySystem ) then
				call sc__AInventory_disable(s__ACharacter_inventory[this])
			endif
  endfunction

  function s__ACharacter_triggerActionDestroyCharacter takes nothing returns nothing
   local trigger triggeringTrigger= GetTriggeringTrigger()
   local integer character= s__AHashTable_getHandleInteger(AGetCharacterHashTable(),triggeringTrigger , "character")
			call sc__ACharacter_destroy(character)
			set triggeringTrigger = null
  endfunction

  function s__ACharacter_triggerActionSetUnmovable takes nothing returns nothing
   local trigger triggeringTrigger= GetTriggeringTrigger()
   local integer character= s__AHashTable_getHandleInteger(AGetCharacterHashTable(),triggeringTrigger , "character")
			call s__ACharacter_setMovable(character,false)
			set triggeringTrigger = null
  endfunction

  function s__ACharacter_createLeaveTrigger takes integer this returns nothing
   local event triggerEvent
   local triggeraction triggerAction
			set s__ACharacter_leaveTrigger[this]=CreateTrigger()
			set triggerEvent = TriggerRegisterPlayerEvent(s__ACharacter_leaveTrigger[this] , s__ACharacter_user[this] , EVENT_PLAYER_LEAVE)
			if ( s__ACharacter_destroyOnPlayerLeaves ) then
				set triggerAction = TriggerAddAction(s__ACharacter_leaveTrigger[this] , function s__ACharacter_triggerActionDestroyCharacter)
			else
				set triggerAction = TriggerAddAction(s__ACharacter_leaveTrigger[this] , function s__ACharacter_triggerActionSetUnmovable)
			endif
			call s__AHashTable_storeHandleInteger(AGetCharacterHashTable(),s__ACharacter_leaveTrigger[this] , "character" , this)
			set triggerEvent = null
			set triggerAction = null
  endfunction

  function s__ACharacter_createDeathTrigger takes integer this returns nothing
   local event triggerEvent
   local triggeraction triggerAction
			set s__ACharacter_deathTrigger[this]=CreateTrigger()
			set triggerEvent = TriggerRegisterUnitEvent(s__ACharacter_deathTrigger[this] , s__ACharacter_usedUnit[this] , EVENT_UNIT_DEATH)
			if ( s__ACharacter_destroyOnDeath ) then
				set triggerAction = TriggerAddAction(s__ACharacter_deathTrigger[this] , function s__ACharacter_triggerActionDestroyCharacter)
			else
				set triggerAction = TriggerAddAction(s__ACharacter_deathTrigger[this] , function s__ACharacter_triggerActionSetUnmovable)
			endif
			call s__AHashTable_storeHandleInteger(AGetCharacterHashTable(),s__ACharacter_deathTrigger[this] , "character" , this) //AClassCharacterCharacterHashTable
			set triggerEvent = null
			set triggerAction = null
  endfunction

  function s__ACharacter_createSystems takes integer this returns nothing
			if ( s__ACharacter_useViewSystem ) then
				set s__ACharacter_view[this]=sc__AView_create(this)
			endif
			if ( s__ACharacter_useFocusSystem ) then
				set s__ACharacter_focus[this]=sc__AFocus_create(this)
			endif
			if ( s__ACharacter_useMovementSystem ) then
				set s__ACharacter_movement[this]=sc__AMovement_create(this)
			endif
			if ( s__ACharacter_useFightSystem ) then
				set s__ACharacter_fight[this]=sc__AFight_create(this)
			endif
			if ( s__ACharacter_useRevivalSystem ) then
				set s__ACharacter_revival[this]=sc__ARevival_create(this)
			endif
			if ( s__ACharacter_useInventorySystem ) then
				set s__ACharacter_inventory[this]=sc__AInventory_create(this)
			endif
  endfunction

		/// @todo Should be private, vJass bug
		//Private, every player only can have one character
  function s__ACharacter_create takes player user,unit usedUnit returns integer
   local integer this= s__ACharacter__allocate()
			//start members
			set s__ACharacter_user[this]=user
			set s__ACharacter_usedUnit[this]=usedUnit
			//dynamic members
			set s__ACharacter_movable[this]=true

			call s__ACharacter_createLeaveTrigger(this)
			call s__ACharacter_createDeathTrigger(this)
			call s__ACharacter_createSystems(this)
			return this
  endfunction

  function s__ACharacter_removeUsedUnit takes integer this returns nothing
			if ( s__ACharacter_removeUnitOnDestruction ) then
				call RemoveUnit(s__ACharacter_usedUnit[this])
			endif
			set s__ACharacter_usedUnit[this]=null
  endfunction

  function s__ACharacter_destroyLeaveTrigger takes integer this returns nothing
			call s__AHashTable_destroyTrigger(AGetCharacterHashTable(),s__ACharacter_leaveTrigger[this])
			set s__ACharacter_leaveTrigger[this]=null
  endfunction

  function s__ACharacter_destroyDeathTrigger takes integer this returns nothing
			call s__AHashTable_destroyTrigger(AGetCharacterHashTable(),s__ACharacter_deathTrigger[this])
			set s__ACharacter_deathTrigger[this]=null
  endfunction

  function s__ACharacter_destroySystems takes integer this returns nothing
			//ifs are important
			if ( s__ACharacter_useViewSystem ) then
				call sc__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_destroy(s__ACharacter_view[this])
			endif
			if ( s__ACharacter_useFocusSystem ) then
				call sc__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_destroy(s__ACharacter_focus[this])
			endif
			if ( s__ACharacter_useMovementSystem ) then
				call sc__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_destroy(s__ACharacter_movement[this])
			endif
			if ( s__ACharacter_useFightSystem ) then
				call sc__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_destroy(s__ACharacter_fight[this])
			endif
			if ( s__ACharacter_useRevivalSystem ) then
				call sc__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_destroy(s__ACharacter_revival[this])
			endif
			if ( s__ACharacter_useInventorySystem ) then
				call sc__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_destroy(s__ACharacter_inventory[this])
			endif
  endfunction

		//Automatic desturction when player leaves
  function s__ACharacter_onDestroy takes integer this returns nothing
			//start members
			set s__ACharacter_user[this]=null

			call s__ACharacter_removeUsedUnit(this)
			call s__ACharacter_destroyLeaveTrigger(this)
			call s__ACharacter_destroyDeathTrigger(this)
			call s__ACharacter_destroySystems(this)
  endfunction

//Generated destructor of ACharacter
function s__ACharacter_destroy takes integer this returns nothing
    if this==null then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: ACharacter")
        return
    elseif (si__ACharacter_V[this]!=-1) then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: ACharacter")
        return
    endif
    call s__ACharacter_onDestroy(this)
    set si__ACharacter_V[this]=si__ACharacter_F
    set si__ACharacter_F=this
endfunction

		/// Call this method before you use this class!
		/// @param destroyOnPlayerLeaves If this value is false the character will be set unmovable when his owner leaves otherwise he will be destroyed.
		/// @param destroyOnDeath If this value is false the character will be set unmovable when he dies otherwise he will be destroyed.
		/// @param useViewSystem Shows if the view system is used.
		/// @param useFocusSystem Shows if the focus system is used.
		/// @param useMovementSystem Shows if the movement system is used.
		/// @param useFightSystem Shows if the fight system is used.
		/// @param useRevivalSystem Shows if the revival system is used.
		/// @param useInventorySystem Shows if the inventory system is used.
  function s__ACharacter_init takes boolean removeUnitOnDestruction,boolean destroyOnPlayerLeaves,boolean destroyOnDeath,boolean useViewSystem,boolean useFocusSystem,boolean useMovementSystem,boolean useFightSystem,boolean useRevivalSystem,boolean useInventorySystem returns nothing
			//static start members
			set s__ACharacter_removeUnitOnDestruction=removeUnitOnDestruction
			set s__ACharacter_destroyOnPlayerLeaves=destroyOnPlayerLeaves
			set s__ACharacter_destroyOnDeath=destroyOnDeath
			set s__ACharacter_useViewSystem=useViewSystem
			set s__ACharacter_useFocusSystem=useFocusSystem
			set s__ACharacter_useMovementSystem=useMovementSystem
			set s__ACharacter_useFightSystem=useFightSystem
			set s__ACharacter_useRevivalSystem=useRevivalSystem
			set s__ACharacter_useInventorySystem=useInventorySystem
  endfunction

		/// Each player can own exactly one character.
		/// Use this method to set the characters unit of a player.
		/// @param user The owner of the character.
		/// @param usedUnit The unit of the character.
		/// @return Character id.
  function s__ACharacter_setPlayerCharacter takes player user,unit usedUnit returns integer
   local integer character= s__ACharacter_create(user , usedUnit)
			set s__ACharacter_playerCharacter[GetPlayerId(user)]=character
			return character
  endfunction

		/// @param user The owner of the character.
		/// @return The character instance.
  function s__ACharacter_getPlayerCharacter takes player user returns integer
			return s__ACharacter_playerCharacter[GetPlayerId(user)]
  endfunction

		/// If character will be destroyed automaticly you don't have to call this method.
		/// @param user The owner of the character.
  function s__ACharacter_destroyPlayerCharacter takes player user returns nothing
			call s__ACharacter_destroy(s__ACharacter_playerCharacter[GetPlayerId(user)])
  endfunction
		
		//static comfort methods
		
		/// @todo You could also check it by only comparing with the units owner character unit.
  function s__ACharacter_getCharacterByUnit takes unit usedUnit returns integer
   local integer i
   local player user
			set i = 0
			loop
				exitwhen ( i == bj_MAX_PLAYERS )
				set user = Player(i)
				if ( s__ACharacter_getPlayerCharacter(user) != 0 and s__ACharacter_getUsedUnit(s__ACharacter_getPlayerCharacter(user)) == usedUnit ) then
					set user = null
					return s__ACharacter_getPlayerCharacter(user)
				endif
				set user = null
				set i = i + 1
			endloop
			return 0
  endfunction

  function s__ACharacter_setAllMovable takes boolean movable returns nothing
   local integer i
   local player user
			set i = 0
			loop
				exitwhen ( i == bj_MAX_PLAYERS )
				set user = Player(i)
				if ( IsPlayerPlayingUser(user) ) then
					call s__ACharacter_setMovable(s__ACharacter_getPlayerCharacter(user),movable)
				endif
				set user = null
				set i = i + 1
			endloop
  endfunction

		/// Displays a message to each owner of every character.
  function s__ACharacter_displayMessageToAll takes integer messageType,string message returns nothing
   local integer i
   local player user
			set i = 0
			loop
				exitwhen ( i == bj_MAX_PLAYERS )
				set user = Player(i)
				if ( IsPlayerPlayingUser(user) ) then
					call s__ACharacter_displayMessage(s__ACharacter_getPlayerCharacter(user),messageType , message)
				endif
				set user = null
				set i = i + 1
			endloop
  endfunction

  function s__ACharacter_addLevelsToAll takes integer levels,boolean showEffect returns nothing
   local integer i
   local player user
			set i = 0
			loop
				exitwhen ( i == bj_MAX_PLAYERS )
				set user = Player(i)
				if ( IsPlayerPlayingUser(user) ) then
					call s__ACharacter_addLevels(s__ACharacter_getPlayerCharacter(user),levels , showEffect)
				endif
				set user = null
				set i = i + 1
			endloop
  endfunction

  function s__ACharacter_addSkillPointsToAll takes integer skillPoints returns nothing
   local integer i
   local player user
			set i = 0
			loop
				exitwhen ( i == bj_MAX_PLAYERS )
				set user = Player(i)
				if ( IsPlayerPlayingUser(user) ) then
					call s__ACharacter_addSkillPoints(s__ACharacter_getPlayerCharacter(user),skillPoints)
				endif
				set user = null
				set i = i + 1
			endloop
  endfunction

  function s__ACharacter_addExperienceToAll takes integer experience,boolean showEffect returns nothing
   local integer i
   local player user
			set i = 0
			loop
				exitwhen ( i == bj_MAX_PLAYERS )
				set user = Player(i)
				if ( IsPlayerPlayingUser(user) ) then
					call s__ACharacter_addExperience(s__ACharacter_getPlayerCharacter(user),experience , showEffect)
				endif
				set user = null
				set i = i + 1
			endloop
  endfunction

  function s__ACharacter_addStrengthToAll takes integer strength returns nothing
   local integer i
   local player user
			set i = 0
			loop
				exitwhen ( i == bj_MAX_PLAYERS )
				set user = Player(i)
				if ( IsPlayerPlayingUser(user) ) then
					call s__ACharacter_addStrength(s__ACharacter_getPlayerCharacter(user),strength)
				endif
				set user = null
				set i = i + 1
			endloop
  endfunction

  function s__ACharacter_addAgilityToAll takes integer agility returns nothing
   local integer i
   local player user
			set i = 0
			loop
				exitwhen ( i == bj_MAX_PLAYERS )
				set user = Player(i)
				if ( IsPlayerPlayingUser(user) ) then
					call s__ACharacter_addAgility(s__ACharacter_getPlayerCharacter(user),agility)
				endif
				set user = null
				set i = i + 1
			endloop
  endfunction

  function s__ACharacter_addIntelligenceToAll takes integer intelligence returns nothing
   local integer i
   local player user
			set i = 0
			loop
				exitwhen ( i == bj_MAX_PLAYERS )
				set user = Player(i)
				if ( IsPlayerPlayingUser(user) ) then
					call s__ACharacter_addIntelligence(s__ACharacter_getPlayerCharacter(user),intelligence)
				endif
				set user = null
				set i = i + 1
			endloop
  endfunction

  function s__ACharacter_addGoldToAll takes integer gold returns nothing
   local integer i
   local player user
			set i = 0
			loop
				exitwhen ( i == bj_MAX_PLAYERS )
				set user = Player(i)
				if ( IsPlayerPlayingUser(user) ) then
					call s__ACharacter_addGold(s__ACharacter_getPlayerCharacter(user),gold)
				endif
				set user = null
				set i = i + 1
			endloop
  endfunction

  function s__ACharacter_addLumberToAll takes integer lumber returns nothing
   local integer i
   local player user
			set i = 0
			loop
				exitwhen ( i == bj_MAX_PLAYERS )
				set user = Player(i)
				if ( IsPlayerPlayingUser(user) ) then
					call s__ACharacter_addLumber(s__ACharacter_getPlayerCharacter(user),lumber)
				endif
				set user = null
				set i = i + 1
			endloop
  endfunction
		
  function s__ACharacter_allUnitsAreInRect takes rect usedRect returns boolean
   local integer i
   local player user
			set i = 0
			loop
				exitwhen ( i == bj_MAX_PLAYERS )
				set user = Player(i)
				if ( IsPlayerPlayingUser(user) ) then
					if ( ( s__ACharacter_getUsedUnit(s__ACharacter_getPlayerCharacter(user)) == null ) or ( not RectContainsUnit(usedRect , s__ACharacter_getUsedUnit(s__ACharacter_getPlayerCharacter(user))) ) ) then //RectContainsUnit shouldn't be that slow
						return false
					endif
				endif
				set user = null
				set i = i + 1
			endloop
			return true
  endfunction


//library AStructSystemsCharacterCharacter ends
//library AStructSystemsCharacterFight:

		//static start members
		//members

  function s__AFight_enable takes integer this returns nothing
			call EnableTrigger(s__AFight_fightTrigger[this])
			if ( TimerGetRemaining(s__AFight_usedTimer[this]) > 0.0 ) then
				call PauseTimerBJ(false , s__AFight_usedTimer[this])
			endif
  endfunction

  function s__AFight_disable takes integer this returns nothing
			call DisableTrigger(s__AFight_fightTrigger[this])
			if ( TimerGetRemaining(s__AFight_usedTimer[this]) > 0.0 ) then
				call PauseTimerBJ(true , s__AFight_usedTimer[this])
			endif
  endfunction

  function s__AFight_hit takes integer this returns nothing
			set s__AFight_hasOrdered[this]=false
			set s__AFight_canOrder[this]=false

			//call UnitDamagePoint(this.getUnit(), 0.0, GetUnitPolarProjectionX(this.getUnit(), (GetUnitFacing(this.getUnit()) + AFight.angle), AFocus.range)

			set s__AFight_canOrder[this]=true
  endfunction

  function s__AFight_timerFunctionReset takes nothing returns nothing
   local timer expiredTimer= GetExpiredTimer()
   local integer fight= s__AHashTable_getHandleInteger(AGetCharacterHashTable(),expiredTimer , "fight") //AClassCharacterCharacterHashTable
			set s__AFight_hasOrdered[fight]=false
			set expiredTimer = null
  endfunction

  function s__AFight_startTimer takes integer this returns nothing
			set s__AFight_hasOrdered[this]=true
			call TimerStart(s__AFight_usedTimer[this] , s__AFight_time , false , function s__AFight_timerFunctionReset)
			call s__AHashTable_storeHandleInteger(AGetCharacterHashTable(),s__AFight_usedTimer[this] , "fight" , this) //AClassCharacterCharacterHashTable
  endfunction

  function s__AFight_triggerConditionOrder takes nothing returns boolean
			return GetIssuedOrderId() == OrderId(s__AFight_order)
  endfunction

  function s__AFight_triggerActionOrder takes nothing returns nothing
   local trigger triggeringTrigger= GetTriggeringTrigger()
   local integer fight= s__AHashTable_getHandleInteger(AGetCharacterHashTable(),triggeringTrigger , "fight") //AClassCharacterCharacterHashTable
			if ( s__AFight_canOrder[fight] ) then
				if ( s__AFight_hasOrdered[fight] ) then
					call s__AFight_hit(fight)
				else
					call s__AFight_startTimer(fight)
				endif
			endif
			set triggeringTrigger = null
  endfunction

  function s__AFight_createFightTrigger takes integer this returns nothing
   local event triggerEvent
   local conditionfunc conditionFunction
   local triggercondition triggerCondition
   local triggeraction triggerAction
			if ( not s__AFight_useFps ) then
				set triggerEvent = TriggerRegisterUnitEvent(s__AFight_fightTrigger[this] , s__AAbstractCharacterSystem_getUnit(this) , EVENT_UNIT_ISSUED_ORDER) //Return nothing
				set conditionFunction = Condition(function s__AFight_triggerConditionOrder)
				set triggerCondition = TriggerAddCondition(s__AFight_fightTrigger[this] , conditionFunction)
				set triggerEvent = null
			else
				//call TriggerRegisterMouseEvent(this.fightTrigger, EVENT_LMOUSEDOWN) //fpscommon.j
			endif
			set triggerAction = TriggerAddAction(s__AFight_fightTrigger[this] , function s__AFight_triggerActionOrder)
			call s__AHashTable_storeHandleInteger(AGetCharacterHashTable(),s__AFight_fightTrigger[this] , "fight" , this) //AClassCharacterCharacterHashTable
			set conditionFunction = null
			set triggerCondition = null
			set triggerAction = null
  endfunction

  function s__AFight_create takes integer character returns integer
   local integer this= s__AFight__allocate(character)
			//members
			set s__AFight_usedTimer[this]=CreateTimer()

			call s__AFight_createFightTrigger(this)
			return this
  endfunction

  function s__AFight_destroyUsedTimer takes integer this returns nothing
			call s__AHashTable_destroyTimer(AGetCharacterHashTable(),s__AFight_usedTimer[this]) //AClassCharacterCharacterHashTable
			set s__AFight_usedTimer[this]=null
  endfunction

  function s__AFight_destroyFightTrigger takes integer this returns nothing
			call s__AHashTable_destroyTrigger(AGetCharacterHashTable(),s__AFight_fightTrigger[this]) //AClassCharacterCharacterHashTable
			set s__AFight_fightTrigger[this]=null
  endfunction

  function s__AFight_onDestroy takes integer this returns nothing

			call s__AFight_destroyUsedTimer(this)
			call s__AFight_destroyFightTrigger(this)
  endfunction

		/// @param useFps false, new implementation, uses the left mouse key
		/// @param order "move"
		/// @param time 0.5
		/// @param hitAnimation "attack"
		/// @param angle 20.0
  function s__AFight_init takes boolean useFps,string order,real time,string hitAnimation,real angle returns nothing
			//static start members
			set s__AFight_useFps=useFps
			set s__AFight_order=order
			set s__AFight_time=time
			set s__AFight_hitAnimation=hitAnimation
			set s__AFight_angle=angle
  endfunction


//library AStructSystemsCharacterFight ends
//library AStructSystemsCharacterSpell:

	/// @todo vJass bug, should be a part of @struct ASpell.
//processed: 	function interface ASpellCastAction takes ACharacter character returns nothing

	/// This struct represents exactly one spell which is owned by a character.
	/// @author Tamino Dauth
	/// @param Hello
		//start members
		//members

		//Make it available
  function s__ASpell_enable takes integer this returns nothing
  endfunction

  function s__ASpell_disable takes integer this returns nothing
  endfunction

  function s__ASpell_triggerConditionCast takes nothing returns boolean
   local trigger triggeringTrigger= GetTriggeringTrigger()
   local integer spell= s__AHashTable_getHandleInteger(AGetCharacterHashTable(),triggeringTrigger , "spell") //AClassCharacterCharacterHashTable
   local boolean result= ( GetSpellAbilityId() == s__ASpell_usedAbility[spell] )
			set triggeringTrigger = null
			return result
  endfunction

  function s__ASpell_triggerActionCast takes nothing returns nothing
   local trigger triggeringTrigger= GetTriggeringTrigger()
   local integer spell= s__AHashTable_getHandleInteger(AGetCharacterHashTable(),triggeringTrigger , "spell") //AClassCharacterCharacterHashTable
			call sc___prototype831_execute(s__ASpell_castAction[spell],s__AAbstractCharacterSystem_getCharacter(spell))
			set triggeringTrigger = null
  endfunction

  function s__ASpell_createCastTrigger takes integer this returns nothing
   local event triggerEvent
   local conditionfunc conditionFunction
   local triggercondition triggerCondition
   local triggeraction triggerAction
			if ( s__ASpell_castAction[this] != 0 ) then
				set s__ASpell_castTrigger[this]=CreateTrigger()
				set triggerEvent = TriggerRegisterUnitEvent(s__ASpell_castTrigger[this] , s__AAbstractCharacterSystem_getUnit(this) , EVENT_UNIT_SPELL_CAST)
				set conditionFunction = Condition(function s__ASpell_triggerConditionCast)
				set triggerCondition = TriggerAddCondition(s__ASpell_castTrigger[this] , conditionFunction)
				set triggerAction = TriggerAddAction(s__ASpell_castTrigger[this] , function s__ASpell_triggerActionCast)
				call s__AHashTable_storeHandleInteger(AGetCharacterHashTable(),s__ASpell_castTrigger[this] , "spell" , this) //AClassCharacterCharacterHashTable
				set triggerEvent = null
				set conditionFunction = null
				set triggerCondition = null
				set triggerAction = null
			endif
  endfunction

		/// @param character Used character.
		/// @param usedAbility The ability which has to be casted by the unit of the character to run the cast action and which has to be skilled for the unit of the character to run the teach action.
  function s__ASpell_create takes integer character,integer usedAbility,integer castAction returns integer
   local integer this= s__ASpell__allocate(character)
			//start members
			set s__ASpell_usedAbility[this]=usedAbility
			set s__ASpell_castAction[this]=castAction

			call s__ASpell_createCastTrigger(this)
			return this
  endfunction

  function s__ASpell_destroyCastTrigger takes integer this returns nothing
			if ( s__ASpell_castAction[this] != 0 ) then
				call s__AHashTable_destroyTrigger(AGetCharacterHashTable(),s__ASpell_castTrigger[this]) //AClassCharacterCharacterHashTable
				set s__ASpell_castTrigger[this]=null
			endif
  endfunction

  function s__ASpell_onDestroy takes integer this returns nothing

			call s__ASpell_destroyCastTrigger(this)
  endfunction


//library AStructSystemsCharacterSpell ends
//library AStructSystemsCharacterView:

		//static start members
		//members

		//methods

  function s__AView_enable takes integer this returns nothing
			call EnableTrigger(s__AView_viewTrigger[this])
			call SetCameraTargetControllerNoZForPlayer(s__AAbstractCharacterSystem_getUser(this) , s__AAbstractCharacterSystem_getUnit(this) , 0.0 , 0.0 , false)
  endfunction

  function s__AView_disable takes integer this returns nothing
			call DisableTrigger(s__AView_viewTrigger[this])
			call ResetToGameCameraForPlayer(s__AAbstractCharacterSystem_getUser(this) , 0.0)
  endfunction

  function s__AView_refreshView takes integer this returns nothing
   local real z= GetTerrainZ(GetUnitX(s__AAbstractCharacterSystem_getUnit(this)) , GetUnitY(s__AAbstractCharacterSystem_getUnit(this)))
			call CameraSetupApplyForPlayer(true , s__AView_cameraSetup , s__AAbstractCharacterSystem_getUser(this) , 0.0)
			call SetCameraFieldForPlayer(s__AAbstractCharacterSystem_getUser(this) , CAMERA_FIELD_ROTATION , GetUnitFacing(s__AAbstractCharacterSystem_getUnit(this)) , 0.0)
			call SetCameraFieldForPlayer(s__AAbstractCharacterSystem_getUser(this) , CAMERA_FIELD_ZOFFSET , 128.0 + z + GetUnitFlyHeight(s__AAbstractCharacterSystem_getUnit(this)) , 0.0) //Eigentlich perfekter Z-Wert
         endfunction

  function s__AView_triggerActionRefreshView takes nothing returns nothing
   local trigger triggeringTrigger= GetTriggeringTrigger()
   local integer view= s__AHashTable_getHandleInteger(AGetCharacterHashTable(),triggeringTrigger , "view") //AClassCharacterCharacterHashTable
			call s__AView_refreshView(view)
			set triggeringTrigger = null
  endfunction

  function s__AView_createViewTrigger takes integer this returns nothing
   local event triggerEvent
   local triggeraction triggerAction
			set s__AView_viewTrigger[this]=CreateTrigger()
			set triggerEvent = TriggerRegisterTimerEvent(s__AView_viewTrigger[this] , s__AView_viewRefreshRate , true)
			set triggerAction = TriggerAddAction(s__AView_viewTrigger[this] , function s__AView_triggerActionRefreshView)
			call s__AHashTable_storeHandleInteger(AGetCharacterHashTable(),s__AView_viewTrigger[this] , "view" , this) //AClassCharacterCharacterHashTable
			set triggerEvent = null
			set triggerAction = null
  endfunction

  function s__AView_create takes integer character returns integer
   local integer this= s__AView__allocate(character)

			call s__AView_createViewTrigger(this)
			return this
  endfunction

  function s__AView_destroyViewTrigger takes integer this returns nothing
			call s__AHashTable_destroyTrigger(AGetCharacterHashTable(),s__AView_viewTrigger[this]) //AClassCharacterCharacterHashTable
			set s__AView_viewTrigger[this]=null
  endfunction

  function s__AView_onDestroy takes integer this returns nothing

			call s__AView_destroyViewTrigger(this)
  endfunction

  function s__AView_init takes camerasetup cameraSetup,real viewRefreshRate returns nothing
			//static start members
			set s__AView_cameraSetup=cameraSetup
			set s__AView_viewRefreshRate=viewRefreshRate
  endfunction


//library AStructSystemsCharacterView ends
//library AStructSystemsGuiGui:

	/// @todo AGui.maxMainWindows should be the max size value
//textmacro instance: A_CONTAINER("AMainWindow", "MainWindow", "4")

		/// @state untested
		/// An operation function interface with two elements.
		/// The return value is the result of the operation.
		/// Examples are addition and subtraction etc.
//processed: 		function interface AMainWindowContainerOperation takes AMainWindow element0, AMainWindow element1 returns AMainWindow

		/// @state untested
		/// Unary predicate.
		/// A comparision function interface for one element.
//processed: 		function interface AMainWindowContainerUnaryPredicate takes AMainWindow element returns boolean

		/// @state untested
		/// Binary predicate.
		/// A comparisan function interface for two elements.
//processed: 		function interface AMainWindowContainerBinaryPredicate takes AMainWindow element0, AMainWindow element1 returns boolean

		/// @state works
		/// Unary function.
		/// Allows the call of an user-definied function for each element.
//processed: 		function interface AMainWindowContainerUnaryFunction takes AMainWindow element returns nothing //Rückgabewert wurde vorerst rausgenommen, bis ich weiß, was er bringt

		/// Generator.
		/// Allows filling some elements with the return value.
//processed: 		function interface AMainWindowContainerGenerator takes nothing returns AMainWindow

			//dynamic members
			//Quicksort statics

			//dynamic members

   function s__AMainWindowContainer_setElement takes integer this,integer index,integer element returns nothing
     call sc__AMainWindowContainer_debugCheckIndex(this,index)
				set s___AMainWindowContainer_element[s__AMainWindowContainer_element[this]+index]=element
   endfunction

   function s__AMainWindowContainer_getElement takes integer this,integer index returns integer
     call sc__AMainWindowContainer_debugCheckIndex(this,index)
				return s___AMainWindowContainer_element[s__AMainWindowContainer_element[this]+index]
   endfunction

			//start members

   function s__AMainWindowContainer_getSize takes integer this returns integer
				return s___AMainWindowContainer_element_size
   endfunction

			//methods

			/// Checks the start position.
    function s__AMainWindowContainer_debugCheckStart takes integer this,integer start returns nothing
     if ( ( start < 0 ) or ( start >= 4 ) ) then
      call Print("Wrong start value of container " + I2S(this) + ": start " + I2S(start) + ".")
     endif
    endfunction

			/// Checks the number.
    function s__AMainWindowContainer_debugCheckNumber takes integer this,integer number returns nothing
     if ( ( number > 4 ) or ( number <= 0 ) ) then
      call Print("Wrong number value of container " + I2S(this) + ": number " + I2S(number) + ".")
     endif
    endfunction

			/// Checks both values.
    function s__AMainWindowContainer_debugCheckStartAndNumber takes integer this,integer start,integer number returns nothing
     call s__AMainWindowContainer_debugCheckStart(this,start)
     call s__AMainWindowContainer_debugCheckNumber(this,number)
     if ( start + number > 4 ) then
      call Print("Wrong start or number value of container " + I2S(this) + ": start " + I2S(start) + " number " + I2S(number) + ".")
     endif
    endfunction

			/// Checks over- and underflow of the size.
    function s__AMainWindowContainer_debugCheckSize takes integer this,integer size returns nothing
     if ( size > 4 ) then
      call Print("Wrong size of container " + I2S(this) + ": " + I2S(size) + ".")
     endif
    endfunction
	
			/// Checks over- and underflow of the index.
    function s__AMainWindowContainer_debugCheckIndex takes integer this,integer index returns nothing
     if ( ( index < 0 ) or ( index >= 4 ) ) then
      call Print("Wrong index of container " + I2S(this) + ": " + I2S(index) + ".")
     endif
    endfunction

			/// Common quick sort algorithm.
   function s__AMainWindowContainer_quickSort takes integer this,integer left,integer right,integer binaryPredicate returns nothing
    local integer i
    local integer temp
				if ( right > left ) then
					set s__AMainWindowContainer_m[this]=s___AMainWindowContainer_element[s__AMainWindowContainer_element[this]+right]
					set i = left - 1
					set s__AMainWindowContainer_j[this]=right
					loop
						loop
							set i = i + 1
							exitwhen ( not sc___prototype834_evaluate(binaryPredicate,s___AMainWindowContainer_element[s__AMainWindowContainer_element[this]+i] , s__AMainWindowContainer_m[this]) )
						endloop
						
						loop
							set s__AMainWindowContainer_j[this]=s__AMainWindowContainer_j[this] - 1
							exitwhen ( sc___prototype834_evaluate(binaryPredicate,s___AMainWindowContainer_element[s__AMainWindowContainer_element[this]+s__AMainWindowContainer_j[this]] , s__AMainWindowContainer_m[this]) )
						endloop
		
						exitwhen ( i >= s__AMainWindowContainer_j[this] )
						set temp = s___AMainWindowContainer_element[s__AMainWindowContainer_element[this]+i]
						set s___AMainWindowContainer_element[s__AMainWindowContainer_element[this]+i]=s___AMainWindowContainer_element[s__AMainWindowContainer_element[this]+s__AMainWindowContainer_j[this]]
						set s___AMainWindowContainer_element[s__AMainWindowContainer_element[this]+s__AMainWindowContainer_j[this]]=temp
					endloop
					
					set temp = s___AMainWindowContainer_element[s__AMainWindowContainer_element[this]+i]
					set s___AMainWindowContainer_element[s__AMainWindowContainer_element[this]+i]=s___AMainWindowContainer_element[s__AMainWindowContainer_element[this]+right]
					set s___AMainWindowContainer_element[s__AMainWindowContainer_element[this]+right]=temp
					
					call s__AMainWindowContainer_quickSort(this,left , i - 1 , binaryPredicate)
					call s__AMainWindowContainer_quickSort(this,i + 1 , right , binaryPredicate)
				endif
   endfunction

			/// Sorts elements by using the quick sort algorithm in ascending order.
			/// @param start Index of first element.
			/// @param number Number of elements.
			/// @param binaryPredicate Binary comparison function.
   function s__AMainWindowContainer_sort takes integer this,integer start,integer number,integer binaryPredicate returns nothing
     call s__AMainWindowContainer_debugCheckStartAndNumber(this,start , number)
				call s__AMainWindowContainer_quickSort(this,start , start + number - 1 , binaryPredicate)
   endfunction

			/// Reverses elements.
			/// @param start Index of first element.
			/// @param number Number of elements.
			/// @todo I'm not sure if this is best solution.
   function s__AMainWindowContainer_reverse takes integer this,integer start,integer number returns nothing
    local integer i= start
    local integer exitValue= start + ( number / 2 )
    local integer temp
    local integer swapindex
     call s__AMainWindowContainer_debugCheckStartAndNumber(this,start , number)
				loop
					exitwhen ( i == exitValue )
					set swapindex = ( ( 2 * start ) + number - i - 1 )
					set temp = s___AMainWindowContainer_element[s__AMainWindowContainer_element[this]+i]
					set s___AMainWindowContainer_element[s__AMainWindowContainer_element[this]+i]=s___AMainWindowContainer_element[s__AMainWindowContainer_element[this]+swapindex]
					set s___AMainWindowContainer_element[s__AMainWindowContainer_element[this]+swapindex]=temp
					set i = i + 1
				endloop
   endfunction

			//C++ algorithm

			/// @state untested
			/// Orientiert sich an accumulate und adjacent_difference.
			/// Man kann allerdings nicht jeden Datentyp addieren oder subtrahieren.
			/// Führt eine Operation mit allen Elementen in einem Bereich durch.
			/// @param start Startposition
			/// @param number Anzahl der Elemente
			/// @param value Der Startwert des Ergebnis
			/// @param operation Operationsfunktion
			/// @return Ergebnis aller Operationen
   function s__AMainWindowContainer_operation takes integer this,integer start,integer number,integer value,integer operation returns integer
    local integer i= start
    local integer exitValue= start + number
    local integer result= value
     call s__AMainWindowContainer_debugCheckStartAndNumber(this,start , number)
				loop
					exitwhen ( i == exitValue )
					set result = sc___prototype832_evaluate(operation,result , s___AMainWindowContainer_element[s__AMainWindowContainer_element[this]+i]) //Returns something
					set i = i + 1
				endloop
				return result
   endfunction

			/// @state untested
			/// Sucht nach zwei aneinander liegenden gleichen Elementen.
			/// @param start Startposition
			/// @param number Anzahl der Elemente
			/// @return Index des ersten Treffers oder -1
   function s__AMainWindowContainer_adjacentFind takes integer this,integer start,integer number returns integer
    local integer i= start
    local integer exitValue= start + number - 1 //-1 da beim Vergleich + 1 angewendet wird
     call s__AMainWindowContainer_debugCheckStartAndNumber(this,start , number)
				loop
					exitwhen ( i == exitValue )
					if ( s___AMainWindowContainer_element[s__AMainWindowContainer_element[this]+i] == s___AMainWindowContainer_element[s__AMainWindowContainer_element[this]+i + 1] ) then
						return i
					endif
					set i = i + 1
				endloop
				return - 1
   endfunction

			/// @state untested
			/// Sucht mit Hilfe einer benutzerdefinierten Vergleichsfunktion nach zwei aneinander liegenden gleichen Elementen.
			/// @param start Startposition
			/// @param number Anzahl der Elemente
			/// @param binaryPredicate Vergleichsfunktion
			/// @return Index des ersten Treffers oder -1
   function s__AMainWindowContainer_adjacentFindIf takes integer this,integer start,integer number,integer binaryPredicate returns integer
    local integer i= start
    local integer exitValue= start + number - 1 //-1 da beim Vergleich + 1 angewendet wird
     call s__AMainWindowContainer_debugCheckStartAndNumber(this,start , number)
				loop
					exitwhen ( i == exitValue )
					if ( sc___prototype834_evaluate(binaryPredicate,s___AMainWindowContainer_element[s__AMainWindowContainer_element[this]+i] , s___AMainWindowContainer_element[s__AMainWindowContainer_element[this]+i + 1]) ) then
						return i
					endif
					set i = i + 1
				endloop
				return - 1
   endfunction

			/// @state untested
			/// Die binäre Suche funktioniert nur wenn die Elemente in Reihenfolge sortiert sind.
			/// @todo Noch implementieren.
			/// @todo bool binary_search( iterator start, iterator end, const TYPE& val );
			/// @todo bool binary_search( iterator start, iterator end, const TYPE& val, Comp f );
   function s__AMainWindowContainer_binarySearch takes integer this returns nothing
   endfunction

			/// @state untested
			/// Kopiert einen Elementebereich des Containers in einen Ziel-Container.
			/// @param start0 Index of first element.
			/// @param number0 Number of elements.
			/// @param start1 Index of first element in container @param desitination.
			/// @param destination Container where elements are copied to.
   function s__AMainWindowContainer_copy takes integer this,integer start0,integer number0,integer start1,integer destination returns nothing
    local integer i= start0
    local integer j= start1
    local integer exitValue= start0 + number0
     call s__AMainWindowContainer_debugCheckStartAndNumber(this,start0 , number0)
     call s__AMainWindowContainer_debugCheckStart(destination,start1)
				loop
					exitwhen ( i == exitValue )
					set s___AMainWindowContainer_element[s__AMainWindowContainer_element[destination]+j]=s___AMainWindowContainer_element[s__AMainWindowContainer_element[this]+i]
					set i = i + 1
					set j = j + 1
				endloop
   endfunction

			/// @state untested
			/// Kopiert einen Elementebereich des Containers in einen Ziel-Container.
			/// Im Gegensatz zur copy-Methode fängt diese Methode beim letzten zu kopierenden Wert an.
			/// @param start0 Startposition
			/// @param number0 Anzahl der Elemente
			/// @param start1 Startposition im Ziel-Container
			/// @param destination Ziel-Container
   function s__AMainWindowContainer_copyBackward takes integer this,integer start0,integer number0,integer start1,integer destination returns nothing
    local integer i= start0 + number0 - 1
    local integer j= start1 + number0 - 1
    local integer exitValue= start0 - 1
     call s__AMainWindowContainer_debugCheckStartAndNumber(this,start0 , number0)
     call s__AMainWindowContainer_debugCheckStart(destination,start1)
				loop
					exitwhen ( i == exitValue )
					set s___AMainWindowContainer_element[s__AMainWindowContainer_element[destination]+j]=s___AMainWindowContainer_element[s__AMainWindowContainer_element[this]+i]
					set i = i - 1
					set j = j - 1
				endloop
   endfunction

			/// Diese Methode tut das, was die Methoden dieses Containers von C++-Containern unterscheidet.
			/// Sie verwendet als zweiten Parameter die Anzahl der Elemente und keinen Ziel-Iterator.
			/// Sie ist daher überflüssig.
			/// iterator copy_n( iterator from, size_t num, iterator to );
   function s__AMainWindowContainer_copyN takes integer this returns nothing
   endfunction

			/// @state untested
			/// Vergleicht einen Elementebereich mit einem Wert.
			/// @param start Startposition
			/// @param number Anzahl der Elemente
			/// @param value Vergleichswert
			/// @return Anzahl der Treffer
   function s__AMainWindowContainer_count takes integer this,integer start,integer number,integer value returns integer
    local integer i= start
    local integer exitValue= start + number
    local integer result= 0
     call s__AMainWindowContainer_debugCheckStartAndNumber(this,start , number)
				loop
					exitwhen ( i == exitValue )
					if ( s___AMainWindowContainer_element[s__AMainWindowContainer_element[this]+i] == value ) then
						set result = result + 1
					endif
					set i = i + 1
				endloop
				return result
   endfunction

			/// @state untested
			/// Vergleicht einen Elementebereich mit Hilfe einer benutzerdefinierten Funktion.
			/// @param start Startposition
			/// @param number Anzahl der Elemente
			/// @param unaryPredicate Vergleichsfunktion
			/// @return Anzahl der Treffer
   function s__AMainWindowContainer_countIf takes integer this,integer start,integer number,integer unaryPredicate returns integer
    local integer i= start
    local integer exitValue= start + number
    local integer result= 0
     call s__AMainWindowContainer_debugCheckStartAndNumber(this,start , number)
				loop
					exitwhen ( i == exitValue )
					if ( sc___prototype833_evaluate(unaryPredicate,s___AMainWindowContainer_element[s__AMainWindowContainer_element[this]+i]) ) then
						set result = result + 1
					endif
					set i = i + 1
				endloop
				return result
   endfunction

			/// @state untested
			/// Prüft ob ein Elementebereich einem anderen entspricht.
			/// Verwendet dabei den Standard ==-Operator, der normalerweise bei allen Datentypen anwendbar ist.
			/// @param start1 Startposition
			/// @param number1 Anzahl der Elemente
			/// @param start2 Startposition im Vergleichs-Container
			/// @param destination Vergleichs-Container
			/// @return Übereinstimmung aller Elemente
   function s__AMainWindowContainer_equal takes integer this,integer start1,integer number1,integer start2,integer destination returns boolean
    local integer i= start1
    local integer j= start2
    local integer exitValue= start1 + number1
     call s__AMainWindowContainer_debugCheckStartAndNumber(this,start1 , number1)
     call s__AMainWindowContainer_debugCheckStart(destination,start2)
				loop
					exitwhen ( i == exitValue )
						if ( not ( s___AMainWindowContainer_element[s__AMainWindowContainer_element[this]+i] == s___AMainWindowContainer_element[s__AMainWindowContainer_element[destination]+j] ) ) then
							return false
						endif
					set i = i + 1
					set j = j + 1
				endloop
				return true
   endfunction

			/// @state untested
			/// Prüft mit Hilfe einer benutzerdefinierten Vergleichsfunktion ob ein Elementebereich einem anderen entspricht.
			/// @param start0 Startposition
			/// @param number0 Anzahl der Elemente
			/// @param start1 Startposition im Vergleichs-Container
			/// @param destination Vergleichs-Container
			/// @param binaryPredicate Vergleichsfunktion
			/// @return Übereinstimmung aller Elemente
   function s__AMainWindowContainer_equalIf takes integer this,integer start0,integer number0,integer start1,integer destination,integer binaryPredicate returns boolean
    local integer i= start0
    local integer j= start1
    local integer exitValue= start0 + number0
     call s__AMainWindowContainer_debugCheckStartAndNumber(this,start0 , number0)
     call s__AMainWindowContainer_debugCheckStart(destination,start1)
				loop
					exitwhen ( i == exitValue )
						if ( not sc___prototype834_evaluate(binaryPredicate,s___AMainWindowContainer_element[s__AMainWindowContainer_element[this]+i] , s___AMainWindowContainer_element[s__AMainWindowContainer_element[destination]+j]) ) then
							return false
						endif
					set i = i + 1
					set j = j + 1
				endloop
				return true
   endfunction

			/// @state untested
			/// Füllt einen Elementebereich mit einem Wert.
			/// @param start Startposition
			/// @param number Anzahl der Elemente
			/// @param value Zu füllender Wert
   function s__AMainWindowContainer_fill takes integer this,integer start,integer number,integer value returns nothing
    local integer i= start
    local integer exitValue= start + number
     call s__AMainWindowContainer_debugCheckStartAndNumber(this,start , number)
				loop
					exitwhen ( i == exitValue )
						set s___AMainWindowContainer_element[s__AMainWindowContainer_element[this]+i]=value
					set i = i + 1
				endloop
   endfunction

			/// Diese Methode tut das, was die Methoden dieses Containers von C++-Containern unterscheidet.
			/// Sie verwendet als zweiten Parameter die Anzahl der Elemente und keinen Ziel-Iterator.
			/// Sie ist daher überflüssig.
			/// iterator fill_n( iterator start, size_t n, const TYPE& val );
   function s__AMainWindowContainer_fillN takes integer this returns nothing
   endfunction

			/// @state untested
			/// Sucht im Container nach einem Element mit einem bestimmten Wert.
			/// @param start Index of first element which is checked for the searched value.
			/// @param number Number of elements which are checked for the searched value.
			/// @param value Searched value.
			/// @return Returns the index of the first hit. If there was no hit it returns -1.
   function s__AMainWindowContainer_find takes integer this,integer start,integer number,integer value returns integer
    local integer i= start
    local integer exitValue= start + number
     call s__AMainWindowContainer_debugCheckStartAndNumber(this,start , number)
				loop
					exitwhen ( i == exitValue )
					if ( s___AMainWindowContainer_element[s__AMainWindowContainer_element[this]+i] == value ) then
						return i
					endif
					set i = i + 1
				endloop
				return - 1
   endfunction

			/// @todo iterator find_end( iterator start, iterator end, iterator seq_start, iterator seq_end );
			/// @todo iterator find_end( iterator start, iterator end, iterator seq_start, iterator seq_end, BinPred bp );
   function s__AMainWindowContainer_findEnd takes integer this returns nothing
   endfunction

			/// @todo iterator find_first_of( iterator start, iterator end, iterator find_start, iterator find_end );
			/// @todo iterator find_first_of( iterator start, iterator end, iterator find_start, iterator find_end, BinPred bp );
   function s__AMainWindowContainer_findFirstOf takes integer this returns nothing
   endfunction

			/// @state untested
			/// Sucht mit Hilfe einer benutzerdefinierten Funktion ein Element im Container.
			/// @param start Startposition
			/// @param number Anzahl der Elemente
			/// @param unaryPredicate Vergleichsfunktion
			/// @return Index des ersten Treffers oder -1
   function s__AMainWindowContainer_findIf takes integer this,integer start,integer number,integer unaryPredicate returns integer
    local integer i= start
    local integer exitValue= start + number
     call s__AMainWindowContainer_debugCheckStartAndNumber(this,start , number)
				loop
					exitwhen ( i == exitValue )
						if ( sc___prototype833_evaluate(unaryPredicate,s___AMainWindowContainer_element[s__AMainWindowContainer_element[this]+i]) ) then
							return i
						endif
					set i = i + 1
				endloop
				return - 1
   endfunction

			/// @state untested
			/// Führt eine benutzerdefinierte Funktion für einen Elementebereich aus.
			/// @param start Startposition
			/// @param number Anzahl der Elemente
			/// @param unaryFunction Benutzerdefinierte Funktion
   function s__AMainWindowContainer_forEach takes integer this,integer start,integer number,integer unaryFunction returns nothing
    local integer i= start
    local integer exitValue= start + number
     call s__AMainWindowContainer_debugCheckStartAndNumber(this,start , number)
				loop
					exitwhen ( i == exitValue )
						call sc___prototype835_execute(unaryFunction,s___AMainWindowContainer_element[s__AMainWindowContainer_element[this]+i])
					set i = i + 1
				endloop
   endfunction

			/// void generate( iterator start, iterator end, Generator g );
			/// @state untested
			/// Füllt einen Elementebereich mit dem Rückgabewert einer benutzerdefinierten Funktion.
			/// Funktion wurde so in Quell-Code des GCCs nachgeschlagen.
			/// @param start Startposition
			/// @param number Anzahl der Elemente
			/// @param generator Benutzerdefinierte Funktion
   function s__AMainWindowContainer_generate takes integer this,integer start,integer number,integer generator returns nothing
    local integer i= start
    local integer exitValue= start + number
     call s__AMainWindowContainer_debugCheckStartAndNumber(this,start , number)
				loop
					exitwhen ( i == exitValue )
						set s___AMainWindowContainer_element[s__AMainWindowContainer_element[this]+i]=sc___prototype836_evaluate(generator)
					set i = i + 1
				endloop
   endfunction

			/// Diese Methode tut das, was die Methoden dieses Containers von C++-Containern unterscheidet.
			/// Sie verwendet als zweiten Parameter die Anzahl der Elemente und keinen Ziel-Iterator.
			/// Sie ist daher überflüssig.
			/// iterator generate_n( iterator result, size_t num, Generator g );
   function s__AMainWindowContainer_generate_n takes integer this returns nothing
   endfunction

			/// @todo bool includes( iterator start1, iterator end1, iterator start2, iterator end2 );
			/// @todo bool includes( iterator start1, iterator end1, iterator start2, iterator end2, StrictWeakOrdering cmp );
			/// @todo The includes() algorithm returns true if every element in [start2,end2) is also in [start1,end1). Both of the given ranges must be sorted in ascending order.
			/// @todo By default, the < operator is used to compare elements. If the strict weak ordering function object cmp is given, then it is used instead.
   function s__AMainWindowContainer_includes takes integer this returns nothing
   endfunction

			/// @todo TYPE inner_product( iterator start1, iterator end1, iterator start2, TYPE val );
			/// @todo TYPE inner_product( iterator start1, iterator end1, iterator start2, TYPE val, BinaryFunction f1, BinaryFunction f2 );
			/// @todo The inner_product() function computes the inner product of [start1,end1) and a range of the same size starting at start2.
   function s__AMainWindowContainer_inner_product takes integer this returns nothing
   endfunction

			/// @todo inline void inplace_merge( iterator start, iterator middle, iterator end );
			/// @todo inline void inplace_merge( iterator start, iterator middle, iterator end, StrictWeakOrdering cmp );
			/// @todo The inplace_merge() function is similar to the merge() function, but instead of creating a new sorted range of elements, inplace_merge() alters the existing ranges to perform the merge in-place.
   function s__AMainWindowContainer_inplace_merge takes integer this returns nothing
   endfunction

			/// @state untested
			/// iterator max_element( iterator start, iterator end );
			/// iterator max_element( iterator start, iterator end, BinPred p );
			/// Sucht mit Hilfe einer benutzerdefinierten Vergleichsfunktion nach dem größten Element in einem Elementebereich.
			/// Das Prädikat stellt in diesem Fall den <-Operator dar.
			/// @param start Startposition
			/// @param number Anzahl der Elemente
			/// @param binaryPredicate Benutzerdefinierte Vergleichsfunktion
			/// @return Index des größten Elements
   function s__AMainWindowContainer_max_element takes integer this,integer start,integer number,integer binaryPredicate returns integer
    local integer i= start + 1
    local integer exitValue= start + number
    local integer result= start
     call s__AMainWindowContainer_debugCheckStartAndNumber(this,start , number)
				loop
					exitwhen ( i == exitValue )
						//x < y
						if ( sc___prototype834_evaluate(binaryPredicate,s___AMainWindowContainer_element[s__AMainWindowContainer_element[this]+result] , s___AMainWindowContainer_element[s__AMainWindowContainer_element[this]+i]) ) then
							set result = i
						endif
					set i = i + 1
				endloop
				return result
   endfunction

			//iterator min_element( iterator start, iterator end );
			//iterator min_element( iterator start, iterator end, BinPred p );
			/// Sucht mit Hilfe einer benutzerdefinierten Vergleichsfunktion nach dem kleinsten Element in einem Elementebereich.
			/// Das Prädikat stellt in diesem Fall den <-Operator dar.
			/// @param start Startposition
			/// @param number Anzahl der Elemente
			/// @param binaryPredicate Benutzerdefinierte Vergleichsfunktion
			/// @return Index des kleinsten Elements
   function s__AMainWindowContainer_min_element takes integer this,integer start,integer number,integer binaryPredicate returns integer
    local integer i= start + 1
    local integer exitValue= start + number
    local integer result= start
     call s__AMainWindowContainer_debugCheckStartAndNumber(this,start , number)
				loop
					exitwhen ( i == exitValue )
						//x < y
						if ( sc___prototype834_evaluate(binaryPredicate,s___AMainWindowContainer_element[s__AMainWindowContainer_element[this]+i] , s___AMainWindowContainer_element[s__AMainWindowContainer_element[this]+result]) ) then
							set result = i
						endif
					set i = i + 1
				endloop
				return result
   endfunction

			/// Mit dem []-Operator kann man auf ein Element des Containers zugreifen.
			/// @param index Index des Elements
			/// @return Das Element
   function s__AMainWindowContainer__getindex takes integer this,integer index returns integer
				return s__AMainWindowContainer_getElement(this,index)
   endfunction

			/// Mit dem []=-Operator kann man einem Element des Containers einen Wert zuweisen.
			/// @param index Index des Elements
			/// @param value Zuzuweisender Wert
   function s__AMainWindowContainer__setindex takes integer this,integer index,integer value returns nothing
				call s__AMainWindowContainer_setElement(this,index , value)
   endfunction

			/// Mit dem <-Operator kann man prüfen, ob der Container eine kleinere Größe als ein anderer hat.
			/// @param destination Vergleichs-Container
			/// @return Gibt wahr zurück, wenn der Container eine kleinere Größe als der Ziel-Container hat.
   function s__AMainWindowContainer__lessthan takes integer this,integer destination returns boolean
				return s___AMainWindowContainer_element_size < s___AMainWindowContainer_element_size
   endfunction

			// Mit dem >-Operator kann man prüfen, ob der Container eine größere Größe als ein anderer hat.
			// @param destination Vergleichs-Container
			// @return Gibt wahr zurück, wenn der Container eine kleinere Größe als der Ziel-Container hat.
			//public method operator> takes AMainWindowContainer destination returns boolean
				//return this.size > destionation.size
			//endmethod

		//Basic algorithm

		//The binary predicate represents the < operator.
		//function AMax takes AMainWindow x, AMainWindow y, AMainWindowContainerBinaryPredicate binaryPredicate returns $ELEMENTTYPE
		//	if (binaryPredicate.evaluate(x, y)) then
		//		return y
		//	endif
		//	return x
		//endfunction

		//function AMin takes AMainWindow x, AMainWindow y, AMainWindowContainerBinaryPredicate binaryPredicate returns $ELEMENTTYPE
		//	if (binaryPredicate.evaluate(x, y)) then
		//		return x
		//	endif
		//	return y
		//endfunction
//end of: A_CONTAINER("AMainWindow", "MainWindow", "4")

	/// @todo Should be a static member of @struct AGui, vJass bug.
	/// This is the generic shortcut function interface.
	/// @param id Id of the object which belongs to the function call.
//processed: 	function interface AGuiOnPressShortcutAction takes integer id returns nothing

	/// @todo Should be a static member of @struct AGui, vJass bug.
	/// If you want to use an explicit gui action use this.
//processed: 	function interface AGuiOnPressGuiShortcutAction takes AGui gui returns nothing

	/// @todo Should be a static method of @struct AGui, vJass bug.
	/// Represents the generic function interface for dialog button actions.
//processed: 	function interface AGuiDialogButtonAction takes AGui gui, integer index returns nothing

	/// @todo Should be a static method of @struct AGui, vJass bug.
 function AStructSystemsGuiGui__unaryFunctionDestroyMainWindow takes integer element returns nothing
		//saver
		if ( element != 0 ) then
			call sc__AMainWindow_destroy(element)
		endif
	endfunction

	/// AGui represents the graphical user interface which can be used by every player.
	/// Each player can have exactly one GUI.
	/// A GUI contains main windows which are user-defined areas on the map. That's necessary because
	/// trackables, textes and images are map-placed objects.
	/// When you destroy an instance of AGui all docked main windows will be destroy automatically.
		//static constant members
		//static start members
		//static dynamic members
		//static members
		//dynamic members
		//start members
		//members

//textmacro instance: A_STRUCT_DEBUG("\"AGui\"")
   function s__AGui_print takes integer this,string message returns nothing
    call Print("AGui" + " - " + I2S(this) + ": " + message)
   endfunction

   function s__AGui_staticPrint takes string message returns nothing
    call Print("AGui" + ": " + message)
   endfunction
//end of: A_STRUCT_DEBUG("\"AGui\"")

		//dynamic members

		/// Each shortcut (including special shortcuts) can have its own action.
		/// Additionally you can add shortcuts to widgets that they'll get the widgets action automatically.
  function s__AGui_setOnPressShortcutAction takes integer this,integer shortcut,integer onPressShortcutAction,integer id returns nothing
			if ( ( shortcut >= 0 ) and ( shortcut < s__AGui_maxSpecialShortcuts ) ) then
				call sc__AGui_createSpecialShortcutTrigger(this,shortcut)
			endif
			set s___AGui_onPressShortcutAction[s__AGui_onPressShortcutAction[this]+shortcut]=onPressShortcutAction
			set s___AGui_onPressShortcutActionId[s__AGui_onPressShortcutActionId[this]+shortcut]=id
  endfunction

		/// Convenience method.
		/// Assigns a function to a shortcut. The function gets the AGui instance as argument.
  function s__AGui_setOnPressGuiShortcutAction takes integer this,integer shortcut,integer onPressGuiShortcutAction returns nothing
			call s__AGui_setOnPressShortcutAction(this,shortcut , onPressGuiShortcutAction , this)
  endfunction

		//start members

  function s__AGui_getUser takes integer this returns player
			return s__AGui_user[this]
  endfunction

		//methods

		/// @todo desynchronisation?
		/// Saves GUI users camera data and selection in game.
  function s__AGui_savePlayerData takes integer this returns nothing
			set s__AGui_playerDataCameraX[this]=GetCameraTargetPositionXOfPlayer(s__AGui_user[this]) //ALibraryInterfaceCamera
			set s__AGui_playerDataCameraY[this]=GetCameraTargetPositionYOfPlayer(s__AGui_user[this]) //ALibraryInterfaceCamera
			set s__AGui_playerDataSelection[this]=GetUnitsSelectedAll(s__AGui_user[this])
  endfunction

		/// Loads GUI users camera data and selection from time before he has enabled the GUI.
  function s__AGui_loadPlayerData takes integer this returns nothing
			call PanCameraToForPlayer(s__AGui_user[this] , s__AGui_playerDataCameraX[this] , s__AGui_playerDataCameraY[this])
			call SelectGroupForPlayerBJ(s__AGui_playerDataSelection[this] , s__AGui_user[this])
			call DestroyGroup(s__AGui_playerDataSelection[this])
			set s__AGui_playerDataSelection[this]=null
  endfunction

		/// If you dock a main window it will be destroyed when the GUI will be destroyed.
		/// Friend relation to AMainWindow. In general you do not need to use this method.
		/// @return Container index.
  function s__AGui_dockMainWindow takes integer this,integer mainWindow returns integer
   local integer i= 0
			loop
				exitwhen ( i == s__AGui_maxMainWindows )
				if ( s__AMainWindowContainer__getindex(s__AGui_container[this],i) == 0 ) then
					call s__AMainWindowContainer__setindex(s__AGui_container[this],i, mainWindow)
					return i
				endif
				set i = i + 1
			endloop
    call s__AGui_print(this,"Could not dock main window " + I2S(mainWindow) + ". Maximum reached.")
			return - 1
  endfunction

		/// Undocks a main window from GUI. If a main window is undocked there won't be any relationships between it and the GUI anymore.
  function s__AGui_undockMainWindow takes integer this,integer mainWindow returns nothing
   local integer i= 0
			loop
				exitwhen ( i == s__AGui_maxMainWindows )
				if ( s__AMainWindowContainer__getindex(s__AGui_container[this],i) == mainWindow ) then
					call s__AMainWindowContainer__setindex(s__AGui_container[this],i, 0)
					return 
				endif
				set i = i + 1
			endloop
    call s__AGui_print(this,"Could not undock main window " + I2S(mainWindow) + ". Main window was not found.")
  endfunction

  function s__AGui_showMainWindowByIndex takes integer this,integer index returns nothing
			call sc__AMainWindow_show(s__AMainWindowContainer__getindex(s__AGui_container[this],index))
  endfunction

		/// @todo Friend relation to @struct AMainWindow, do not use!
  function s__AGui_hideShownMainWindowAndSetNew takes integer this,integer mainWindow returns nothing
			if ( s__AGui_shownMainWindow[this] != 0 ) then
				call sc__AMainWindow_hide(s__AGui_shownMainWindow[this])
			endif
			set s__AGui_shownMainWindow[this]=mainWindow
  endfunction

  function s__AGui_enableShortcuts takes integer this returns nothing
   local integer i
			call PauseUnit(s__AGui_shortcutHandler[this] , false)
			call SelectUnitForPlayerSingle(s__AGui_shortcutHandler[this] , s__AGui_user[this])
			call EnableTrigger(s__AGui_shortcutHandleTrigger[this])
			call sc__AGui_enableSpecialShortcutTriggers(this)
			set i = 0
			loop
				exitwhen ( i == s__AGui_maxShortcuts )
				if ( s___AGui_onPressShortcutActionId[s__AGui_onPressShortcutActionId[this]+i] != 0 ) then
					call UnitAddAbility(s__AGui_shortcutHandler[this] , s__s__AGui_shortcutAbility[i])
				endif
				set i = i + 1
			endloop
  endfunction

		/// Resets all shortcut actions!
  function s__AGui_disableShortcuts takes integer this returns nothing
   local integer i
			call PauseUnit(s__AGui_shortcutHandler[this] , true)
			call SelectUnitRemoveForPlayer(s__AGui_shortcutHandler[this] , s__AGui_user[this])
			call DisableTrigger(s__AGui_shortcutHandleTrigger[this])
			call sc__AGui_disableSpecialShortcutTriggers(this)
			
			set i = 0
			loop
				exitwhen ( i == s__AGui_maxShortcuts )
				if ( s___AGui_onPressShortcutActionId[s__AGui_onPressShortcutActionId[this]+i] != 0 ) then
					call UnitRemoveAbility(s__AGui_shortcutHandler[this] , s__s__AGui_shortcutAbility[i])
				endif
				set s___AGui_onPressShortcutActionId[s__AGui_onPressShortcutActionId[this]+i]=0
				set i = i + 1
			endloop
  endfunction

  function s__AGui_clearDialog takes integer this returns nothing
   local integer i= 0
			loop
				exitwhen ( i == s__AGui_dialogButtons[this] )
					set s___AGui_dialogButton[s__AGui_dialogButton[this]+i]=null
				set i = i + 1
			endloop
			call DialogClear(s__AGui_usedDialog[this])
			set s__AGui_dialogButtons[this]=0
  endfunction

		/// @todo Check the maxLineLength argument. InsertLineBreaks is bugged.
  function s__AGui_setDialogTitle takes integer this,string title returns nothing
			call DialogSetMessage(s__AGui_usedDialog[this] , title) //InsertLineBreaks(title, 10) //ALibraryStringConversion
  endfunction

  function s__AGui_showDialog takes integer this returns nothing
			call DialogDisplay(s__AGui_user[this] , s__AGui_usedDialog[this] , true)
  endfunction

  function s__AGui_hideDialog takes integer this returns nothing
			call DialogDisplay(s__AGui_user[this] , s__AGui_usedDialog[this] , false)
  endfunction

  function s__AGui_addDialogButton takes integer this,string text,integer shortcut,integer dialogButtonAction returns integer
   local integer id
			if ( s__AGui_dialogButtons[this] >= s__AGui_maxDialogButtons ) then
				return - 1
			endif
			set id = s__AGui_dialogButtons[this]
			set s___AGui_dialogButton[s__AGui_dialogButton[this]+id]=DialogAddButton(s__AGui_usedDialog[this] , text , shortcut)
			set s___AGui_dialogButtonAction[s__AGui_dialogButtonAction[this]+id]=dialogButtonAction
			set s__AGui_dialogButtons[this]=id + 1
			call sc__AGui_createDialogButtonTrigger(this,id)
			return id
  endfunction

		/// Convenience method.
		/// Shows a simple dialog with an OK button.
		/// @param text Displayed text.
  function s__AGui_showInfoDialog takes integer this,string text returns nothing
			call s__AGui_clearDialog(this)
			call s__AGui_setDialogTitle(this,text)
			call s__AGui_addDialogButton(this,s__AGui_textOk , 'O' , 0)
			call s__AGui_showDialog(this)
  endfunction

  function s__AGui_enableSpecialShortcutTriggers takes integer this returns nothing
   local integer i= 0
			loop
				exitwhen ( i == s__AGui_maxSpecialShortcuts )
					if ( s___AGui_specialShortcutHandleTrigger[s__AGui_specialShortcutHandleTrigger[this]+i] != null ) then
						call EnableTrigger(s___AGui_specialShortcutHandleTrigger[s__AGui_specialShortcutHandleTrigger[this]+i])
					endif
				set i = i + 1
			endloop
  endfunction

  function s__AGui_disableSpecialShortcutTriggers takes integer this returns nothing
   local integer i= 0
			loop
				exitwhen ( i == s__AGui_maxSpecialShortcuts )
					if ( s___AGui_specialShortcutHandleTrigger[s__AGui_specialShortcutHandleTrigger[this]+i] != null ) then
						call DisableTrigger(s___AGui_specialShortcutHandleTrigger[s__AGui_specialShortcutHandleTrigger[this]+i])
					endif
				set i = i + 1
			endloop
  endfunction

  function s__AGui_triggerActionPlayerLeaves takes nothing returns nothing
   local player triggerPlayer= GetTriggerPlayer()
			call sc__AGui_destroy(s__AGui_playerGui[GetPlayerId(triggerPlayer)])
			set triggerPlayer = null
  endfunction

  function s__AGui_createLeaveTrigger takes integer this returns nothing
   local event triggerEvent
   local triggeraction triggerAction
			set s__AGui_leaveTrigger[this]=CreateTrigger()
			set triggerEvent = TriggerRegisterPlayerEvent(s__AGui_leaveTrigger[this] , s__AGui_user[this] , EVENT_PLAYER_LEAVE)
			set triggerAction = TriggerAddAction(s__AGui_leaveTrigger[this] , function s__AGui_triggerActionPlayerLeaves)
			set triggerEvent = null
			set triggerAction = null
  endfunction

  function s__AGui_createShortcutHandler takes integer this returns nothing
			set s__AGui_shortcutHandler[this]=CreateUnit(s__AGui_user[this] , s__AGui_shortcutHandlerUnitType , s__AGui_shortcutHandlerX , s__AGui_shortcutHandlerY , 0.0)
			call SetUnitInvulnerable(s__AGui_shortcutHandler[this] , true)
  endfunction

  function s__AGui_triggerActionOnPressShortcut takes nothing returns nothing
   local integer i
   local integer abilityId= GetSpellAbilityId()
   local trigger triggeringTrigger
   local integer gui
    call Print("SHORTCUT TRIGGER with Ability " + I2S(abilityId))
			set i = 'a'
			loop
				exitwhen ( i == s__AGui_maxShortcuts )
				if ( abilityId == s__s__AGui_shortcutAbility[i] ) then
      call Print("EXIT!!!! " + I2S(i))
					set triggeringTrigger = GetTriggeringTrigger()
					set gui = s__AHashTable_getHandleInteger(AGetInterfaceHashTable(),triggeringTrigger , "gui") //AClassInterfaceInterfaceHashTable
      if ( s___AGui_onPressShortcutAction[s__AGui_onPressShortcutAction[gui]+i] != 0 ) then
       call Print("Action exists")
      endif
					call sc___prototype789_execute(s___AGui_onPressShortcutAction[s__AGui_onPressShortcutAction[gui]+i],s___AGui_onPressShortcutActionId[s__AGui_onPressShortcutActionId[gui]+i])
					set triggeringTrigger = null
					exitwhen ( true )
				endif
				set i = i + 1
			endloop
  endfunction

  function s__AGui_createShortcutHandleTrigger takes integer this returns nothing
   local event triggerEvent
   local triggeraction triggerAction
			set s__AGui_shortcutHandleTrigger[this]=CreateTrigger()
			set triggerEvent = TriggerRegisterUnitEvent(s__AGui_shortcutHandleTrigger[this] , s__AGui_shortcutHandler[this] , EVENT_UNIT_SPELL_CAST)
			set triggerAction = TriggerAddAction(s__AGui_shortcutHandleTrigger[this] , function s__AGui_triggerActionOnPressShortcut)
			call s__AHashTable_storeHandleInteger(AGetInterfaceHashTable(),s__AGui_shortcutHandleTrigger[this] , "gui" , this) //AClassInterfaceInterfaceHashTable
			set triggerEvent = null
			set triggerAction = null
  endfunction

  function s__AGui_triggerActionOnPressSpecialShortcut takes nothing returns nothing
   local trigger triggeringTrigger= GetTriggeringTrigger()
   local integer gui= s__AHashTable_getHandleInteger(AGetInterfaceHashTable(),triggeringTrigger , "gui")
   local integer shortcut= s__AHashTable_getHandleInteger(AGetInterfaceHashTable(),triggeringTrigger , "shortcut")
    call Print("SHORTCUT " + I2S(shortcut))
			call sc___prototype789_execute(s___AGui_onPressShortcutAction[s__AGui_onPressShortcutAction[gui]+shortcut],gui)
			set triggeringTrigger = null
  endfunction

		/// This method won't be called in the constructor.
		/// It is a dynamic creation.
  function s__AGui_createSpecialShortcutTrigger takes integer this,integer shortcut returns nothing
   local event triggerEvent
   local triggeraction triggerAction
			//don't check if the action is 0, it can be changed dynamicly!
			//the trigger can't be changed dynamicly
			if ( s___AGui_specialShortcutHandleTrigger[s__AGui_specialShortcutHandleTrigger[this]+shortcut] == null ) then
				set s___AGui_specialShortcutHandleTrigger[s__AGui_specialShortcutHandleTrigger[this]+shortcut]=CreateTrigger()
				if ( shortcut == s__AGui_shortcutArrowUpDown ) then
					set triggerEvent = TriggerRegisterPlayerEvent(s___AGui_specialShortcutHandleTrigger[s__AGui_specialShortcutHandleTrigger[this]+shortcut] , s__AGui_user[this] , EVENT_PLAYER_ARROW_UP_DOWN)
				elseif ( shortcut == s__AGui_shortcutArrowDownDown ) then
					set triggerEvent = TriggerRegisterPlayerEvent(s___AGui_specialShortcutHandleTrigger[s__AGui_specialShortcutHandleTrigger[this]+shortcut] , s__AGui_user[this] , EVENT_PLAYER_ARROW_DOWN_DOWN)
				elseif ( shortcut == s__AGui_shortcutArrowLeftDown ) then
					set triggerEvent = TriggerRegisterPlayerEvent(s___AGui_specialShortcutHandleTrigger[s__AGui_specialShortcutHandleTrigger[this]+shortcut] , s__AGui_user[this] , EVENT_PLAYER_ARROW_LEFT_DOWN)
				elseif ( shortcut == s__AGui_shortcutArrowRightDown ) then
					set triggerEvent = TriggerRegisterPlayerEvent(s___AGui_specialShortcutHandleTrigger[s__AGui_specialShortcutHandleTrigger[this]+shortcut] , s__AGui_user[this] , EVENT_PLAYER_ARROW_RIGHT_DOWN)
				elseif ( shortcut == s__AGui_shortcutArrowUpUp ) then
					set triggerEvent = TriggerRegisterPlayerEvent(s___AGui_specialShortcutHandleTrigger[s__AGui_specialShortcutHandleTrigger[this]+shortcut] , s__AGui_user[this] , EVENT_PLAYER_ARROW_UP_UP)
				elseif ( shortcut == s__AGui_shortcutArrowDownUp ) then
					set triggerEvent = TriggerRegisterPlayerEvent(s___AGui_specialShortcutHandleTrigger[s__AGui_specialShortcutHandleTrigger[this]+shortcut] , s__AGui_user[this] , EVENT_PLAYER_ARROW_DOWN_UP)
				elseif ( shortcut == s__AGui_shortcutArrowLeftUp ) then
					set triggerEvent = TriggerRegisterPlayerEvent(s___AGui_specialShortcutHandleTrigger[s__AGui_specialShortcutHandleTrigger[this]+shortcut] , s__AGui_user[this] , EVENT_PLAYER_ARROW_LEFT_UP)
				elseif ( shortcut == s__AGui_shortcutArrowRightUp ) then
					set triggerEvent = TriggerRegisterPlayerEvent(s___AGui_specialShortcutHandleTrigger[s__AGui_specialShortcutHandleTrigger[this]+shortcut] , s__AGui_user[this] , EVENT_PLAYER_ARROW_RIGHT_UP)
				elseif ( shortcut == s__AGui_shortcutEscape ) then
					set triggerEvent = TriggerRegisterPlayerEvent(s___AGui_specialShortcutHandleTrigger[s__AGui_specialShortcutHandleTrigger[this]+shortcut] , s__AGui_user[this] , EVENT_PLAYER_END_CINEMATIC)
				endif
				set triggerAction = TriggerAddAction(s___AGui_specialShortcutHandleTrigger[s__AGui_specialShortcutHandleTrigger[this]+shortcut] , function s__AGui_triggerActionOnPressSpecialShortcut)
				call s__AHashTable_storeHandleInteger(AGetInterfaceHashTable(),s___AGui_specialShortcutHandleTrigger[s__AGui_specialShortcutHandleTrigger[this]+shortcut] , "gui" , this) //AClassInterfaceInterfaceHashTable
				call s__AHashTable_storeHandleInteger(AGetInterfaceHashTable(),s___AGui_specialShortcutHandleTrigger[s__AGui_specialShortcutHandleTrigger[this]+shortcut] , "shortcut" , shortcut) //AClassInterfaceInterfaceHashTable
				set triggerEvent = null
				set triggerAction = null
			endif
  endfunction

  function s__AGui_triggerActionRunDialogButtonAction takes nothing returns nothing
   local trigger triggeringTrigger= GetTriggeringTrigger()
   local integer gui= s__AHashTable_getHandleInteger(AGetInterfaceHashTable(),triggeringTrigger , "gui") //AClassInterfaceInterfaceHashTable
   local integer index= s__AHashTable_getHandleInteger(AGetInterfaceHashTable(),triggeringTrigger , "index") //AClassInterfaceInterfaceHashTable
			call sc___prototype838_execute(s___AGui_dialogButtonAction[s__AGui_dialogButtonAction[gui]+index],gui , index)
			set triggeringTrigger = null
  endfunction

  function s__AGui_createDialogButtonTrigger takes integer this,integer index returns nothing
   local event triggerEvent
   local triggeraction triggerAction
			if ( ( s__AGui_dialogButtonTrigger[this] == null ) and ( s___AGui_dialogButtonAction[s__AGui_dialogButtonAction[this]+index] != 0 ) ) then
				set s___AGui_dialogButtonTrigger[s__AGui_dialogButtonTrigger[this]+index]=CreateTrigger()
				set triggerEvent = TriggerRegisterDialogButtonEvent(s___AGui_dialogButtonTrigger[s__AGui_dialogButtonTrigger[this]+index] , s___AGui_dialogButton[s__AGui_dialogButton[this]+index])
				set triggerAction = TriggerAddAction(s___AGui_dialogButtonTrigger[s__AGui_dialogButtonTrigger[this]+index] , function s__AGui_triggerActionRunDialogButtonAction)
				call s__AHashTable_storeHandleInteger(AGetInterfaceHashTable(),s___AGui_dialogButtonTrigger[s__AGui_dialogButtonTrigger[this]+index] , "gui" , this) //AClassInterfaceInterfaceHashTable
				call s__AHashTable_storeHandleInteger(AGetInterfaceHashTable(),s___AGui_dialogButtonTrigger[s__AGui_dialogButtonTrigger[this]+index] , "index" , index) //AClassInterfaceInterfaceHashTable
				set triggerEvent = null
				set triggerAction = null
			endif
  endfunction

		/// Don't use the constructor.
		/// Use @method getPlayerGui.
		/// Shortcuts will be disabled first.
  function s__AGui_create takes player user returns integer
   local integer this= s__AGui__allocate()
			//start members
			set s__AGui_user[this]=user
			//members
			set s__AGui_container[this]=s__AMainWindowContainer__allocate()
			set s__AGui_shownMainWindow[this]=0
			set s__AGui_usedDialog[this]=DialogCreate()
			set s__AGui_dialogButtons[this]=0

			call s__AGui_createLeaveTrigger(this)
			call s__AGui_createShortcutHandler(this)
			call s__AGui_createShortcutHandleTrigger(this)
			call s__AGui_disableShortcuts(this)
			return this
  endfunction

  function s__AGui_destroyDockedMainWindows takes integer this returns nothing
			call s__AMainWindowContainer_forEach(s__AGui_container[this],0 , s__AGui_maxMainWindows , (1))
  endfunction

  function s__AGui_destroyDialogButtons takes integer this returns nothing
   local integer i= 0
			loop
				exitwhen ( i == s__AGui_maxDialogButtons )
				set s___AGui_dialogButton[s__AGui_dialogButton[this]+i]=null
				set i = i + 1
			endloop
  endfunction

  function s__AGui_destroyLeaveTrigger takes integer this returns nothing
			call DestroyTrigger(s__AGui_leaveTrigger[this])
			set s__AGui_leaveTrigger[this]=null
  endfunction

  function s__AGui_removeShortcutHandler takes integer this returns nothing
			call RemoveUnit(s__AGui_shortcutHandler[this])
			set s__AGui_shortcutHandler[this]=null
  endfunction

  function s__AGui_destroyShortcutHandleTrigger takes integer this returns nothing
			call s__AHashTable_destroyTrigger(AGetInterfaceHashTable(),s__AGui_shortcutHandleTrigger[this])
			set s__AGui_shortcutHandleTrigger[this]=null
  endfunction

  function s__AGui_destroySpecialShortcutTriggers takes integer this returns nothing
   local integer i= 0
			loop
				exitwhen ( i == s__AGui_maxSpecialShortcuts )
					if ( s___AGui_specialShortcutHandleTrigger[s__AGui_specialShortcutHandleTrigger[this]+i] != null ) then
						call s__AHashTable_destroyTrigger(AGetInterfaceHashTable(),s___AGui_specialShortcutHandleTrigger[s__AGui_specialShortcutHandleTrigger[this]+i])
						set s___AGui_specialShortcutHandleTrigger[s__AGui_specialShortcutHandleTrigger[this]+i]=null
					endif
				set i = i + 1
			endloop
  endfunction

  function s__AGui_destroyDialogButtonTriggers takes integer this returns nothing
   local integer i= 0
			loop
				exitwhen ( i == s__AGui_maxDialogButtons )
				if ( s___AGui_dialogButtonTrigger[s__AGui_dialogButtonTrigger[this]+i] != null ) then
					call s__AHashTable_destroyTrigger(AGetInterfaceHashTable(),s___AGui_dialogButtonTrigger[s__AGui_dialogButtonTrigger[this]+i])
					set s___AGui_dialogButtonTrigger[s__AGui_dialogButtonTrigger[this]+i]=null
				endif
				set i = i + 1
			endloop
  endfunction

		/// Will be destroyed when player leaves the game.
  function s__AGui_onDestroy takes integer this returns nothing
			//elements
			call s__AGui_destroyDockedMainWindows(this)
			call s__AMainWindowContainer_destroy(s__AGui_container[this])
			call s__AGui_clearDialog(this)
			call DialogDestroy(s__AGui_usedDialog[this])
			set s__AGui_usedDialog[this]=null

			call s__AGui_destroyDialogButtons(this)
			call s__AGui_destroyLeaveTrigger(this)
			call s__AGui_removeShortcutHandler(this)
			call s__AGui_destroyShortcutHandleTrigger(this)
			call s__AGui_destroySpecialShortcutTriggers(this)
			call s__AGui_destroyDialogButtonTriggers(this)
  endfunction

//Generated destructor of AGui
function s__AGui_destroy takes integer this returns nothing
    if this==null then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: AGui")
        return
    elseif (si__AGui_V[this]!=-1) then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: AGui")
        return
    endif
    call s__AGui_onDestroy(this)
    set si__AGui_V[this]=si__AGui_F
    set si__AGui_F=this
endfunction

		/// @param shortcutHandlerUnitType The unit type of the unit which is selected during the display time of the GUI. It should have all shortcut abilities.
		/// @param shortcutHandlerX The x coordinate of the shortcut handlers position.
		/// @param shortcutHandlerY The y coordinate of the shortcut handlers position.
		/// @param textOk The text which is displayed as Ok text.
  function s__AGui_init takes integer shortcutHandlerUnitType,real shortcutHandlerX,real shortcutHandlerY,string textOk returns nothing
   local integer i
			//static start members
			set s__AGui_shortcutHandlerUnitType=shortcutHandlerUnitType
			set s__AGui_shortcutHandlerX=shortcutHandlerX
			set s__AGui_shortcutHandlerY=shortcutHandlerY
			set s__AGui_textOk=textOk
  endfunction

		//static dynamic members

  function s__AGui_setShortcutAbility takes integer shortcutAbility,integer abilityId returns nothing
			set s__s__AGui_shortcutAbility[shortcutAbility]= abilityId
  endfunction

  function s__AGui_getShortcutAbility takes integer shortcutAbility returns integer
			return s__s__AGui_shortcutAbility[shortcutAbility]
  endfunction

		//static methods

  function s__AGui_getPlayerGui takes player user returns integer
			if ( s__AGui_playerGui[GetPlayerId(user)] == 0 ) then
     call Print("Create gui for player " + GetPlayerName(user))
				set s__AGui_playerGui[GetPlayerId(user)]=s__AGui_create(user) //If you forget [GetPlayerId(user)] there is a jasshelper error
			endif
			return s__AGui_playerGui[GetPlayerId(user)]
  endfunction

		//static convenience methods
		
  function s__AGui_setOnPressGuiShortcutActionForAll takes integer shortcut,integer onPressGuiShortcutAction returns nothing
   local integer i
   local player user
			set i = 0
			loop
				exitwhen ( i == bj_MAX_PLAYERS )
				set user = Player(i)
				if ( IsPlayerPlayingUser(user) ) then
					call s__AGui_setOnPressGuiShortcutAction(s__AGui_getPlayerGui(user),shortcut , onPressGuiShortcutAction)
				endif
				set user = null
				set i = i + 1
			endloop
  endfunction
		
  function s__AGui_showInfoDialogToAll takes string text returns nothing
   local integer i
   local player user
			set i = 0
			loop
				exitwhen ( i == bj_MAX_PLAYERS )
				set user = Player(i)
				if ( IsPlayerPlayingUser(user) ) then
					call s__AGui_showInfoDialog(s__AGui_getPlayerGui(user),text)
				endif
				set user = null
				set i = i + 1
			endloop
  endfunction


//library AStructSystemsGuiGui ends
//library AStructSystemsWorldRoutine:

	/// @todo Should be a part of @struct ARoutine, vJass bug.
//processed: 	function interface ARoutineAction takes ARoutine routine returns nothing

	/// ARoute provides NPC routine handling like in the game Gothic or Gothic II.
	/// You are able to assign day times and routine actions using the function interface @functioninterface ARouteAction.
	/// Additionally you can make periodic routines by setting a 'run rate'.
	/// If the assigned unit is paused, routine won't be runned until unit gets unpaused.
		//start members
		//members

		//start members

		//You will need this in the routine action
  function s__ARoutine_getUsedUnit takes integer this returns unit
			return s__ARoutine_usedUnit[this]
  endfunction

		//methods

  function s__ARoutine_enable takes integer this returns nothing
			if ( s__ARoutine_runRate[this] > 0.0 ) then
				call EnableTrigger(s__ARoutine_runTrigger[this])
				call EnableTrigger(s__ARoutine_disableTrigger[this])
			endif
			call EnableTrigger(s__ARoutine_enableTrigger[this])
  endfunction

  function s__ARoutine_disable takes integer this returns nothing
			if ( s__ARoutine_runRate[this] > 0.0 ) then
				call DisableTrigger(s__ARoutine_runTrigger[this])
				call DisableTrigger(s__ARoutine_disableTrigger[this])
			endif
			call DisableTrigger(s__ARoutine_enableTrigger[this])
  endfunction

  function s__ARoutine_isInTime takes integer this returns boolean
			return GetFloatGameState(GAME_STATE_TIME_OF_DAY) <= s__ARoutine_endTimeOfDay[this] //n�chsten Tag eintragen, wenn Endzeit kleiner oder gleich der Startzeit ist
  endfunction

		//Call PauseUnit if you want to stop the routine.
  function s__ARoutine_isAbleToMove takes integer this returns boolean
			return not IsUnitPaused(s__ARoutine_usedUnit[this])
  endfunction

  function s__ARoutine_run takes integer this returns nothing
			call sc___prototype839_execute(s__ARoutine_routineAction[this],this)
  endfunction
		
  function s__ARoutine_runCondition takes nothing returns boolean
   local trigger triggeringTrigger= GetTriggeringTrigger()
   local integer routine= s__AHashTable_getHandleInteger(AGetWorldHashTable(),triggeringTrigger , "routine") //AStructWorldWorldHashTable
   local boolean result= s__ARoutine_isAbleToMove(routine)
			set triggeringTrigger = null
			return result
  endfunction

  function s__ARoutine_runAction takes nothing returns nothing
   local trigger triggeringTrigger= GetTriggeringTrigger()
   local integer routine= s__AHashTable_getHandleInteger(AGetWorldHashTable(),triggeringTrigger , "routine") //AStructWorldWorldHashTable
			call s__ARoutine_run(routine)
			set triggeringTrigger = null
  endfunction

  function s__ARoutine_createRunTrigger takes integer this returns nothing
   local event triggerEvent
   local conditionfunc conditionFunction
   local triggercondition triggerCondition
   local triggeraction triggerAction
			if ( s__ARoutine_runRate[this] > 0.0 ) then
				set s__ARoutine_runTrigger[this]=CreateTrigger()
				set triggerEvent = TriggerRegisterTimerEvent(s__ARoutine_runTrigger[this] , s__ARoutine_runRate[this] , true)
				set conditionFunction = Condition(function s__ARoutine_runCondition)
				set triggerCondition = TriggerAddCondition(s__ARoutine_runTrigger[this] , conditionFunction)
				set triggerAction = TriggerAddAction(s__ARoutine_runTrigger[this] , function s__ARoutine_runAction)
				call s__AHashTable_storeHandleInteger(AGetWorldHashTable(),s__ARoutine_runTrigger[this] , "routine" , this) //AStructWorldWorldHashTable
				set triggerEvent = null
				set conditionFunction = null
				set triggerCondition = null
				set triggerAction = null
			endif
  endfunction

  function s__ARoutine_triggerActionEnable takes nothing returns nothing
   local trigger triggeringTrigger= GetTriggeringTrigger()
   local integer routine= s__AHashTable_getHandleInteger(AGetWorldHashTable(),triggeringTrigger , "routine") //AStructWorldWorldHashTable
			if ( s__ARoutine_runRate[routine] > 0.0 ) then
				call EnableTrigger(s__ARoutine_runTrigger[routine])
			else
				call s__ARoutine_run(routine)
			endif
			set triggeringTrigger = null
  endfunction

  function s__ARoutine_createEnableTrigger takes integer this returns nothing
   local event triggerEvent
   local triggeraction triggerAction
			set s__ARoutine_enableTrigger[this]=CreateTrigger()
			set triggerEvent = TriggerRegisterGameStateEvent(s__ARoutine_enableTrigger[this] , GAME_STATE_TIME_OF_DAY , EQUAL , s__ARoutine_startTimeOfDay[this])
			set triggerAction = TriggerAddAction(s__ARoutine_enableTrigger[this] , function s__ARoutine_triggerActionEnable)
			call s__AHashTable_storeHandleInteger(AGetWorldHashTable(),s__ARoutine_enableTrigger[this] , "routine" , this) //AStructWorldWorldHashTable
			set triggerEvent = null
			set triggerAction = null
  endfunction

  function s__ARoutine_triggerActionDisable takes nothing returns nothing
   local trigger triggeringTrigger= GetTriggeringTrigger()
   local integer routine= s__AHashTable_getHandleInteger(AGetWorldHashTable(),triggeringTrigger , "routine") //AStructWorldWorldHashTable
			call DisableTrigger(s__ARoutine_runTrigger[routine])
			set triggeringTrigger = null
  endfunction

  function s__ARoutine_createDisableTrigger takes integer this returns nothing
   local event triggerEvent
   local triggeraction triggerAction
			if ( s__ARoutine_runRate[this] > 0.0 ) then
				set s__ARoutine_disableTrigger[this]=CreateTrigger()
				set triggerEvent = TriggerRegisterGameStateEvent(s__ARoutine_disableTrigger[this] , GAME_STATE_TIME_OF_DAY , EQUAL , s__ARoutine_endTimeOfDay[this])
				set triggerAction = TriggerAddAction(s__ARoutine_disableTrigger[this] , function s__ARoutine_triggerActionDisable)
				call s__AHashTable_storeHandleInteger(AGetWorldHashTable(),s__ARoutine_disableTrigger[this] , "routine" , this) //AStructWorldWorldHashTable
				set triggerEvent = null
				set triggerAction = null
			endif
  endfunction

		/// Usually it will be runned when the assigned time of day is reached.
		/// @param runRate If runRate is <= 0.0 action won't be runned at an interval.
  function s__ARoutine_create takes unit usedUnit,real startTimeOfDay,real endTimeOfDay,real runRate,integer routineAction returns integer
   local integer this= s__ARoutine__allocate()
			//start members
			set s__ARoutine_usedUnit[this]=usedUnit
			set s__ARoutine_startTimeOfDay[this]=startTimeOfDay
			set s__ARoutine_endTimeOfDay[this]=endTimeOfDay
			set s__ARoutine_runRate[this]=runRate
			set s__ARoutine_routineAction[this]=routineAction

			call s__ARoutine_createRunTrigger(this)
			call s__ARoutine_createEnableTrigger(this)
			call s__ARoutine_createDisableTrigger(this)
			return this
  endfunction

  function s__ARoutine_destroyRunTrigger takes integer this returns nothing
			if ( s__ARoutine_runRate[this] > 0.0 ) then
				call s__AHashTable_destroyTrigger(AGetWorldHashTable(),s__ARoutine_runTrigger[this]) //AStructWorldWorldHashTable
				set s__ARoutine_runTrigger[this]=null
			endif
  endfunction

  function s__ARoutine_destroyEnableTrigger takes integer this returns nothing
			call s__AHashTable_destroyTrigger(AGetWorldHashTable(),s__ARoutine_enableTrigger[this]) //AStructWorldWorldHashTable
			set s__ARoutine_enableTrigger[this]=null
  endfunction

  function s__ARoutine_destroyDisableTrigger takes integer this returns nothing
			if ( s__ARoutine_runRate[this] > 0.0 ) then
				call s__AHashTable_destroyTrigger(AGetWorldHashTable(),s__ARoutine_disableTrigger[this]) //AStructWorldWorldHashTable
				set s__ARoutine_disableTrigger[this]=null
			endif
  endfunction

  function s__ARoutine_onDestroy takes integer this returns nothing
			//start members
			set s__ARoutine_usedUnit[this]=null

			call s__ARoutine_destroyRunTrigger(this)
			call s__ARoutine_destroyEnableTrigger(this)
			call s__ARoutine_destroyDisableTrigger(this)
  endfunction

//Generated destructor of ARoutine
function s__ARoutine_destroy takes integer this returns nothing
    if this==null then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: ARoutine")
        return
    elseif (si__ARoutine_V[this]!=-1) then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: ARoutine")
        return
    endif
    call s__ARoutine_onDestroy(this)
    set si__ARoutine_V[this]=si__ARoutine_F
    set si__ARoutine_F=this
endfunction


//library AStructSystemsWorldRoutine ends
//library AStructSystemsWorldSpawnPoint:

	/// @struct ASpawnPoint provides the functionality of common creep spawn points, mostly used in RPG maps.
		//static start members
		//dynamic members
		//start members
		//members

//textmacro instance: A_STRUCT_DEBUG("\"ASpawnPoint\"")
   function s__ASpawnPoint_print takes integer this,string message returns nothing
    call Print("ASpawnPoint" + " - " + I2S(this) + ": " + message)
   endfunction

   function s__ASpawnPoint_staticPrint takes string message returns nothing
    call Print("ASpawnPoint" + ": " + message)
   endfunction
//end of: A_STRUCT_DEBUG("\"ASpawnPoint\"")

		//dynamic members

  function s__ASpawnPoint_setUnitPool takes integer this,unitpool unitPool returns nothing
			set s__ASpawnPoint_unitPool[this]=unitPool
  endfunction

  function s__ASpawnPoint_getUnitPool takes integer this returns unitpool
			return s__ASpawnPoint_unitPool[this]
  endfunction

  function s__ASpawnPoint_setItemPool takes integer this,itempool itemPool returns nothing
			set s__ASpawnPoint_itemPool[this]=itemPool
  endfunction

  function s__ASpawnPoint_getItemPool takes integer this returns itempool
			return s__ASpawnPoint_itemPool[this]
  endfunction

		//methods

		/// If you want to start a video and there are some spawn points near the scene you can disable them during the video.
  function s__ASpawnPoint_enable takes integer this returns nothing
			call EnableTrigger(s__ASpawnPoint_deathTrigger[this])
			if ( TimerGetRemaining(s__ASpawnPoint_spawnTimer[this]) > 0.0 ) then
				call PauseTimerBJ(false , s__ASpawnPoint_spawnTimer[this])
			endif
  endfunction

  function s__ASpawnPoint_disable takes integer this returns nothing
			call DisableTrigger(s__ASpawnPoint_deathTrigger[this])
			if ( TimerGetRemaining(s__ASpawnPoint_spawnTimer[this]) > 0.0 ) then
				call PauseTimerBJ(true , s__ASpawnPoint_spawnTimer[this])
			endif
  endfunction

  function s__ASpawnPoint_spawn takes integer this returns nothing
   local player user= Player(PLAYER_NEUTRAL_AGGRESSIVE)
   local real angle= GetRandomReal(0.0 , 360.0)
   local real range= GetRandomReal(0.0 , s__ASpawnPoint_range[this])
   local real x= GetPolarProjectionX(s__ASpawnPoint_x[this] , angle , range) //ALibraryMathsPoint
   local real y= GetPolarProjectionY(s__ASpawnPoint_y[this] , angle , range) //ALibraryMathsPoint
   local real facingAngle= GetRandomReal(0.0 , 360.0)
			set s__ASpawnPoint_spawnedUnit[this]=PlaceRandomUnit(s__ASpawnPoint_unitPool[this] , user , x , y , facingAngle)
			set user = null
			//Need global, faster?
			if ( s__ASpawnPoint_effectPath != null ) then
				set s__ASpawnPoint_usedEffect[this]=AddSpecialEffect(s__ASpawnPoint_effectPath , x , y)
				call DestroyEffect(s__ASpawnPoint_usedEffect[this])
				set s__ASpawnPoint_usedEffect[this]=null
			endif
  endfunction

  function s__ASpawnPoint_dropItem takes integer this returns nothing
   local integer change= GetRandomInt(0 , 100)
   local unit triggerUnit
   local item droppedItem
			if ( change <= s__ASpawnPoint_dropChance ) then
				set triggerUnit = GetTriggerUnit()
				set droppedItem = PlaceRandomItem(s__ASpawnPoint_itemPool[this] , GetUnitX(triggerUnit) , GetUnitY(triggerUnit))
				set triggerUnit = null
				set droppedItem = null
			endif
  endfunction

  function s__ASpawnPoint_timerFunctionSpawn takes nothing returns nothing
   local timer expiredTimer= GetExpiredTimer()
   local integer spawnPoint= s__AHashTable_getHandleInteger(AGetWorldHashTable(),expiredTimer , "spawnPoint") //AClassWorldWorldHashTable
			call s__ASpawnPoint_spawn(spawnPoint)
			set expiredTimer = null
  endfunction

  function s__ASpawnPoint_startTimer takes integer this returns nothing
    if ( TimerGetRemaining(s__ASpawnPoint_spawnTimer[this]) > 0.0 ) then
     call s__ASpawnPoint_print(this,"Timer has arleady been started.")
     return 
    endif
			call TimerStart(s__ASpawnPoint_spawnTimer[this] , s__ASpawnPoint_time , false , function s__ASpawnPoint_timerFunctionSpawn)
  endfunction

  function s__ASpawnPoint_triggerConditionDeath takes nothing returns boolean
   local trigger triggeringTrigger= GetTriggeringTrigger()
   local unit triggerUnit= GetTriggerUnit()
   local integer spawnPoint= s__AHashTable_getHandleInteger(AGetWorldHashTable(),triggeringTrigger , "spawnPoint") //AClassWorldWorldHashTable
   local boolean result= ( triggerUnit == s__ASpawnPoint_spawnedUnit[spawnPoint] )
			set triggeringTrigger = null
			set triggerUnit = null
			return result
  endfunction

  function s__ASpawnPoint_triggerActionDeath takes nothing returns nothing
   local trigger triggeringTrigger= GetTriggeringTrigger()
   local integer spawnPoint= s__AHashTable_getHandleInteger(AGetWorldHashTable(),triggeringTrigger , "spawnPoint") //AClassWorldWorldHashTable
			call s__ASpawnPoint_dropItem(spawnPoint)
			call s__ASpawnPoint_startTimer(spawnPoint)
			set triggeringTrigger = null
  endfunction

  function s__ASpawnPoint_createDeathTrigger takes integer this returns nothing
   local player user
   local event triggerEvent
   local conditionfunc conditionFunction
   local triggercondition triggerCondition
   local triggeraction triggerAction
			set s__ASpawnPoint_deathTrigger[this]=CreateTrigger()
			set user = Player(PLAYER_NEUTRAL_AGGRESSIVE)
			set triggerEvent = TriggerRegisterPlayerUnitEvent(s__ASpawnPoint_deathTrigger[this] , user , EVENT_PLAYER_UNIT_DEATH , null)
			set user = null
			set conditionFunction = Condition(function s__ASpawnPoint_triggerConditionDeath)
			set triggerCondition = TriggerAddCondition(s__ASpawnPoint_deathTrigger[this] , conditionFunction)
			set triggerAction = TriggerAddAction(s__ASpawnPoint_deathTrigger[this] , function s__ASpawnPoint_triggerActionDeath)
			call s__AHashTable_storeHandleInteger(AGetWorldHashTable(),s__ASpawnPoint_deathTrigger[this] , "spawnPoint" , this) //AClassWorldWorldHashTable
			set triggerEvent = null
			set conditionFunction = null
			set triggerCondition = null
			set triggerAction = null
  endfunction

  function s__ASpawnPoint_createSpawnTimer takes integer this returns nothing
			set s__ASpawnPoint_spawnTimer[this]=CreateTimer()
			call s__AHashTable_storeHandleInteger(AGetWorldHashTable(),s__ASpawnPoint_spawnTimer[this] , "spawnPoint" , this) //AClassWorldWorldHashTable
  endfunction

  function s__ASpawnPoint_create takes real x,real y,real range,unitpool unitPool,itempool itemPool returns integer
   local integer this= s__ASpawnPoint__allocate()
			//start members
			set s__ASpawnPoint_x[this]=x
			set s__ASpawnPoint_y[this]=y
			set s__ASpawnPoint_range[this]=range
			//dynamic members
			set s__ASpawnPoint_unitPool[this]=unitPool
			set s__ASpawnPoint_itemPool[this]=itemPool

			call s__ASpawnPoint_createDeathTrigger(this)
			call s__ASpawnPoint_createSpawnTimer(this)
			call s__ASpawnPoint_spawn(this)
			return this
  endfunction

  function s__ASpawnPoint_destroyDeathTrigger takes integer this returns nothing
			call s__AHashTable_destroyTrigger(AGetWorldHashTable(),s__ASpawnPoint_deathTrigger[this]) //AClassWorldWorldHashTable
			set s__ASpawnPoint_deathTrigger[this]=null
  endfunction

  function s__ASpawnPoint_destroySpawnTimer takes integer this returns nothing
			call s__AHashTable_destroyTimer(AGetWorldHashTable(),s__ASpawnPoint_spawnTimer[this]) //AClassWorldWorldHashTable
			set s__ASpawnPoint_spawnTimer[this]=null
  endfunction

  function s__ASpawnPoint_onDestroy takes integer this returns nothing
			//members
			call RemoveUnit(s__ASpawnPoint_spawnedUnit[this])
			set s__ASpawnPoint_spawnedUnit[this]=null
			//dynamic members
			set s__ASpawnPoint_unitPool[this]=null
			set s__ASpawnPoint_itemPool[this]=null

			call s__ASpawnPoint_destroyDeathTrigger(this)
			call s__ASpawnPoint_destroySpawnTimer(this)
  endfunction

//Generated destructor of ASpawnPoint
function s__ASpawnPoint_destroy takes integer this returns nothing
    if this==null then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: ASpawnPoint")
        return
    elseif (si__ASpawnPoint_V[this]!=-1) then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: ASpawnPoint")
        return
    endif
    call s__ASpawnPoint_onDestroy(this)
    set si__ASpawnPoint_V[this]=si__ASpawnPoint_F
    set si__ASpawnPoint_F=this
endfunction

		/// Initializes the spawn point system. Please call this method before using anything of this system.
		/// @param time The time which has to elapse before the unit respawns.
		/// @param effectPath The path of the effect which is shown when the unit respawns. If this value is null there won't be shown any effect.
		/// @param dropChance The chance (percentaged) for dropping items.
  function s__ASpawnPoint_init takes real time,string effectPath,integer dropChance returns nothing
			//static start members
			set s__ASpawnPoint_time=time
			set s__ASpawnPoint_effectPath=effectPath
			set s__ASpawnPoint_dropChance=dropChance
  endfunction


//library AStructSystemsWorldSpawnPoint ends
//library ACoreInterface:

//library ACoreInterface ends
//library ALibraryCoreDebugString:

 function ALibraryCoreDebugString___GetStringConversionDebug takes nothing returns nothing
  local string PrintString= ""
		//function GetTimeString takes integer Seconds returns string - Works
		set PrintString = ( "GetTimeString - " + GetTimeString(120) )
		call Print(PrintString)
		//function StringToPlayerColour takes string String returns playercolor - Works
		if ( StringToPlayerColor("ff0000") == PLAYER_COLOR_RED ) then
			set PrintString = ( "StringToPlayerColor - Works." )
		else
			set PrintString = ( "StringToPlayerColor - Doesn't work." )
		endif
		call Print(PrintString)
		//function PlayerColourToString takes playercolor PlayerColour returns string - Works
		set PrintString = ( "PlayerColorToString - " + PlayerColorToString(PLAYER_COLOR_BLUE) + "Blue text" )
		call Print(PrintString)
	endfunction

 function ALibraryCoreDebugString___GetStringPoolFunctionsDebug takes nothing returns nothing
  local string PrintString= ""
		//function GetRandomChar takes string CharPool returns string - Works
		set PrintString = GetRandomChar("abc" , 100.00) //if the chance is 100.00 it will be always upper case
		call Print(PrintString)
		//function GetRandomAlphabeticChar takes real RequestedChance returns string - Works
		set PrintString = GetRandomAlphabeticalChar(100.00) //if the chance is 100.00 it will be always upper case
		call Print(PrintString)
		//function GetRandomNumeralChar takes nothing returns string - Works
		set PrintString = GetRandomNumeralChar()
		call Print(PrintString)
		//function GetRandomPeculiarChar takes nothing returns string - Works
		set PrintString = GetRandomSpecialChar()
		call Print(PrintString)
		//function GetRandomString takes integer Length, real CaseSensitivityChance, boolean IncludingNumbers, boolean IncludingPeculiars returns string - Check it
		set PrintString = GetRandomString(23 , 100.00 , true , true , true) //if the chance is 100.00 it will be always upper case
		call Print(PrintString)
		//function IsStringFromStringPool takes string String, string StringPool returns boolean - Works
		if ( not IsStringFromStringPool("Hallo" , "1111") ) then
			set PrintString = "IsStringFromStringPool - Works"
		else
			set PrintString = "IsStringFromStringPool - Doesn't work."
		endif
		call Print(PrintString)
		//function IsStringAlphabetic takes string String returns boolean
		if ( IsStringAlphabetical("hallo") ) then
			set PrintString = "IsStringAlphabetical - Works"
		else
			set PrintString = "IsStringAlphabetical - Doesn't work."
		endif
		call Print(PrintString)
		//function IsStringNumeral takes string String returns boolean
		if ( IsStringNumeral("1243") ) then
			set PrintString = "IsStringNumeral - Works"
		else
			set PrintString = "IsStringNumeral - Doesn't work."
		endif
		call Print(PrintString)
		//function IsStringPeculiar takes string String returns boolean
		if ( IsStringSpecialChar("!()") ) then
			set PrintString = "IsStringSpecialCharacter - Works"
		else
			set PrintString = "IsStringSpecialCharacter - Doesn't work."
		endif
		call Print(PrintString)
		//function IsStringInteger takes string String returns boolean
		if ( IsStringInteger("-345") ) then
			set PrintString = "IsStringInteger - Works"
		else
			set PrintString = "IsStringInteger - Doesn't work."
		endif
		call Print(PrintString)
	
		//- 0% binär
		//- 0 oktal
		//- 0x hexadezimal
	
		//function IsStringBinary takes string String returns boolean
		if ( IsStringBinary("0%11011") ) then
			set PrintString = "IsStringBinary - Works"
		else
			set PrintString = "IsStringBinary - Doesn't work."
		endif
		call Print(PrintString)
		//function IsStringOctal takes string String returns boolean
		if ( IsStringOctal("0243") ) then
			set PrintString = "IsStringOctal - Works"
		else
			set PrintString = "IsStringOctal - Doesn't work."
		endif
		call Print(PrintString)
		//function IsStringHexadecimal takes string String returns boolean
		if ( IsStringHexadecimal("0xFF29A") ) then
			set PrintString = "IsStringHexadecimal - Works"
		else
			set PrintString = "IsStringHexadecimal - Doesn't work."
		endif
		call Print(PrintString)
	endfunction

 function GetStringMiscFunctionsDebug takes nothing returns nothing
	endfunction

 function GetStringDebug takes nothing returns nothing
		call ALibraryCoreDebugString___GetStringConversionDebug()
		call ALibraryCoreDebugString___GetStringPoolFunctionsDebug()
		call GetStringMiscFunctionsDebug()
	endfunction


//library ALibraryCoreDebugString ends
//library AStructSystemsCharacterAbstractQuest:

	/// @todo Should be a part of @struct AAbstractQuest, vJass bug.
//processed: 	function interface AAbstractQuestStateEvent takes AAbstractQuest abstractQuest, trigger usedTrigger returns nothing

	/// @todo Should be a part of @struct AAbstractQuest, vJass bug.
//processed: 	function interface AAbstractQuestStateCondition takes AAbstractQuest abstractQuest returns boolean

	/// @todo Should be a part of @struct AAbstractQuest, vJass bug.
//processed: 	function interface AAbstractQuestStateAction takes AAbstractQuest abstractQuest returns nothing

		//static constant members
		//static start members
		/// @todo Added default values for debugging.
		//dynamic members
		//start members
		//members

//textmacro instance: A_STRUCT_DEBUG("\"AAbstractQuest\"")
   function s__AAbstractQuest_print takes integer this,string message returns nothing
    call Print("AAbstractQuest" + " - " + I2S(this) + ": " + message)
   endfunction

   function s__AAbstractQuest_staticPrint takes string message returns nothing
    call Print("AAbstractQuest" + ": " + message)
   endfunction
//end of: A_STRUCT_DEBUG("\"AAbstractQuest\"")

		//dynamic members

  function s__AAbstractQuest_setState takes integer this,integer state returns nothing
    if ( ( state >= s__AAbstractQuest_stateNew ) and ( state < s__AAbstractQuest_maxStates ) ) then
				if ( s___AAbstractQuest_stateTrigger[s__AAbstractQuest_stateTrigger[this]+state] == null ) then
					if ( s___AAbstractQuest_stateCondition[s__AAbstractQuest_stateCondition[this]+state] != 0 and not sc___prototype841_evaluate(s___AAbstractQuest_stateCondition[s__AAbstractQuest_stateCondition[this]+state],this) ) then
						return 
					endif
					if ( s___AAbstractQuest_stateAction[s__AAbstractQuest_stateAction[this]+state] != 0 ) then
						call sc___prototype842_execute(s___AAbstractQuest_stateAction[s__AAbstractQuest_stateAction[this]+state],this) //call custom function
					endif
				endif
				set s__AAbstractQuest_state[this]=state
     call Print("Set state to " + I2S(state))
				call sc__AAbstractQuest_displayMessage(this)
     call Print("After displaying message")
				if ( state == s__AAbstractQuest_stateNew ) then
      call Print("Enable")
					call sc__AAbstractQuest_enable(this)
				elseif ( state == s__AAbstractQuest_stateCompleted ) then
					call sc__AAbstractQuest_distributeRewards(this)
					call sc__AAbstractQuest_disable(this) //disable
				elseif ( state == s__AAbstractQuest_stateCompleted ) then
					call sc__AAbstractQuest_disable(this) //disable
				endif
    else
     call Print("Invalid quest state in quest " + I2S(this) + ".") //ALibraryGeneralDebug
    endif
  endfunction

  function s__AAbstractQuest_getState takes integer this returns integer
			return s__AAbstractQuest_state[this]
  endfunction

		//call first setStateEvent then setStateCondition and at least setStateAction
  function s__AAbstractQuest_setStateEvent takes integer this,integer state,integer stateEvent returns nothing
			if ( s___AAbstractQuest_stateTrigger[s__AAbstractQuest_stateTrigger[this]+state] == null ) then
				set s___AAbstractQuest_stateTrigger[s__AAbstractQuest_stateTrigger[this]+state]=CreateTrigger()
				call s__AHashTable_storeHandleInteger(AGetCharacterHashTable(),s___AAbstractQuest_stateTrigger[s__AAbstractQuest_stateTrigger[this]+state] , "abstractQuest" , this) //AClassCharacterCharacterHashTable
				call s__AHashTable_storeHandleInteger(AGetCharacterHashTable(),s___AAbstractQuest_stateTrigger[s__AAbstractQuest_stateTrigger[this]+state] , "state" , state) //AClassCharacterCharacterHashTable
				call DisableTrigger(s___AAbstractQuest_stateTrigger[s__AAbstractQuest_stateTrigger[this]+state])
     call Print("Create state trigger for state " + I2S(state))
     call Print("Saved id is " + I2S(s__AHashTable_getHandleInteger(AGetCharacterHashTable(),s___AAbstractQuest_stateTrigger[s__AAbstractQuest_stateTrigger[this]+state] , "abstractQuest")) + " (has to be " + I2S(this) + " and state is " + I2S(s__AHashTable_getHandleInteger(AGetCharacterHashTable(),s___AAbstractQuest_stateTrigger[s__AAbstractQuest_stateTrigger[this]+state] , "state")))
     call Print("Handle id: " + I2S(H2I(s___AAbstractQuest_stateTrigger[s__AAbstractQuest_stateTrigger[this]+state])))
			endif
			call sc___prototype840_execute(stateEvent,this , s___AAbstractQuest_stateTrigger[s__AAbstractQuest_stateTrigger[this]+state]) //evaluate - returns the trigger event
    call Print("After state execution with id " + I2S(this))
  endfunction

  function s__AAbstractQuest_setStateCondition takes integer this,integer state,integer stateCondition returns nothing
   local conditionfunc conditionFunction
   local triggercondition triggerCondition
			set s___AAbstractQuest_stateCondition[s__AAbstractQuest_stateCondition[this]+state]=stateCondition
    call Print("After adding condition to state trigger: " + I2S(H2I(s___AAbstractQuest_stateTrigger[s__AAbstractQuest_stateTrigger[this]+state])) + " and state " + I2S(state))
			if ( s___AAbstractQuest_stateTrigger[s__AAbstractQuest_stateTrigger[this]+state] != null ) then
				set conditionFunction = Condition(function sc__AAbstractQuest_triggerConditionRunQuestState)
				set triggerCondition = TriggerAddCondition(s___AAbstractQuest_stateTrigger[s__AAbstractQuest_stateTrigger[this]+state] , conditionFunction)
				set conditionFunction = null
				set triggerCondition = null
			endif
    call Print("After adding condition with id " + I2S(this) + " and state " + I2S(state))
  endfunction

  function s__AAbstractQuest_setStateAction takes integer this,integer state,integer stateAction returns nothing
   local triggeraction triggerAction
    call Print("After adding action with state " + I2S(state))
			set s___AAbstractQuest_stateAction[s__AAbstractQuest_stateAction[this]+state]=stateAction
			if ( s___AAbstractQuest_stateTrigger[s__AAbstractQuest_stateTrigger[this]+state] != null ) then
				set triggerAction = TriggerAddAction(s___AAbstractQuest_stateTrigger[s__AAbstractQuest_stateTrigger[this]+state] , function sc__AAbstractQuest_triggerActionRunQuestState)
				set triggerAction = null
			endif
    call Print("After adding action with id " + I2S(this))
  endfunction

  function s__AAbstractQuest_setReward takes integer this,integer reward,integer value returns nothing
			set s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+reward]=value
  endfunction

  function s__AAbstractQuest_getReward takes integer this,integer reward returns integer
			return s__AAbstractQuest_reward[this]
  endfunction

  function s__AAbstractQuest_setPingX takes integer this,real pingX returns nothing
			set s__AAbstractQuest_pingX[this]=pingX
  endfunction

  function s__AAbstractQuest_getPingX takes integer this returns real
			return s__AAbstractQuest_pingX[this]
  endfunction

  function s__AAbstractQuest_setPingY takes integer this,real pingY returns nothing
			set s__AAbstractQuest_pingY[this]=pingY
  endfunction

  function s__AAbstractQuest_getPingY takes integer this returns real
			return s__AAbstractQuest_pingY[this]
  endfunction

  function s__AAbstractQuest_setPingDuration takes integer this,real pingDuration returns nothing
			set s__AAbstractQuest_pingDuration[this]=pingDuration
  endfunction

  function s__AAbstractQuest_getPingDuration takes integer this returns real
			return s__AAbstractQuest_pingDuration[this]
  endfunction

		/// @param pingRed Default is 100.0.
  function s__AAbstractQuest_setPingRed takes integer this,real pingRed returns nothing
			set s__AAbstractQuest_pingRed[this]=pingRed
  endfunction

  function s__AAbstractQuest_getPingRed takes integer this returns real
			return s__AAbstractQuest_pingRed[this]
  endfunction

		/// @param pingGreen Default is 100.0.
  function s__AAbstractQuest_setPingGreen takes integer this,real pingGreen returns nothing
			set s__AAbstractQuest_pingGreen[this]=pingGreen
  endfunction

  function s__AAbstractQuest_getPingGreen takes integer this returns real
			return s__AAbstractQuest_pingGreen[this]
  endfunction

		/// @param pingBlue Default is 100.0.
  function s__AAbstractQuest_setPingBlue takes integer this,real pingBlue returns nothing
			set s__AAbstractQuest_pingBlue[this]=pingBlue
  endfunction

  function s__AAbstractQuest_getPingBlue takes integer this returns real
			return s__AAbstractQuest_pingBlue[this]
  endfunction

		//start members

  function s__AAbstractQuest_getCharacter takes integer this returns integer
			return s__AAbstractQuest_character[this]
  endfunction

		//comfort methods
		
  function s__AAbstractQuest_setPingLocation takes integer this,location usedLocation returns nothing
			set s__AAbstractQuest_pingX[this]=GetLocationX(usedLocation)
			set s__AAbstractQuest_pingY[this]=GetLocationY(usedLocation)
  endfunction
		
  function s__AAbstractQuest_setPingRect takes integer this,rect usedRect returns nothing
    if ( usedRect == null ) then
     call Print("In abstract quest " + I2S(this) + " usedRect is null.")
    else
     call Print("In abstract quest " + I2S(this) + " usedRect is NOT null.")
    endif
			set s__AAbstractQuest_pingX[this]=GetRectCenterX(usedRect)
			set s__AAbstractQuest_pingY[this]=GetRectCenterY(usedRect)
  endfunction
		
  function s__AAbstractQuest_setPingWidget takes integer this,widget usedWidget returns nothing
			set s__AAbstractQuest_pingX[this]=GetWidgetX(usedWidget)
			set s__AAbstractQuest_pingY[this]=GetWidgetY(usedWidget)
  endfunction
		
  function s__AAbstractQuest_setPingUnit takes integer this,unit usedUnit returns nothing
			set s__AAbstractQuest_pingX[this]=GetUnitX(usedUnit)
			set s__AAbstractQuest_pingY[this]=GetUnitY(usedUnit)
  endfunction
		
  function s__AAbstractQuest_setPingDestructable takes integer this,destructable usedDestructable returns nothing
			set s__AAbstractQuest_pingX[this]=GetDestructableX(usedDestructable)
			set s__AAbstractQuest_pingY[this]=GetDestructableY(usedDestructable)
  endfunction
		
  function s__AAbstractQuest_setPingItem takes integer this,item usedItem returns nothing
			set s__AAbstractQuest_pingX[this]=GetItemX(usedItem)
			set s__AAbstractQuest_pingY[this]=GetItemY(usedItem)
  endfunction
		
  function s__AAbstractQuest_setPingColour takes integer this,real red,real green,real blue returns nothing
			set s__AAbstractQuest_pingRed[this]=red
			set s__AAbstractQuest_pingGreen[this]=green
			set s__AAbstractQuest_pingBlue[this]=blue
  endfunction
		
		//methods

  function s__AAbstractQuest_getTitle takes integer this returns string
			return s__AAbstractQuest_title[this]
  endfunction
		
  function s__AAbstractQuest_getModifiedTitle takes integer this returns string
			if ( s__AAbstractQuest_state[this] == s__AAbstractQuest_stateNew ) then
				return StringArg(s__AAbstractQuest_textStateNew , s__AAbstractQuest_title[this]) //ALibraryStringConversion
			elseif ( s__AAbstractQuest_state[this] == s__AAbstractQuest_stateCompleted ) then
				return StringArg(s__AAbstractQuest_textStateCompleted , s__AAbstractQuest_title[this]) //ALibraryStringConversion
			elseif ( s__AAbstractQuest_state[this] == s__AAbstractQuest_stateFailed ) then
				return StringArg(s__AAbstractQuest_textStateFailed , s__AAbstractQuest_title[this]) //ALibraryStringConversion
    else
     call Print("Unknown state (in getModifiedTitle()): " + I2S(s__AAbstractQuest_state[this]))
			endif
			return s__AAbstractQuest_title[this]
  endfunction

  function s__AAbstractQuest_enable takes integer this returns nothing
			call sc__AAbstractQuest_enableStateTriggers(this)
			call sc__AAbstractQuest_enablePingTrigger(this)
  endfunction

  function s__AAbstractQuest_disable takes integer this returns nothing
			call sc__AAbstractQuest_disableStateTriggers(this)
			call sc__AAbstractQuest_disablePingTrigger(this)
  endfunction

  function s__AAbstractQuest_enableStateTriggers takes integer this returns nothing
   local integer i= 0
			loop
				exitwhen ( i == s__AAbstractQuest_maxStates )
				if ( s___AAbstractQuest_stateTrigger[s__AAbstractQuest_stateTrigger[this]+i] != null ) then
					call EnableTrigger(s___AAbstractQuest_stateTrigger[s__AAbstractQuest_stateTrigger[this]+i])
      call Print("Enable state trigger " + I2S(i))
				endif
				set i = i + 1
			endloop
  endfunction

  function s__AAbstractQuest_enablePingTrigger takes integer this returns nothing
			if ( s__AAbstractQuest_pingRate[this] != 0.0 ) then
				call EnableTrigger(s__AAbstractQuest_pingTrigger[this])
			endif
  endfunction

  function s__AAbstractQuest_disableStateTriggers takes integer this returns nothing
   local integer i= 0
			loop
				exitwhen ( i == s__AAbstractQuest_maxStates )
				if ( s___AAbstractQuest_stateTrigger[s__AAbstractQuest_stateTrigger[this]+i] != null ) then
					call DisableTrigger(s___AAbstractQuest_stateTrigger[s__AAbstractQuest_stateTrigger[this]+i])
				endif
				set i = i + 1
			endloop
  endfunction

  function s__AAbstractQuest_disablePingTrigger takes integer this returns nothing
			if ( s__AAbstractQuest_pingRate[this] != 0.0 ) then
				call DisableTrigger(s__AAbstractQuest_pingTrigger[this])
			endif
  endfunction

  function s__AAbstractQuest_getSoundPath takes integer this returns string
			if ( s__AAbstractQuest_state[this] == s__AAbstractQuest_stateNew ) then
				return s__AAbstractQuest_stateNewSoundPath
			elseif ( s__AAbstractQuest_state[this] == s__AAbstractQuest_stateCompleted ) then
				return s__AAbstractQuest_stateCompletedSoundPath
			else
				return s__AAbstractQuest_stateFailedSoundPath
			endif
			return ""
  endfunction

  function s__AAbstractQuest_displayMessage takes integer this returns nothing
			if ( s__AAbstractQuest_character[this] != 0 ) then
				call s__ACharacter_displayMessage(s__AAbstractQuest_character[this],s__ACharacter_messageTypeInfo , s__AAbstractQuest_getModifiedTitle(this)) //AClassCharacterCharacter
				call PlaySoundPathForPlayer(s__ACharacter_getUser(s__AAbstractQuest_character[this]) , s__AAbstractQuest_getSoundPath(this)) //ALibraryEnvironmentSound
			else
				call s__ACharacter_displayMessageToAll(s__ACharacter_messageTypeInfo , s__AAbstractQuest_getModifiedTitle(this)) //AClassCharacterCharacter
				call PlaySound(s__AAbstractQuest_getSoundPath(this))
			endif
  endfunction

  function s__AAbstractQuest_displayRewardMessage takes integer this,integer reward returns nothing
   local string message
			if ( reward == s__AAbstractQuest_rewardLevel ) then
				set message = s__AAbstractQuest_textRewardLevels
			elseif ( reward == s__AAbstractQuest_rewardSkillPoints ) then
				set message = s__AAbstractQuest_textRewardSkillPoints
			elseif ( reward == s__AAbstractQuest_rewardExperience ) then
				set message = s__AAbstractQuest_textRewardExperience
			elseif ( reward == s__AAbstractQuest_rewardStrength ) then
				set message = s__AAbstractQuest_textRewardStrength
			elseif ( reward == s__AAbstractQuest_rewardAgility ) then
				set message = s__AAbstractQuest_textRewardAgility
			elseif ( reward == s__AAbstractQuest_rewardIntelligence ) then
				set message = s__AAbstractQuest_textRewardIntelligence
			elseif ( reward == s__AAbstractQuest_rewardGold ) then
				set message = s__AAbstractQuest_textRewardGold
			elseif ( reward == s__AAbstractQuest_rewardLumber ) then
				set message = s__AAbstractQuest_textRewardLumber
    else
     call s__AAbstractQuest_print(this,"Unknown reward: " + I2S(reward))
			endif

			set message = IntegerArg(message , s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+reward])

			if ( s__AAbstractQuest_character[this] != 0 ) then
				call s__ACharacter_displayMessage(s__AAbstractQuest_character[this],s__ACharacter_messageTypeInfo , message)
			else
				call s__ACharacter_displayMessageToAll(s__ACharacter_messageTypeInfo , message)
			endif
  endfunction

  function s__AAbstractQuest_distributeRewards takes integer this returns nothing
   local integer i
			if ( s__AAbstractQuest_character[this] != 0 ) then
				if ( s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardLevel] != 0 ) then
					call s__ACharacter_addLevels(s__AAbstractQuest_character[this],s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardLevel] , true)
				endif
				if ( s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardSkillPoints] != 0 ) then
					call s__ACharacter_addSkillPoints(s__AAbstractQuest_character[this],s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardSkillPoints])
				endif
				if ( s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardExperience] != 0 ) then
					call s__ACharacter_addExperience(s__AAbstractQuest_character[this],s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardExperience] , true)
				endif
				if ( s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardStrength] != 0 ) then
					call s__ACharacter_addStrength(s__AAbstractQuest_character[this],s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardStrength])
				endif
				if ( s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardAgility] != 0 ) then
					call s__ACharacter_addAgility(s__AAbstractQuest_character[this],s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardAgility])
				endif
				if ( s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardIntelligence] != 0 ) then
					call s__ACharacter_addIntelligence(s__AAbstractQuest_character[this],s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardIntelligence])
				endif
				if ( s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardGold] != 0 ) then
					call s__ACharacter_addGold(s__AAbstractQuest_character[this],s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardGold])
				endif
				if ( s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardLumber] != 0 ) then
					call s__ACharacter_addLumber(s__AAbstractQuest_character[this],s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardLumber])
				endif
			else
				if ( s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardLevel] != 0 ) then
					call s__ACharacter_addLevelsToAll(s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardLevel] , true)
				endif
				if ( s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardSkillPoints] != 0 ) then
					call s__ACharacter_addSkillPointsToAll(s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardSkillPoints])
				endif
				if ( s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardExperience] != 0 ) then
					call s__ACharacter_addExperienceToAll(s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardExperience] , true)
				endif
				if ( s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardStrength] != 0 ) then
					call s__ACharacter_addStrengthToAll(s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardStrength])
				endif
				if ( s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardAgility] != 0 ) then
					call s__ACharacter_addAgilityToAll(s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardAgility])
				endif
				if ( s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardIntelligence] != 0 ) then
					call s__ACharacter_addIntelligenceToAll(s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardIntelligence])
				endif
				if ( s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardGold] != 0 ) then
					call s__ACharacter_addGoldToAll(s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardGold])
				endif
				if ( s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardLumber] != 0 ) then
					call s__ACharacter_addLumberToAll(s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardLumber])
				endif
			endif
			set i = s__AAbstractQuest_rewardLevel
			loop
				exitwhen ( i == s__AAbstractQuest_maxRewards )
				if ( s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+i] != 0 ) then
					call s__AAbstractQuest_displayRewardMessage(this,i)
				endif
				set i = i + 1
			endloop
  endfunction

  function s__AAbstractQuest_triggerConditionRunQuestState takes nothing returns boolean
   local trigger triggeringTrigger= GetTriggeringTrigger()
   local integer abstractQuest= s__AHashTable_getHandleInteger(AGetCharacterHashTable(),triggeringTrigger , "abstractQuest") //AClassCharacterCharacterHashTable
   local integer state= s__AHashTable_getHandleInteger(AGetCharacterHashTable(),triggeringTrigger , "state") //AClassCharacterCharacterHashTable
    call Print("Handle id: " + I2S(H2I(triggeringTrigger)))
			set triggeringTrigger = null
    call Print("QUEST CONDITION for abstract quest " + I2S(abstractQuest) + " with state " + I2S(state))
			return sc___prototype841_evaluate(s___AAbstractQuest_stateCondition[s__AAbstractQuest_stateCondition[abstractQuest]+state],abstractQuest)
  endfunction
	
  function s__AAbstractQuest_triggerActionRunQuestState takes nothing returns nothing
   local trigger triggeringTrigger= GetTriggeringTrigger()
   local integer abstractQuest= s__AHashTable_getHandleInteger(AGetCharacterHashTable(),triggeringTrigger , "abstractQuest")
   local integer state= s__AHashTable_getHandleInteger(AGetCharacterHashTable(),triggeringTrigger , "state")
    call Print("ACTION for abstract quest " + I2S(abstractQuest) + " with state " + I2S(state))
			call sc__AAbstractQuest_setState(abstractQuest,state) //custom function will be called in this method
			set triggeringTrigger = null
  endfunction
		
  function s__AAbstractQuest_setupStateTriggers takes integer this returns nothing
   local integer i= 0
			loop
				exitwhen ( i == s__AAbstractQuest_maxStates )
				set s___AAbstractQuest_stateTrigger[s__AAbstractQuest_stateTrigger[this]+i]=null
				set i = i + 1
			endloop
  endfunction
		
  function s__AAbstractQuest_triggerActionPingMinimap takes nothing returns nothing
   local trigger triggeringTrigger= GetTriggeringTrigger()
   local integer abstractQuest= s__AHashTable_getHandleInteger(AGetCharacterHashTable(),triggeringTrigger , "abstractQuest") //AClassCharacterCharacterHashTable
			if ( s__AAbstractQuest_character[abstractQuest] != 0 ) then
				call PingMinimapExForPlayer(s__ACharacter_getUser(s__AAbstractQuest_character[abstractQuest]) , s__AAbstractQuest_pingX[abstractQuest] , s__AAbstractQuest_pingY[abstractQuest] , s__AAbstractQuest_pingDuration[abstractQuest] , s__AAbstractQuest_pingRed[abstractQuest] , s__AAbstractQuest_pingGreen[abstractQuest] , s__AAbstractQuest_pingBlue[abstractQuest] , true) //ALibraryInterfaceMinimap
			else
				call PingMinimapEx(s__AAbstractQuest_pingX[abstractQuest] , s__AAbstractQuest_pingY[abstractQuest] , s__AAbstractQuest_pingDuration[abstractQuest] , PercentTo255(s__AAbstractQuest_pingRed[abstractQuest]) , PercentTo255(s__AAbstractQuest_pingGreen[abstractQuest]) , PercentTo255(s__AAbstractQuest_pingBlue[abstractQuest]) , true)
			endif
			set triggeringTrigger = null
  endfunction

  function s__AAbstractQuest_createPingTrigger takes integer this returns nothing
   local event triggerEvent
   local triggeraction triggerAction
			if ( s__AAbstractQuest_pingRate[this] != 0.0 ) then
				set s__AAbstractQuest_pingTrigger[this]=CreateTrigger()
				set triggerEvent = TriggerRegisterTimerEvent(s__AAbstractQuest_pingTrigger[this] , s__AAbstractQuest_pingRate[this] , true)
				set triggerAction = TriggerAddAction(s__AAbstractQuest_pingTrigger[this] , function s__AAbstractQuest_triggerActionPingMinimap)
				call s__AHashTable_storeHandleInteger(AGetCharacterHashTable(),s__AAbstractQuest_pingTrigger[this] , "abstractQuest" , this) //AClassCharacterCharacterHashTable
				set triggerEvent = null
				set triggerAction = null
				call DisableTrigger(s__AAbstractQuest_pingTrigger[this])
			endif
  endfunction

  function s__AAbstractQuest_create takes integer character,string title,real pingRate returns integer
   local integer this= s__AAbstractQuest__allocate()
			//start members
			set s__AAbstractQuest_character[this]=character
			set s__AAbstractQuest_title[this]=title
			set s__AAbstractQuest_pingRate[this]=pingRate
			//dynamic members
			set s__AAbstractQuest_state[this]=s__AAbstractQuest_stateNotUsed

			call s__AAbstractQuest_setupStateTriggers(this)
			call s__AAbstractQuest_createPingTrigger(this)
			return this
  endfunction

  function s__AAbstractQuest_destroyStateTriggers takes integer this returns nothing
   local integer i= s__AAbstractQuest_stateNew
			loop
				exitwhen ( i == s__AAbstractQuest_maxStates )
				if ( s___AAbstractQuest_stateTrigger[s__AAbstractQuest_stateTrigger[this]+i] != null ) then
					call s__AHashTable_destroyTrigger(AGetCharacterHashTable(),s___AAbstractQuest_stateTrigger[s__AAbstractQuest_stateTrigger[this]+i])
					set s___AAbstractQuest_stateTrigger[s__AAbstractQuest_stateTrigger[this]+i]=null
				endif
				set i = i + 1
			endloop
  endfunction

  function s__AAbstractQuest_destroyPingTrigger takes integer this returns nothing
			if ( s__AAbstractQuest_pingRate[this] != 0.0 ) then
				call s__AHashTable_destroyTrigger(AGetCharacterHashTable(),s__AAbstractQuest_pingTrigger[this])
				set s__AAbstractQuest_pingTrigger[this]=null
			endif
  endfunction

  function s__AAbstractQuest_onDestroy takes integer this returns nothing
		
			call s__AAbstractQuest_destroyStateTriggers(this)
			call s__AAbstractQuest_destroyPingTrigger(this)
  endfunction

  function s__AAbstractQuest_init takes string stateNewSoundPath,string stateCompletedSoundPath,string stateFailedSoundPath,string textStateNew,string textStateCompleted,string textStateFailed,string textRewardLevels,string textRewardSkillPoints,string textRewardExperience,string textRewardStrength,string textRewardAgility,string textRewardIntelligence,string textRewardGold,string textRewardLumber returns nothing
			//static start members
			set s__AAbstractQuest_stateNewSoundPath=stateNewSoundPath
			set s__AAbstractQuest_stateCompletedSoundPath=stateCompletedSoundPath
			set s__AAbstractQuest_stateFailedSoundPath=stateFailedSoundPath
			set s__AAbstractQuest_textStateNew=textStateNew
			set s__AAbstractQuest_textStateCompleted=textStateCompleted
			set s__AAbstractQuest_textStateFailed=textStateFailed
			set s__AAbstractQuest_textRewardLevels=textRewardLevels
			set s__AAbstractQuest_textRewardSkillPoints=textRewardSkillPoints
			set s__AAbstractQuest_textRewardExperience=textRewardExperience
			set s__AAbstractQuest_textRewardStrength=textRewardStrength
			set s__AAbstractQuest_textRewardAgility=textRewardAgility
			set s__AAbstractQuest_textRewardIntelligence=textRewardIntelligence
			set s__AAbstractQuest_textRewardGold=textRewardGold
			set s__AAbstractQuest_textRewardLumber=textRewardLumber

			if ( stateNewSoundPath != null ) then
				call PreloadSoundPath(stateNewSoundPath)
			endif
			if ( stateCompletedSoundPath != null ) then
				call PreloadSoundPath(stateCompletedSoundPath)
			endif
			if ( stateFailedSoundPath != null ) then
				call PreloadSoundPath(stateFailedSoundPath)
			endif
  endfunction


//library AStructSystemsCharacterAbstractQuest ends
//library AStructSystemsCharacterCharactersScheme:

		//static start members
		//static members

  function s__ACharactersScheme_create takes nothing returns integer
			return 0
  endfunction

  function s__ACharactersScheme_onDestroy takes integer this returns nothing
  endfunction

//Generated destructor of ACharactersScheme
function s__ACharactersScheme_destroy takes integer this returns nothing
    if this==null then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: ACharactersScheme")
        return
    elseif (si__ACharactersScheme_V[this]!=-1) then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: ACharactersScheme")
        return
    endif
    call s__ACharactersScheme_onDestroy(this)
    set si__ACharactersScheme_V[this]=si__ACharactersScheme_F
    set si__ACharactersScheme_F=this
endfunction

		/// Call this method before you use this class!
		/// @param refreshRate Should be bigger than 0.0.
  function s__ACharactersScheme_init takes real refreshRate,integer barLength,string textTitle,string textLevel,string textLeftGame returns nothing
			//static start members
			set s__ACharactersScheme_refreshRate=refreshRate
    if ( refreshRate <= 0 ) then
     call Print("ACharactersScheme: Refresh rate is <= 0")
    endif
			set s__ACharactersScheme_barLength=barLength
			set s__ACharactersScheme_textTitle=textTitle
			set s__ACharactersScheme_textLevel=textLevel
			set s__ACharactersScheme_textLeftGame=textLeftGame
			//static members
			set s__ACharactersScheme_usedMultiboard=null
			set s__ACharactersScheme_maxPlayers=0
  endfunction

  function s__ACharactersScheme_show takes nothing returns nothing
    call Print("Show characters scheme")
			if ( s__ACharactersScheme_usedMultiboard == null ) then
				call sc__ACharactersScheme_createMultiboard()
				call sc__ACharactersScheme_createRefreshTrigger()
			endif
			call EnableTrigger(s__ACharactersScheme_refreshTrigger)
			call MultiboardDisplay(s__ACharactersScheme_usedMultiboard , true)
  endfunction

  function s__ACharactersScheme_hide takes nothing returns nothing
			call MultiboardDisplay(s__ACharactersScheme_usedMultiboard , false)
			call DisableTrigger(s__ACharactersScheme_refreshTrigger)
  endfunction

  function s__ACharactersScheme_maximize takes nothing returns nothing
			call EnableTrigger(s__ACharactersScheme_refreshTrigger)
			call MultiboardMinimize(s__ACharactersScheme_usedMultiboard , false)
  endfunction

  function s__ACharactersScheme_minimize takes nothing returns nothing
			call MultiboardMinimize(s__ACharactersScheme_usedMultiboard , true)
			call DisableTrigger(s__ACharactersScheme_refreshTrigger)
  endfunction

  function s__ACharactersScheme_createMultiboard takes nothing returns nothing
   local integer i
   local player user
   local multiboarditem multiboardItem

			set s__ACharactersScheme_usedMultiboard=CreateMultiboard()
			call MultiboardSetTitleText(s__ACharactersScheme_usedMultiboard , s__ACharactersScheme_textTitle)
			call MultiboardSetColumnCount(s__ACharactersScheme_usedMultiboard , 3)

			set i = 0
			loop
				exitwhen ( i == bj_MAX_PLAYERS )
				set user = Player(i)
				if ( IsPlayerPlayingUser(user) ) then //ALibraryGeneralPlayer
					set multiboardItem = MultiboardGetItem(s__ACharactersScheme_usedMultiboard , i , 0)
					call MultiboardSetItemWidth(multiboardItem , 20.0) /// @todo check it
					call MultiboardSetItemStyle(multiboardItem , true , false)
					call MultiboardReleaseItem(multiboardItem)
					set multiboardItem = null

					set s__s__ACharactersScheme_hitPointsBar[i]= s__AMultiboardBar_create(s__ACharactersScheme_usedMultiboard , 1 , i , 10 , 0.0 , true , GetUnitState(s__ACharacter_getUsedUnit(s__ACharacter_getPlayerCharacter(user)) , UNIT_STATE_LIFE) , GetUnitState(s__ACharacter_getUsedUnit(s__ACharacter_getPlayerCharacter(user)) , UNIT_STATE_MAX_LIFE) , 0 , 0)
					call s__AMultiboardBar_setAllIcons(s__s__ACharactersScheme_hitPointsBar[i],"Icons\\Interface\\Bars\\White.blp" , false) //empty icons
					call s__AMultiboardBar_setAllIcons(s__s__ACharactersScheme_hitPointsBar[i],"Icons\\Interface\\Bars\\Green.blp" , true)


					set s__s__ACharactersScheme_manaBar[i]= s__AMultiboardBar_create(s__ACharactersScheme_usedMultiboard , s__AMultiboardBar_getFirstFreeField(s__s__ACharactersScheme_hitPointsBar[i]) , i , 10 , 0.0 , true , GetUnitState(s__ACharacter_getUsedUnit(s__ACharacter_getPlayerCharacter(user)) , UNIT_STATE_MANA) , GetUnitState(s__ACharacter_getUsedUnit(s__ACharacter_getPlayerCharacter(user)) , UNIT_STATE_MAX_MANA) , 0 , 0)
					call s__AMultiboardBar_setAllIcons(s__s__ACharactersScheme_manaBar[i],"Icons\\Interface\\Bars\\White.blp" , false) //empty icons
					call s__AMultiboardBar_setAllIcons(s__s__ACharactersScheme_manaBar[i],"Icons\\Interface\\Bars\\Blue.blp" , true)
					
					set s__ACharactersScheme_maxPlayers=i + 1
				endif
				set i = i + 1
			endloop
  endfunction

  function s__ACharactersScheme_triggerActionRefresh takes nothing returns nothing
   local integer i
   local multiboarditem multiboardItem
   local player user
			set i = 0
			loop
				exitwhen ( i == s__ACharactersScheme_maxPlayers )
				set multiboardItem = MultiboardGetItem(s__ACharactersScheme_usedMultiboard , i , 0)
				set user = Player(i)
				if ( IsPlayerPlayingUser(user) ) then //ALibraryGeneralPlayer
					//refresh name (class - unit name) - level
					call MultiboardSetItemValue(multiboardItem , GetModifiedPlayerName(user) + " [" + GetUnitName(s__ACharacter_getUsedUnit(s__ACharacter_getPlayerCharacter(user))) + "] - " + s__ACharactersScheme_textLevel + " " + I2S(GetHeroLevel(s__ACharacter_getUsedUnit(s__ACharacter_getPlayerCharacter(user))))) //ALibraryInterfaceMisc

					call s__AMultiboardBar_setValue(s__s__ACharactersScheme_hitPointsBar[i],GetUnitState(s__ACharacter_getUsedUnit(s__ACharacter_getPlayerCharacter(user)) , UNIT_STATE_LIFE))
					call s__AMultiboardBar_setMaxValue(s__s__ACharactersScheme_hitPointsBar[i],GetUnitState(s__ACharacter_getUsedUnit(s__ACharacter_getPlayerCharacter(user)) , UNIT_STATE_MAX_LIFE))
					call s__AMultiboardBar_refresh(s__s__ACharactersScheme_hitPointsBar[i])

					call s__AMultiboardBar_setValue(s__s__ACharactersScheme_manaBar[i],GetUnitState(s__ACharacter_getUsedUnit(s__ACharacter_getPlayerCharacter(user)) , UNIT_STATE_MANA))
					call s__AMultiboardBar_setMaxValue(s__s__ACharactersScheme_manaBar[i],GetUnitState(s__ACharacter_getUsedUnit(s__ACharacter_getPlayerCharacter(user)) , UNIT_STATE_MAX_MANA))
					call s__AMultiboardBar_refresh(s__s__ACharactersScheme_manaBar[i])
				elseif ( s__s__ACharactersScheme_hitPointsBar[i] != 0 ) then
					call MultiboardSetItemValue(multiboardItem , s__ACharactersScheme_textLeftGame)

					call s__AMultiboardBar_destroy(s__s__ACharactersScheme_hitPointsBar[i])
					set s__s__ACharactersScheme_hitPointsBar[i]= 0
					call s__AMultiboardBar_destroy(s__s__ACharactersScheme_manaBar[i])
					set s__s__ACharactersScheme_manaBar[i]= 0
				endif
				call MultiboardReleaseItem(multiboardItem)
				set multiboardItem = null
				set i = i + 1
			endloop
  endfunction

  function s__ACharactersScheme_createRefreshTrigger takes nothing returns nothing
   local event triggerEvent
   local triggeraction triggerAction
			set s__ACharactersScheme_refreshTrigger=CreateTrigger()
			set triggerEvent = TriggerRegisterTimerEvent(s__ACharactersScheme_refreshTrigger , s__ACharactersScheme_refreshRate , true)
			set triggerAction = TriggerAddAction(s__ACharactersScheme_refreshTrigger , function s__ACharactersScheme_triggerActionRefresh)
			set triggerEvent = null
			set triggerAction = null
    call Print("After refresh trigger creation with refresh rate " + R2S(s__ACharactersScheme_refreshRate))
  endfunction


//library AStructSystemsCharacterCharactersScheme ends
//library AStructSystemsCharacterClassSelection:

	/// @todo Should be a part of @struct AClassSelection, vJass bug.
//processed: 	function interface AClassSelectionSelectClassAction takes ACharacter character returns nothing

	/// @todo Should be a part of @struct AClassSelection, vJass bug.
//processed: 	function interface AClassSelectionStartGameAction takes nothing returns nothing

		//static constant members
		//static start members
		//static members
		//start members
		//members

		//methods
		
  function s__AClassSelection_show takes integer this returns nothing
			call ClearScreenMessagesForPlayer(s__AClassSelection_user[this]) //ALibraryInterfaceCinematic
			call SetUserInterfaceForPlayer(s__AClassSelection_user[this] , false , true) //ALibraryInterfaceCinematic
			call ShowMultiboardForPlayer(s__AClassSelection_user[this] , s__AClassSelection_infoSheet[this] , true) //ALibraryInterfaceMultiboard
			call MultiboardMinimize(s__AClassSelection_infoSheet[this] , false)
			call sc__AClassSelection_createUnit(this)
  endfunction

		//get new test
  function s__AClassSelection_refreshInfoSheet takes integer this returns nothing
   local integer i
   local multiboarditem multiboardItem
			call MultiboardSetTitleText(s__AClassSelection_infoSheet[this] , GetUnitName(s__AClassSelection_classUnit[this]))
			//strength
			set multiboardItem = MultiboardGetItem(s__AClassSelection_infoSheet[this] , 0 , 0)
			call MultiboardSetItemValue(multiboardItem , s__AClassSelection_textStrength + ": " + I2S(GetHeroStr(s__AClassSelection_classUnit[this] , false)))
			call MultiboardReleaseItem(multiboardItem)
			set multiboardItem = null
			//agility
			set multiboardItem = MultiboardGetItem(s__AClassSelection_infoSheet[this] , 1 , 0)
			call MultiboardSetItemValue(multiboardItem , s__AClassSelection_textAgility + ": " + I2S(GetHeroAgi(s__AClassSelection_classUnit[this] , false)))
			call MultiboardReleaseItem(multiboardItem)
			set multiboardItem = null
			//intelligence
			set multiboardItem = MultiboardGetItem(s__AClassSelection_infoSheet[this] , 2 , 0)
			call MultiboardSetItemValue(multiboardItem , s__AClassSelection_textIntelligence + ": " + I2S(GetHeroInt(s__AClassSelection_classUnit[this] , false)))
			call MultiboardReleaseItem(multiboardItem)
			set multiboardItem = null
			//abilities
			set i = 4
			loop
				exitwhen ( i == s__AClassSelection_maxInfoSheetIconItems )
				set multiboardItem = MultiboardGetItem(s__AClassSelection_infoSheet[this] , i , 0)
				if ( s__AClass_getUsedAbility(s__AClassSelection_class[this],i - 4) != 0 ) then
					call MultiboardSetItemIcon(multiboardItem , s__AClass_getAbilityIconPath(s__AClassSelection_class[this],i - 4)) //AClassCharacterClass
					call MultiboardSetItemValue(multiboardItem , GetObjectName(s__AClass_getUsedAbility(s__AClassSelection_class[this],i - 4))) //AClassCharacterClass
					call MultiboardSetItemStyle(multiboardItem , true , true)
				else
					call MultiboardSetItemStyle(multiboardItem , false , false)
				endif
				call MultiboardReleaseItem(multiboardItem)
				set multiboardItem = null
				set i = i + 1
			endloop
			//description
			set i = s__AClassSelection_maxInfoSheetIconItems + 1
			loop
				exitwhen ( i == s__AClassSelection_maxInfoSheetItems )
				set multiboardItem = MultiboardGetItem(s__AClassSelection_infoSheet[this] , i , 0)
				if ( StringLength(s__AClass_getDescriptionLine(s__AClassSelection_class[this],i - s__AClassSelection_maxInfoSheetIconItems + 1)) > 0 ) then
					call MultiboardSetItemValue(multiboardItem , s__AClass_getDescriptionLine(s__AClassSelection_class[this],i - s__AClassSelection_maxInfoSheetIconItems + 1)) //AClassCharacterClass
					call MultiboardSetItemStyle(multiboardItem , true , false)
				else
					call MultiboardSetItemStyle(multiboardItem , false , false)
				endif
				call MultiboardReleaseItem(multiboardItem)
				set multiboardItem = null
				set i = i + 1
			endloop
  endfunction

  function s__AClassSelection_createUnit takes integer this returns nothing
			if ( s__AClassSelection_classUnit[this] != null ) then
				call RemoveUnit(s__AClassSelection_classUnit[this])
				set s__AClassSelection_classUnit[this]=null
			endif
			set s__AClassSelection_classUnit[this]=CreateUnit(s__AClassSelection_user[this] , s__AClass_getUnitType(s__AClassSelection_class[this]) , s__AClassSelection_x , s__AClassSelection_y , s__AClassSelection_facing) //AClassCharacterClass
			call SetUnitInvulnerable(s__AClassSelection_classUnit[this] , true)
			call PauseUnit(s__AClassSelection_classUnit[this] , true)
			//Fr andere Spieler unsichtbar machen

			call SetUnitAnimation(s__AClassSelection_classUnit[this] , s__AClass_getAnimation(s__AClassSelection_class[this])) //AClassCharacterClass
			call PlaySoundPathForPlayer(s__AClassSelection_user[this] , s__AClass_getSoundPath(s__AClassSelection_class[this])) //AClassCharacterClass
			//call SetCameraTargetControllerNoZForPlayer(this.user, this.classUnit, 0.0, 0.0, false)
		
			call s__AClassSelection_refreshInfoSheet(this)
  endfunction

  function s__AClassSelection_selectClass takes integer this returns nothing
			call SetUserInterfaceForPlayer(s__AClassSelection_user[this] , false , false) //ALibraryInterfaceCinematic
			call ResetToGameCameraForPlayer(s__AClassSelection_user[this] , 0.0)
			call PanCameraToForPlayer(s__AClassSelection_user[this] , s__AClassSelection_startX[this] , s__AClassSelection_startY[this])
			call sc___prototype831_execute(s__AClassSelection_selectClassAction[this],s__ACharacter_setPlayerCharacter(s__AClassSelection_user[this] , s__AClass_generateUnit(s__AClassSelection_class[this],s__AClassSelection_user[this] , s__AClassSelection_startX[this] , s__AClassSelection_startY[this] , s__AClassSelection_startFacing[this]))) //AClassCharacterClass, AClassCharacerCharacter
			call sc__AClassSelection_destroy(this)
    call Print("Select")
			if ( s__AClassSelection_stack == 0 ) then
				call sc___prototype765_execute(s__AClassSelection_startGameAction)
			endif
  endfunction

  function s__AClassSelection_triggerActionRefresh takes nothing returns nothing
   local trigger triggeringTrigger= GetTriggeringTrigger()
   local integer classSelection= s__AHashTable_getHandleInteger(AGetCharacterHashTable(),triggeringTrigger , "classSelection") //AClassCharacterCharacterHashTable
    if ( s__AClassSelection_cameraSetup != null ) then
				call CameraSetupApplyForPlayer(true , s__AClassSelection_cameraSetup , s__AClassSelection_user[classSelection] , 0.0)
    else
     call Print("No camera")
    endif
			call SetUnitFacingTimed(s__AClassSelection_classUnit[classSelection] , GetUnitFacing(s__AClassSelection_classUnit[classSelection]) + s__AClassSelection_rotationAngle , s__AClassSelection_refreshRate)
			set triggeringTrigger = null
  endfunction

  function s__AClassSelection_createRefreshTrigger takes integer this returns nothing
   local event triggerEvent
   local triggeraction triggerAction
			if ( s__AClassSelection_refreshRate > 0.0 ) then
				set s__AClassSelection_refreshTrigger[this]=CreateTrigger()
				set triggerEvent = TriggerRegisterTimerEvent(s__AClassSelection_refreshTrigger[this] , s__AClassSelection_refreshRate , true)
				set triggerAction = TriggerAddAction(s__AClassSelection_refreshTrigger[this] , function s__AClassSelection_triggerActionRefresh)
				call s__AHashTable_storeHandleInteger(AGetCharacterHashTable(),s__AClassSelection_refreshTrigger[this] , "classSelection" , this) //AClassCharacterCharacterHashTable
				set triggerEvent = null
				set triggerAction = null
			endif
  endfunction

  function s__AClassSelection_triggerActionChangeToPrevious takes nothing returns nothing
   local trigger triggeringTrigger= GetTriggeringTrigger()
   local integer classSelection= s__AHashTable_getHandleInteger(AGetCharacterHashTable(),triggeringTrigger , "classSelection") //AClassCharacterCharacterHashTable
			if ( s__AClassSelection_class[classSelection] == s__AClassSelection_firstClass ) then
				set s__AClassSelection_class[classSelection]=s__AClassSelection_lastClass
			else
				set s__AClassSelection_class[classSelection]=s__AClassSelection_class[classSelection] - 1
			endif
			call s__AClassSelection_createUnit(classSelection)
			set triggeringTrigger = null
  endfunction

  function s__AClassSelection_createChangePreviousTrigger takes integer this returns nothing
   local event triggerEvent
   local triggeraction triggerAction
			set s__AClassSelection_changePreviousTrigger[this]=CreateTrigger()
			set triggerEvent = TriggerRegisterKeyEventForPlayer(s__AClassSelection_user[this] , s__AClassSelection_changePreviousTrigger[this] , KEY_LEFT , true) //ALibraryInterfaceMisc
			set triggerAction = TriggerAddAction(s__AClassSelection_changePreviousTrigger[this] , function s__AClassSelection_triggerActionChangeToPrevious)
			call s__AHashTable_storeHandleInteger(AGetCharacterHashTable(),s__AClassSelection_changePreviousTrigger[this] , "classSelection" , this) //AClassCharacterCharacterHashTable
			set triggerEvent = null
			set triggerAction = null
  endfunction

  function s__AClassSelection_triggerActionChangeToNext takes nothing returns nothing
   local trigger triggeringTrigger= GetTriggeringTrigger()
   local integer classSelection= s__AHashTable_getHandleInteger(AGetCharacterHashTable(),triggeringTrigger , "classSelection") //AClassCharacterCharacterHashTable
			if ( s__AClassSelection_class[classSelection] == s__AClassSelection_lastClass ) then
				set s__AClassSelection_class[classSelection]=s__AClassSelection_firstClass
			else
				set s__AClassSelection_class[classSelection]=s__AClassSelection_class[classSelection] + 1
			endif
			call s__AClassSelection_createUnit(classSelection)
			set triggeringTrigger = null
  endfunction

  function s__AClassSelection_createChangeNextTrigger takes integer this returns nothing
   local event triggerEvent
   local triggeraction triggerAction
			set s__AClassSelection_changeNextTrigger[this]=CreateTrigger()
			set triggerEvent = TriggerRegisterKeyEventForPlayer(s__AClassSelection_user[this] , s__AClassSelection_changeNextTrigger[this] , KEY_RIGHT , true) //ALibraryInterfaceMisc
			set triggerAction = TriggerAddAction(s__AClassSelection_changeNextTrigger[this] , function s__AClassSelection_triggerActionChangeToNext)
			call s__AHashTable_storeHandleInteger(AGetCharacterHashTable(),s__AClassSelection_changeNextTrigger[this] , "classSelection" , this) //AClassCharacterCharacterHashTable
			set triggerEvent = null
			set triggerAction = null
  endfunction

  function s__AClassSelection_triggerActionSelectClass takes nothing returns nothing
   local trigger triggeringTrigger= GetTriggeringTrigger()
   local integer classSelection= s__AHashTable_getHandleInteger(AGetCharacterHashTable(),triggeringTrigger , "classSelection")
			call s__AClassSelection_selectClass(classSelection)
			set triggeringTrigger = null
  endfunction

  function s__AClassSelection_createSelectTrigger takes integer this returns nothing
   local event triggerEvent
   local triggeraction triggerAction
			set s__AClassSelection_selectTrigger[this]=CreateTrigger()
			set triggerEvent = TriggerRegisterKeyEventForPlayer(s__AClassSelection_user[this] , s__AClassSelection_selectTrigger[this] , KEY_ESCAPE , true) //ALibraryInterfaceMisc
			set triggerAction = TriggerAddAction(s__AClassSelection_selectTrigger[this] , function s__AClassSelection_triggerActionSelectClass)
			call s__AHashTable_storeHandleInteger(AGetCharacterHashTable(),s__AClassSelection_selectTrigger[this] , "classSelection" , this) //AClassCharacterCharacterHashTable
			set triggerEvent = null
			set triggerAction = null
  endfunction

		//release test
  function s__AClassSelection_createInfoSheet takes integer this returns nothing
   local integer i
   local multiboarditem multiboardItem
			set s__AClassSelection_infoSheet[this]=CreateMultiboard()
			call MultiboardSetColumnCount(s__AClassSelection_infoSheet[this] , 1)
			call MultiboardSetRowCount(s__AClassSelection_infoSheet[this] , s__AClassSelection_maxInfoSheetItems)
			set i = 0
			loop
				exitwhen ( i == s__AClassSelection_maxInfoSheetItems )
				set multiboardItem = MultiboardGetItem(s__AClassSelection_infoSheet[this] , i , 0)
				if ( i < s__AClassSelection_maxInfoSheetIconItems ) then
					call MultiboardSetItemStyle(multiboardItem , true , true)
				else
					call MultiboardSetItemStyle(multiboardItem , true , false)
				endif
				call MultiboardReleaseItem(multiboardItem)
				set multiboardItem = null
				set i = i + 1
			endloop
			call MultiboardSetItemsWidth(s__AClassSelection_infoSheet[this] , 0.20)

			//strength
			set multiboardItem = MultiboardGetItem(s__AClassSelection_infoSheet[this] , 0 , 0)
			call MultiboardSetItemIcon(multiboardItem , s__AClassSelection_strengthIconPath)
			call MultiboardReleaseItem(multiboardItem)
			set multiboardItem = null
			//agility
			set multiboardItem = MultiboardGetItem(s__AClassSelection_infoSheet[this] , 1 , 0)
			call MultiboardSetItemIcon(multiboardItem , s__AClassSelection_agilityIconPath)
			call MultiboardReleaseItem(multiboardItem)
			set multiboardItem = null
			//intelligence
			set multiboardItem = MultiboardGetItem(s__AClassSelection_infoSheet[this] , 2 , 0)
			call MultiboardSetItemIcon(multiboardItem , s__AClassSelection_intelligenceIconPath)
			call MultiboardReleaseItem(multiboardItem)
			set multiboardItem = null
			//abilities
			set multiboardItem = MultiboardGetItem(s__AClassSelection_infoSheet[this] , 3 , 0)
			call MultiboardSetItemValue(multiboardItem , s__AClassSelection_textAbilities + ": ")
			call MultiboardReleaseItem(multiboardItem)
			set multiboardItem = null
			//description
			set multiboardItem = MultiboardGetItem(s__AClassSelection_infoSheet[this] , s__AClassSelection_maxInfoSheetIconItems , 0)
			call MultiboardSetItemValue(multiboardItem , s__AClassSelection_textDescription + ": ")
			call MultiboardReleaseItem(multiboardItem)
			set multiboardItem = null
  endfunction

  function s__AClassSelection_create takes player user,real startX,real startY,real startFacing,integer selectClassAction returns integer
   local integer this= s__AClassSelection__allocate()
			//start properties
    call Print("1")
			set s__AClassSelection_user[this]=user
			set s__AClassSelection_startFacing[this]=startFacing
    call Print("2")
			set s__AClassSelection_startX[this]=startX
			set s__AClassSelection_startY[this]=startY
			set s__AClassSelection_selectClassAction[this]=selectClassAction
			//properties
			set s__AClassSelection_class[this]=s__AClassSelection_firstClass
    call Print("FIRST CLASS " + I2S(s__AClassSelection_firstClass))
			//static properties
			set s__AClassSelection_stack=s__AClassSelection_stack + 1
    call Print("3")

			call s__AClassSelection_createRefreshTrigger(this)
    call Print("4")
			call s__AClassSelection_createChangePreviousTrigger(this)
    call Print("5")
			call s__AClassSelection_createChangeNextTrigger(this)
    call Print("6")
			call s__AClassSelection_createSelectTrigger(this)
    call Print("Before Info Sheet")
			call s__AClassSelection_createInfoSheet(this)
    call Print("After Info Sheet")
			return this
  endfunction

  function s__AClassSelection_destroyRefreshTrigger takes integer this returns nothing
			call s__AHashTable_destroyTrigger(AGetCharacterHashTable(),s__AClassSelection_refreshTrigger[this]) //AClassCharacterCharacterHashTable
			set s__AClassSelection_refreshTrigger[this]=null
  endfunction

  function s__AClassSelection_destroyChangePreviousTrigger takes integer this returns nothing
			call s__AHashTable_destroyTrigger(AGetCharacterHashTable(),s__AClassSelection_changePreviousTrigger[this]) //AClassCharacterCharacterHashTable
			set s__AClassSelection_changePreviousTrigger[this]=null
  endfunction

  function s__AClassSelection_destroyChangeNextTrigger takes integer this returns nothing
			call s__AHashTable_destroyTrigger(AGetCharacterHashTable(),s__AClassSelection_changeNextTrigger[this]) //AClassCharacterCharacterHashTable
			set s__AClassSelection_changeNextTrigger[this]=null
  endfunction

  function s__AClassSelection_destroySelectTrigger takes integer this returns nothing
			call s__AHashTable_destroyTrigger(AGetCharacterHashTable(),s__AClassSelection_selectTrigger[this]) //AClassCharacterCharacterHashTable
			set s__AClassSelection_selectTrigger[this]=null
  endfunction

  function s__AClassSelection_destroyInfoSheet takes integer this returns nothing
			call DestroyMultiboard(s__AClassSelection_infoSheet[this])
			set s__AClassSelection_infoSheet[this]=null
  endfunction
		
  function s__AClassSelection_removeClassUnit takes integer this returns nothing
			call RemoveUnit(s__AClassSelection_classUnit[this])
			set s__AClassSelection_classUnit[this]=null
  endfunction

  function s__AClassSelection_onDestroy takes integer this returns nothing
			//start members
			set s__AClassSelection_user[this]=null
			//static members
			set s__AClassSelection_stack=s__AClassSelection_stack - 1

			call s__AClassSelection_destroyRefreshTrigger(this)
			call s__AClassSelection_destroyChangePreviousTrigger(this)
			call s__AClassSelection_destroyChangeNextTrigger(this)
			call s__AClassSelection_destroySelectTrigger(this)
			call s__AClassSelection_destroyInfoSheet(this)
			call s__AClassSelection_removeClassUnit(this)
  endfunction

//Generated destructor of AClassSelection
function s__AClassSelection_destroy takes integer this returns nothing
    if this==null then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: AClassSelection")
        return
    elseif (si__AClassSelection_V[this]!=-1) then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: AClassSelection")
        return
    endif
    call s__AClassSelection_onDestroy(this)
    set si__AClassSelection_V[this]=si__AClassSelection_F
    set si__AClassSelection_F=this
endfunction
		
  function s__AClassSelection_init takes camerasetup cameraSetup,real x,real y,real facing,real refreshRate,real rotationAngle,integer firstClass,integer lastClass,integer startGameAction,string strengthIconPath,string agilityIconPath,string intelligenceIconPath,string textStrength,string textAgility,string textIntelligence,string textAbilities,string textDescription returns nothing
			//static start members
			set s__AClassSelection_cameraSetup=cameraSetup
			set s__AClassSelection_x=x
			set s__AClassSelection_y=y
			set s__AClassSelection_facing=facing
			set s__AClassSelection_refreshRate=refreshRate
			set s__AClassSelection_rotationAngle=rotationAngle
			set s__AClassSelection_firstClass=firstClass
			set s__AClassSelection_lastClass=lastClass
			set s__AClassSelection_startGameAction=startGameAction
			set s__AClassSelection_strengthIconPath=strengthIconPath
			set s__AClassSelection_agilityIconPath=agilityIconPath
			set s__AClassSelection_intelligenceIconPath=intelligenceIconPath
			set s__AClassSelection_textStrength=textStrength
			set s__AClassSelection_textAgility=textAgility
			set s__AClassSelection_textIntelligence=textIntelligence
			set s__AClassSelection_textAbilities=textAbilities
			set s__AClassSelection_textDescription=textDescription
			//static members
			set s__AClassSelection_stack=0
  endfunction


//library AStructSystemsCharacterClassSelection ends
//library AStructSystemsCharacterFocus:

		//static start members
		//members

  function s__AFocus_enable takes integer this returns nothing
			call EnableTrigger(s__AFocus_focusTrigger[this])
			call ShowTextTagForPlayer(s__AAbstractCharacterSystem_getUser(this) , s__AFocus_textTag[this] , true) //ALibraryInterfaceTextTag
			call EnableTrigger(s__AFocus_workerTrigger[this])
  endfunction

  function s__AFocus_disable takes integer this returns nothing
			call DisableTrigger(s__AFocus_focusTrigger[this])
			call ShowTextTagForPlayer(s__AAbstractCharacterSystem_getUser(this) , s__AFocus_textTag[this] , false) //ALibraryInterfaceTextTag
			call DisableTrigger(s__AFocus_workerTrigger[this])
  endfunction

  function s__AFocus_isTargetInFocus takes integer this returns boolean
			if ( GetDistanceBetweenUnits(s__AAbstractCharacterSystem_getUnit(this) , s__AFocus_target[this] , 0.0 , 0.0) > s__AFocus_range ) then //ALibraryGeometryHandle
			//Optional kann man auch mit Z-Wert (Extrafunktion) berprfen lassen, wrde aber mehr Speicher ziehen
				return false
			//Erst berprfen
			elseif ( GetAngleBetweenUnits(s__AAbstractCharacterSystem_getUnit(this) , s__AFocus_target[this]) > s__AFocus_angle ) then //ALibraryMathsHandle
				return false
			endif
			return true
  endfunction

		//Don't destroy the group!
  function s__AFocus_getNearestTarget takes integer this,group usedGroup returns unit
   local unit first= null
   local unit nearest= null
			loop
				set first = FirstOfGroup(usedGroup)
				exitwhen ( first == null )
				if ( s__AAbstractCharacterSystem_getUnit(this) != first ) then //Darf sich nicht selbst anvisieren
					if ( ( nearest == null ) or ( GetDistanceBetweenUnits(s__AAbstractCharacterSystem_getUnit(this) , first , 0.0 , 0.0) < GetDistanceBetweenUnits(s__AAbstractCharacterSystem_getUnit(this) , nearest , 0.0 , 0.0) ) ) then //ALibraryMathsHandle
						set nearest = first
					endif
				endif
				call GroupRemoveUnit(usedGroup , first)
				set first = null
			endloop
			return nearest
  endfunction

  function s__AFocus_getTargetName takes integer this returns string
   local integer state= GetUnitAllianceStateToUnit(s__AAbstractCharacterSystem_getUnit(this) , s__AFocus_target[this]) //ALibraryEnvironmentUnit
   local string colour
			if ( state == bj_ALLIANCE_UNALLIED ) then
				set colour = "|c00ff0000"
			elseif ( state == bj_ALLIANCE_ALLIED ) then
				set colour = "|c0000ff00"
			else //Neutral
				set colour = "|c00ffcc00"
			endif
			return ( colour + GetUnitName(s__AFocus_target[this]) + "|r " + s__AFocus_textLevel + ":" + I2S(GetUnitLevel(s__AFocus_target[this])) )
  endfunction

  function s__AFocus_showTargetText takes integer this returns nothing
			if ( s__AFocus_showText ) then
				call SetTextTagTextBJ(s__AFocus_textTag[this] , s__AFocus_getTargetName(this) , 12.0)
				call SetTextTagPos(s__AFocus_textTag[this] , GetUnitX(s__AFocus_target[this]) , GetUnitY(s__AFocus_target[this]) , ( GetUnitFlyHeight(s__AFocus_target[this]) + 70.0 ))
				call ShowTextTagForPlayer(s__AAbstractCharacterSystem_getUser(this) , s__AFocus_textTag[this] , true) //ALibraryInterfaceTextTag
			endif
  endfunction

  function s__AFocus_indicateTheTarget takes integer this,real red,real green,real blue,real alpha returns nothing
			if ( s__AFocus_indicateTarget ) then
				call SetUnitVertexColourForPlayer(s__AAbstractCharacterSystem_getUser(this) , s__AFocus_target[this] , red , green , blue , alpha) //ALibraryInterfaceMisc
			endif
  endfunction

  function s__AFocus_getNewTarget takes integer this returns nothing
   local real x1= GetUnitX(s__AAbstractCharacterSystem_getUnit(this))
   local real y1= GetUnitY(s__AAbstractCharacterSystem_getUnit(this))
   local real x3= GetUnitPolarProjectionX(s__AAbstractCharacterSystem_getUnit(this) , ( GetUnitFacing(s__AAbstractCharacterSystem_getUnit(this)) + s__AFocus_angle ) , s__AFocus_range) //ALibraryMathsHandle
   local real y3= GetUnitPolarProjectionY(s__AAbstractCharacterSystem_getUnit(this) , ( GetUnitFacing(s__AAbstractCharacterSystem_getUnit(this)) + s__AFocus_angle ) , s__AFocus_range) //ALibraryMathsHandle
   local real x4= GetUnitPolarProjectionX(s__AAbstractCharacterSystem_getUnit(this) , ( GetUnitFacing(s__AAbstractCharacterSystem_getUnit(this)) - s__AFocus_angle ) , s__AFocus_range) //ALibraryMathsHandle
   local real y4= GetUnitPolarProjectionY(s__AAbstractCharacterSystem_getUnit(this) , ( GetUnitFacing(s__AAbstractCharacterSystem_getUnit(this)) - s__AFocus_angle ) , s__AFocus_range) //ALibraryMathsHandle
   local group targetGroup= GetGroupInRectByCoordinates(x1 , y1 , x1 , y1 , x3 , y3 , x4 , y4) //ALibraryMathsRect
    if ( IsUnitGroupEmptyBJ(targetGroup) ) then
     call Print("Group is empty")
    else
     call Print("Group is not empty")
    endif
			set s__AFocus_target[this]=s__AFocus_getNearestTarget(this,targetGroup) //Gruppe wird verndert
			call DestroyGroup(targetGroup)
			set targetGroup = null
			if ( s__AFocus_target[this] == null ) then
				call ShowTextTagForPlayer(s__AAbstractCharacterSystem_getUser(this) , s__AFocus_textTag[this] , false)
				return 
			endif
			call s__AFocus_showTargetText(this)
			call s__AFocus_indicateTheTarget(this,100.0 , 50.0 , 50.0 , 0.0)
  endfunction

  function s__AFocus_triggerActionFocus takes nothing returns nothing
   local trigger triggeringTrigger= GetTriggeringTrigger()
   local integer focus= s__AHashTable_getHandleInteger(AGetCharacterHashTable(),triggeringTrigger , "focus") //AClassCharacterCharacterHashTable
			//Hat bereits ein Ziel
			if ( s__AFocus_target[focus] != null ) then
				//Altes Objekt ist auer Reichweite - Bentige neues Ziel
				if ( not s__AFocus_isTargetInFocus(focus) ) then
					call s__AFocus_indicateTheTarget(focus,100.0 , 100.0 , 100.0 , 0.0)
					call s__AFocus_getNewTarget(focus)
				endif
			//Hat kein Ziel
			else
				call s__AFocus_getNewTarget(focus)
			endif
			set triggeringTrigger = null
  endfunction

  function s__AFocus_createFocusTrigger takes integer this returns nothing
   local event triggerEvent
   local triggeraction triggerAction
			set s__AFocus_focusTrigger[this]=CreateTrigger()
			set triggerEvent = TriggerRegisterTimerEvent(s__AFocus_focusTrigger[this] , s__AFocus_refreshRate , true)
			set triggerAction = TriggerAddAction(s__AFocus_focusTrigger[this] , function s__AFocus_triggerActionFocus)
			call s__AHashTable_storeHandleInteger(AGetCharacterHashTable(),s__AFocus_focusTrigger[this] , "focus" , this) //AClassCharacterCharacterHashTable
			set triggerEvent = null
			set triggerAction = null
  endfunction

  function s__AFocus_createTextTag takes integer this returns nothing
			set s__AFocus_textTag[this]=CreateTextTag()
			call SetTextTagVisibility(s__AFocus_textTag[this] , false)
  endfunction

  function s__AFocus_createWorkerTrigger takes integer this returns nothing
   local event triggerEvent
   local triggeraction triggerAction
			//set this.worker = CreateUnit(this.getCharacter().getUser(), AFocus.workerUnitType, 

			set s__AFocus_workerTrigger[this]=CreateTrigger()
			//Noch ausarbeiten
  endfunction

  function s__AFocus_create takes integer character returns integer
   local integer this= s__AFocus__allocate(character)
			//members
			set s__AFocus_fixedTarget[this]=false

			call s__AFocus_createFocusTrigger(this)
			call s__AFocus_createTextTag(this)
			call s__AFocus_createWorkerTrigger(this)
			return this
  endfunction

  function s__AFocus_destroyFocusTrigger takes integer this returns nothing
			call s__AHashTable_destroyTrigger(AGetCharacterHashTable(),s__AFocus_focusTrigger[this]) //AClassCharacterCharacterHashTable
			set s__AFocus_focusTrigger[this]=null
  endfunction

  function s__AFocus_destroyTextTag takes integer this returns nothing
			call DestroyTextTag(s__AFocus_textTag[this])
			set s__AFocus_textTag[this]=null
  endfunction

  function s__AFocus_destroyWorkerTrigger takes integer this returns nothing
			call RemoveUnit(s__AFocus_worker[this])
			set s__AFocus_worker[this]=null
			call s__AHashTable_destroyTrigger(AGetCharacterHashTable(),s__AFocus_workerTrigger[this]) //AClassCharacterCharacterHashTable
			set s__AFocus_workerTrigger[this]=null
  endfunction

  function s__AFocus_onDestroy takes integer this returns nothing

			call s__AFocus_destroyFocusTrigger(this)
			call s__AFocus_destroyTextTag(this)
			call s__AFocus_destroyWorkerTrigger(this)
  endfunction

		/// @param refreshRate 1.0 //If this value is 0.0 there is no text
		/// @param range 500.0
		/// @param angle 30.0 //Grad 0-360
		/// @param workerUnitType 'HPEA'
		/// @param showText true
		/// @param indicateTarget true
		/// @param textLevel Stufe
  function s__AFocus_init takes real refreshRate,real range,real angle,integer workerUnitType,boolean showText,boolean indicateTarget,string textLevel returns nothing
			//static start members
			set s__AFocus_refreshRate=refreshRate
			set s__AFocus_range=range
			set s__AFocus_angle=angle
			set s__AFocus_workerUnitType=workerUnitType
			set s__AFocus_showText=showText
			set s__AFocus_indicateTarget=indicateTarget
			set s__AFocus_textLevel=textLevel
  endfunction


//library AStructSystemsCharacterFocus ends
//library AStructSystemsCharacterItemType:

	/// Represents an item type, not an item object!
		//static constant members
		//static start members
		//start members

		//start members

		/// Friend relation to AInventory, don't use
  function s__AItemType_getEquipmentType takes integer this returns integer
			return s__AItemType_equipmentType[this]
  endfunction

		//methods

  function s__AItemType_checkRequirement takes integer this,integer character returns boolean
			if ( GetHeroLevel(s__ACharacter_getUsedUnit(character)) < s__AItemType_requiredLevel[this] ) then //AClassCharacterCharacter
				call s__ACharacter_displayMessage(character,s__ACharacter_messageTypeError , s__AItemType_textLevel) //AClassCharacterCharacter
				return false
			elseif ( GetHeroStr(s__ACharacter_getUsedUnit(character) , true) < s__AItemType_requiredStrength[this] ) then //AClassCharacterCharacter
				call s__ACharacter_displayMessage(character,s__ACharacter_messageTypeError , s__AItemType_textStrength) //AClassCharacterCharacter
				return false
			elseif ( GetHeroAgi(s__ACharacter_getUsedUnit(character) , true) < s__AItemType_requiredAgility[this] ) then //AClassCharacterCharacter
				call s__ACharacter_displayMessage(character,s__ACharacter_messageTypeError , s__AItemType_textAgility) //AClassCharacterCharacter
				return false
			elseif ( GetHeroInt(s__ACharacter_getUsedUnit(character) , true) < s__AItemType_requiredIntelligence[this] ) then //AClassCharacterCharacter
				call s__ACharacter_displayMessage(character,s__ACharacter_messageTypeError , s__AItemType_textIntelligence) //AClassCharacterCharacter
				return false
			elseif ( s__AItemType_requiredClass[this] != 0 and s__ACharacter_getClass(character) != s__AItemType_requiredClass[this] ) then //AClassCharacterCharacter
				call s__ACharacter_displayMessage(character,s__ACharacter_messageTypeError , s__AItemType_textClass) //AClassCharacterCharacter
				return false
			endif
			return true
  endfunction

  function s__AItemType_create takes integer itemType,integer equipmentType,integer requiredLevel,integer requiredStrength,integer requiredAgility,integer requiredIntelligence,integer requiredClass returns integer
   local integer this= s__AItemType__allocate()
			//start members
			set s__AItemType_itemType[this]=itemType
			set s__AItemType_equipmentType[this]=equipmentType
			set s__AItemType_requiredLevel[this]=requiredLevel
			set s__AItemType_requiredStrength[this]=requiredStrength
			set s__AItemType_requiredAgility[this]=requiredAgility
			set s__AItemType_requiredIntelligence[this]=requiredIntelligence
			set s__AItemType_requiredClass[this]=requiredClass

    if ( s__AHashTable_getStoredInteger(AGetCharacterHashTable(),"AItemTypes" , I2S(s__AItemType_itemType[this])) != 0 ) then
     call Print("Item type " + I2S(this) + " already has an item type.")
    endif
			call s__AHashTable_storeInteger(AGetCharacterHashTable(),"AItemTypes" , I2S(s__AItemType_itemType[this]) , this) //AClassCharacterCharacterHashTable
			return this
  endfunction

  function s__AItemType_onDestroy takes integer this returns nothing
			call s__AHashTable_flushStoredInteger(AGetCharacterHashTable(),"AItemTypes" , I2S(s__AItemType_itemType[this])) //AClassCharacterCharacterHashTable
  endfunction

//Generated destructor of AItemType
function s__AItemType_destroy takes integer this returns nothing
    if this==null then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: AItemType")
        return
    elseif (si__AItemType_V[this]!=-1) then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: AItemType")
        return
    endif
    call s__AItemType_onDestroy(this)
    set si__AItemType_V[this]=si__AItemType_F
    set si__AItemType_F=this
endfunction

  function s__AItemType_init takes string textLevel,string textStrength,string textAgility,string textIntelligence,string textClass returns nothing
			//static start members
			set s__AItemType_textLevel=textLevel
			set s__AItemType_textStrength=textStrength
			set s__AItemType_textAgility=textAgility
			set s__AItemType_textIntelligence=textIntelligence
			set s__AItemType_textClass=textClass
  endfunction

  function s__AItemType_getItemTypeOfItemType takes integer itemType returns integer
			return s__AHashTable_getStoredInteger(AGetCharacterHashTable(),"AItemTypes" , I2S(itemType)) //AClassCharacterCharacterHashTable
  endfunction

		/// @author Tamino Dauth
  function s__AItemType_getItemTypeOfItem takes item usedItem returns integer
			return s__AItemType_getItemTypeOfItemType(GetItemTypeId(usedItem))
  endfunction


//library AStructSystemsCharacterItemType ends
//library AStructSystemsCharacterMovement:

	//Die Blocker-Suche noch weiter ausarbeiten und auch die Entfernung für die Kamera damit berechnen
	//Herausfinden wir man Parameter in die Funktion der Blocker übergeben kann.
	//private function FilterFunctionIsDestructableBlocker takes nothing returns boolean
		//local destructable FilterDestructable = GetFilterDestructable()
		//local boolean Result = false
		//if (GetDestructableTypeId(FilterDestructable) == 'YTpb') then //Verlauf-Blocker Boden
		//set Result = true
		//elseif (GetDestructableTypeId(FilterDestructable) == 'YTpc') then  //Verlauf-Blocker Boden (groß)
		//set Result = true
		//elseif (GetDestructableTypeId(FilterDestructable) == 'YTfb') then  //Verlauf-Blocker Beides (groß)
		//set Result = true
		//elseif (GetDestructableTypeId(FilterDestructable) == 'YTfc') then  //Verlauf-Blocker Beides
		//set Result = true
		//endif
		//set FilterDestructable = null
		//return Result
	//endfunction

	//function IsBlockerInRange takes real X, real Y, real Angle, real AngleWidth, real Distance returns boolean
		//local real RealAngle = (AngleWidth / 2.00)
		//local real X1 = GetPolarProjectionX(X, (Angle + RealAngle), 0.00)
		//local real Y1 = GetPolarProjectionY(Y, (Angle + RealAngle), 0.00)
		//local real X2 = GetPolarProjectionX(X, (Angle - RealAngle), Distance)
		//local real Y2 = GetPolarProjectionY(Y, (Angle - RealAngle), Distance)
		//local rect BlockerRect = Rect(X1, Y1, X2, Y2)
		//call EnumDestructablesInRect(BlockerRect, Filter(function FilterFunctionIsDestructableBlocker), null)
		//call RemoveRect(BlockerRect)
		//set BlockerRect = null
		//return false
	//endfunction

		//static constant members
		//static start members
		//members

  function s__AMovement_enable takes integer this returns nothing
   local integer i
			call EnableTrigger(s__AMovement_movementTrigger[this])
			set i = 0
			loop
				exitwhen ( i == s__AMovement_maxMovementTriggers )
				call EnableTrigger(s___AMovement_startMovementTrigger[s__AMovement_startMovementTrigger[this]+i])
				set i = i + 1
			endloop
  endfunction

  function s__AMovement_disable takes integer this returns nothing
   local integer i
			call DisableTrigger(s__AMovement_movementTrigger[this])
			set i = 0
			loop
				exitwhen ( i == s__AMovement_maxMovementTriggers )
				call DisableTrigger(s___AMovement_startMovementTrigger[s__AMovement_startMovementTrigger[this]+i])
				set i = i + 1
			endloop
  endfunction

  function s__AMovement_moveToPoint takes integer this,real x,real y returns nothing
			if ( not IsTerrainPathable(x , y , PATHING_TYPE_WALKABILITY) ) then
				call SetUnitPosition(s__AAbstractCharacterSystem_getUnit(this) , x , y)
			endif
  endfunction

  function s__AMovement_moveForward takes integer this returns nothing
   local real facing= GetUnitFacing(s__AAbstractCharacterSystem_getUnit(this))
   local real x= GetUnitX(s__AAbstractCharacterSystem_getUnit(this))
   local real y= GetUnitY(s__AAbstractCharacterSystem_getUnit(this))
			set x = x + s__AMovement_speed * Cos(facing * bj_DEGTORAD)
            		set y = y + s__AMovement_speed * Sin(facing * bj_DEGTORAD)
			call s__AMovement_moveToPoint(this,x , y)
    call Print("move forward")
  endfunction

  function s__AMovement_moveBackward takes integer this returns nothing
   local real facing= GetUnitFacing(s__AAbstractCharacterSystem_getUnit(this))
   local real x= GetUnitX(s__AAbstractCharacterSystem_getUnit(this))
   local real y= GetUnitY(s__AAbstractCharacterSystem_getUnit(this))
			set x = x - s__AMovement_speed * Cos(facing * bj_DEGTORAD)
			set y = y - s__AMovement_speed * Sin(facing * bj_DEGTORAD)
			call s__AMovement_moveToPoint(this,x , y)
    call Print("move backward")
  endfunction

  function s__AMovement_moveRightForward takes integer this returns nothing
   local real facing= GetUnitFacing(s__AAbstractCharacterSystem_getUnit(this))
   local real x= GetUnitX(s__AAbstractCharacterSystem_getUnit(this))
   local real y= GetUnitY(s__AAbstractCharacterSystem_getUnit(this))
			set x = x + s__AMovement_speed * Cos(( facing - s__AMovement_angle ) * bj_DEGTORAD)
            		set y = y + s__AMovement_speed * Sin(( facing - s__AMovement_angle ) * bj_DEGTORAD)
			call s__AMovement_moveToPoint(this,x , y)
  endfunction

  function s__AMovement_moveRightBackward takes integer this returns nothing
   local real facing= GetUnitFacing(s__AAbstractCharacterSystem_getUnit(this))
   local real x= GetUnitX(s__AAbstractCharacterSystem_getUnit(this))
   local real y= GetUnitY(s__AAbstractCharacterSystem_getUnit(this))
			set x = x - s__AMovement_speed * Cos(( facing + s__AMovement_angle ) * bj_DEGTORAD)
            		set y = y - s__AMovement_speed * Sin(( facing + s__AMovement_angle ) * bj_DEGTORAD)
			call s__AMovement_moveToPoint(this,x , y)
  endfunction

  function s__AMovement_moveLeftForward takes integer this returns nothing
   local real facing= GetUnitFacing(s__AAbstractCharacterSystem_getUnit(this))
   local real x= GetUnitX(s__AAbstractCharacterSystem_getUnit(this))
   local real y= GetUnitY(s__AAbstractCharacterSystem_getUnit(this))
			set x = x + s__AMovement_speed * Cos(( facing + s__AMovement_angle ) * bj_DEGTORAD)
            		set y = y + s__AMovement_speed * Sin(( facing + s__AMovement_angle ) * bj_DEGTORAD)
			call s__AMovement_moveToPoint(this,x , y)
  endfunction

  function s__AMovement_moveLeftBackward takes integer this returns nothing
   local real facing= GetUnitFacing(s__AAbstractCharacterSystem_getUnit(this))
   local real x= GetUnitX(s__AAbstractCharacterSystem_getUnit(this))
   local real y= GetUnitY(s__AAbstractCharacterSystem_getUnit(this))
			set x = x - s__AMovement_speed * Cos(( facing - s__AMovement_angle ) * bj_DEGTORAD)
            		set y = y - s__AMovement_speed * Sin(( facing - s__AMovement_angle ) * bj_DEGTORAD)
			call s__AMovement_moveToPoint(this,x , y)
  endfunction

  function s__AMovement_turnRight takes integer this returns nothing
   local real facingAngle= GetUnitFacing(s__AAbstractCharacterSystem_getUnit(this)) - s__AMovement_angle
			call SetUnitFacingTimed(s__AAbstractCharacterSystem_getUnit(this) , facingAngle , s__AMovement_refreshRate + 0.5)
  endfunction
		
  function s__AMovement_turnLeft takes integer this returns nothing
   local real facingAngle= GetUnitFacing(s__AAbstractCharacterSystem_getUnit(this)) + s__AMovement_angle
			call SetUnitFacingTimed(s__AAbstractCharacterSystem_getUnit(this) , facingAngle , s__AMovement_refreshRate + 0.5)
  endfunction
		
  function s__AMovement_stop takes integer this returns nothing
			call IssueImmediateOrder(s__AAbstractCharacterSystem_getUnit(this) , "holdposition")
  endfunction

  function s__AMovement_triggerActionMovement takes nothing returns nothing
   local trigger triggeringTrigger= GetTriggeringTrigger()
   local integer movement= s__AHashTable_getHandleInteger(AGetCharacterHashTable(),triggeringTrigger , "movement") //AClassCharacterCharacterHashTable
			if ( s___AMovement_state[s__AMovement_state[movement]+s__AMovement_stateMoveForward] ) then
				if ( s___AMovement_state[s__AMovement_state[movement]+s__AMovement_stateTurnRight] ) then
					call s__AMovement_moveRightForward(movement)
				elseif ( s___AMovement_state[s__AMovement_state[movement]+s__AMovement_stateTurnLeft] ) then
					call s__AMovement_moveLeftForward(movement)
				else
					call s__AMovement_moveForward(movement)
				endif
			elseif ( s___AMovement_state[s__AMovement_state[movement]+s__AMovement_stateMoveBackward] ) then
				if ( s___AMovement_state[s__AMovement_state[movement]+s__AMovement_stateTurnRight] ) then
					call s__AMovement_moveRightBackward(movement)
				elseif ( s___AMovement_state[s__AMovement_state[movement]+s__AMovement_stateTurnLeft] ) then
					call s__AMovement_moveLeftBackward(movement)
				else
					call s__AMovement_moveBackward(movement)
				endif
			elseif ( s___AMovement_state[s__AMovement_state[movement]+s__AMovement_stateTurnRight] ) then
				call s__AMovement_turnRight(movement)
			elseif ( s___AMovement_state[s__AMovement_state[movement]+s__AMovement_stateTurnLeft] ) then
				call s__AMovement_turnLeft(movement)
			elseif ( s__AMovement_stopWhileStanding ) then
				call s__AMovement_stop(movement)
			endif //Stop wird in den Start-Aktionen aufgerufen
			set triggeringTrigger = null
  endfunction

  function s__AMovement_triggerActionMoveForward takes nothing returns nothing
   local trigger triggeringTrigger= GetTriggeringTrigger()
   local integer movement= s__AHashTable_getHandleInteger(AGetCharacterHashTable(),triggeringTrigger , "movement") //AClassCharacterCharacterHashTable
			set s___AMovement_state[s__AMovement_state[movement]+s__AMovement_stateMoveBackward]=false
			set s___AMovement_state[s__AMovement_state[movement]+s__AMovement_stateMoveForward]=true
			set triggeringTrigger = null
  endfunction

  function s__AMovement_triggerActionStopMovingForward takes nothing returns nothing
   local trigger triggeringTrigger= GetTriggeringTrigger()
   local integer movement= s__AHashTable_getHandleInteger(AGetCharacterHashTable(),triggeringTrigger , "movement") //AClassCharacterCharacterHashTable
			set s___AMovement_state[s__AMovement_state[movement]+s__AMovement_stateMoveForward]=false
			set triggeringTrigger = null
  endfunction

  function s__AMovement_triggerActionMoveBackward takes nothing returns nothing
   local trigger triggeringTrigger= GetTriggeringTrigger()
   local integer movement= s__AHashTable_getHandleInteger(AGetCharacterHashTable(),triggeringTrigger , "movement") //AClassCharacterCharacterHashTable
			set s___AMovement_state[s__AMovement_state[movement]+s__AMovement_stateMoveForward]=false
			set s___AMovement_state[s__AMovement_state[movement]+s__AMovement_stateMoveBackward]=true
			set triggeringTrigger = null
  endfunction

  function s__AMovement_triggerActionStopMovingBackward takes nothing returns nothing
   local trigger triggeringTrigger= GetTriggeringTrigger()
   local integer movement= s__AHashTable_getHandleInteger(AGetCharacterHashTable(),triggeringTrigger , "movement") //AClassCharacterCharacterHashTable
			set s___AMovement_state[s__AMovement_state[movement]+s__AMovement_stateMoveBackward]=false
			set triggeringTrigger = null
  endfunction

  function s__AMovement_triggerActionTurnRight takes nothing returns nothing
   local trigger triggeringTrigger= GetTriggeringTrigger()
   local integer movement= s__AHashTable_getHandleInteger(AGetCharacterHashTable(),triggeringTrigger , "movement") //AClassCharacterCharacterHashTable
			set s___AMovement_state[s__AMovement_state[movement]+s__AMovement_stateTurnLeft]=false
			set s___AMovement_state[s__AMovement_state[movement]+s__AMovement_stateTurnRight]=true
			set triggeringTrigger = null
  endfunction

  function s__AMovement_triggerActionStopTurningRight takes nothing returns nothing
   local trigger triggeringTrigger= GetTriggeringTrigger()
   local integer movement= s__AHashTable_getHandleInteger(AGetCharacterHashTable(),triggeringTrigger , "movement") //AClassCharacterCharacterHashTable
			set s___AMovement_state[s__AMovement_state[movement]+s__AMovement_stateTurnRight]=false
			set triggeringTrigger = null
  endfunction

  function s__AMovement_triggerActionTurnLeft takes nothing returns nothing
   local trigger triggeringTrigger= GetTriggeringTrigger()
   local integer movement= s__AHashTable_getHandleInteger(AGetCharacterHashTable(),triggeringTrigger , "movement") //AClassCharacterCharacterHashTable
			set s___AMovement_state[s__AMovement_state[movement]+s__AMovement_stateTurnRight]=false
			set s___AMovement_state[s__AMovement_state[movement]+s__AMovement_stateTurnLeft]=true
			set triggeringTrigger = null
  endfunction

  function s__AMovement_triggerActionStopTurningLeft takes nothing returns nothing
   local trigger triggeringTrigger= GetTriggeringTrigger()
   local integer movement= s__AHashTable_getHandleInteger(AGetCharacterHashTable(),triggeringTrigger , "movement") //AClassCharacterCharacterHashTable
			set s___AMovement_state[s__AMovement_state[movement]+s__AMovement_stateTurnLeft]=false
			set triggeringTrigger = null
  endfunction

  function s__AMovement_createMovementTriggers takes integer this returns nothing
   local event triggerEvent
   local triggeraction triggerAction

			set s__AMovement_movementTrigger[this]=CreateTrigger()
			set triggerEvent = TriggerRegisterTimerEvent(s__AMovement_movementTrigger[this] , s__AMovement_refreshRate , true)
			set triggerAction = TriggerAddAction(s__AMovement_movementTrigger[this] , function s__AMovement_triggerActionMovement)
			call s__AHashTable_storeHandleInteger(AGetCharacterHashTable(),s__AMovement_movementTrigger[this] , "movement" , this) //AClassCharacterCharacterHashTable
			set triggerEvent = null
			set triggerAction = null

			if ( not s__AMovement_useFps ) then
				//forward
				set s___AMovement_startMovementTrigger[s__AMovement_startMovementTrigger[this]]=CreateTrigger()
				set triggerEvent = TriggerRegisterKeyEventForPlayer(s__AAbstractCharacterSystem_getUser(this) , s___AMovement_startMovementTrigger[s__AMovement_startMovementTrigger[this]] , KEY_UP , true) //ALibraryInterfaceMisc
				set triggerAction = TriggerAddAction(s___AMovement_startMovementTrigger[s__AMovement_startMovementTrigger[this]] , function s__AMovement_triggerActionMoveForward)
				call s__AHashTable_storeHandleInteger(AGetCharacterHashTable(),s___AMovement_startMovementTrigger[s__AMovement_startMovementTrigger[this]] , "movement" , this) //AClassCharacterCharacterHashTable
				set triggerEvent = null
				set triggerAction = null
	
				//stop forward
				set s___AMovement_startMovementTrigger[s__AMovement_startMovementTrigger[this]+1]=CreateTrigger()
				set triggerEvent = TriggerRegisterKeyEventForPlayer(s__AAbstractCharacterSystem_getUser(this) , s___AMovement_startMovementTrigger[s__AMovement_startMovementTrigger[this]+1] , KEY_UP , false) //ALibraryInterfaceMisc
				set triggerAction = TriggerAddAction(s___AMovement_startMovementTrigger[s__AMovement_startMovementTrigger[this]+1] , function s__AMovement_triggerActionStopMovingForward)
				call s__AHashTable_storeHandleInteger(AGetCharacterHashTable(),s___AMovement_startMovementTrigger[s__AMovement_startMovementTrigger[this]+1] , "movement" , this) //AClassCharacterCharacterHashTable
				set triggerEvent = null
				set triggerAction = null
	
				//backward
				set s___AMovement_startMovementTrigger[s__AMovement_startMovementTrigger[this]+2]=CreateTrigger()
				set triggerEvent = TriggerRegisterKeyEventForPlayer(s__AAbstractCharacterSystem_getUser(this) , s___AMovement_startMovementTrigger[s__AMovement_startMovementTrigger[this]+2] , KEY_DOWN , true) //ALibraryInterfaceMisc
				set triggerAction = TriggerAddAction(s___AMovement_startMovementTrigger[s__AMovement_startMovementTrigger[this]+2] , function s__AMovement_triggerActionMoveBackward)
				call s__AHashTable_storeHandleInteger(AGetCharacterHashTable(),s___AMovement_startMovementTrigger[s__AMovement_startMovementTrigger[this]+2] , "movement" , this) //AClassCharacterCharacterHashTable
				set triggerEvent = null
				set triggerAction = null
	
				//stop backward
				set s___AMovement_startMovementTrigger[s__AMovement_startMovementTrigger[this]+3]=CreateTrigger()
				set triggerEvent = TriggerRegisterKeyEventForPlayer(s__AAbstractCharacterSystem_getUser(this) , s___AMovement_startMovementTrigger[s__AMovement_startMovementTrigger[this]+3] , KEY_DOWN , false) //ALibraryInterfaceMisc
				set triggerAction = TriggerAddAction(s___AMovement_startMovementTrigger[s__AMovement_startMovementTrigger[this]+3] , function s__AMovement_triggerActionStopMovingBackward)
				call s__AHashTable_storeHandleInteger(AGetCharacterHashTable(),s___AMovement_startMovementTrigger[s__AMovement_startMovementTrigger[this]+3] , "movement" , this) //AClassCharacterCharacterHashTable
				set triggerEvent = null
				set triggerAction = null
	
				//right
				set s___AMovement_startMovementTrigger[s__AMovement_startMovementTrigger[this]+4]=CreateTrigger()
				set triggerEvent = TriggerRegisterKeyEventForPlayer(s__AAbstractCharacterSystem_getUser(this) , s___AMovement_startMovementTrigger[s__AMovement_startMovementTrigger[this]+4] , KEY_RIGHT , true) //ALibraryInterfaceMisc
				set triggerAction = TriggerAddAction(s___AMovement_startMovementTrigger[s__AMovement_startMovementTrigger[this]+4] , function s__AMovement_triggerActionTurnRight)
				call s__AHashTable_storeHandleInteger(AGetCharacterHashTable(),s___AMovement_startMovementTrigger[s__AMovement_startMovementTrigger[this]+4] , "movement" , this) //AClassCharacterCharacterHashTable
				set triggerEvent = null
				set triggerAction = null
	
				//stop right
				set s___AMovement_startMovementTrigger[s__AMovement_startMovementTrigger[this]+5]=CreateTrigger()
				set triggerEvent = TriggerRegisterKeyEventForPlayer(s__AAbstractCharacterSystem_getUser(this) , s___AMovement_startMovementTrigger[s__AMovement_startMovementTrigger[this]+5] , KEY_RIGHT , false) //ALibraryInterfaceMisc
				set triggerAction = TriggerAddAction(s___AMovement_startMovementTrigger[s__AMovement_startMovementTrigger[this]+5] , function s__AMovement_triggerActionStopTurningRight)
				call s__AHashTable_storeHandleInteger(AGetCharacterHashTable(),s___AMovement_startMovementTrigger[s__AMovement_startMovementTrigger[this]+5] , "movement" , this) //AClassCharacterCharacterHashTable
				set triggerEvent = null
				set triggerAction = null
				
				//left
				set s___AMovement_startMovementTrigger[s__AMovement_startMovementTrigger[this]+6]=CreateTrigger()
				set triggerEvent = TriggerRegisterKeyEventForPlayer(s__AAbstractCharacterSystem_getUser(this) , s___AMovement_startMovementTrigger[s__AMovement_startMovementTrigger[this]+6] , KEY_LEFT , true) //ALibraryInterfaceMisc
				set triggerAction = TriggerAddAction(s___AMovement_startMovementTrigger[s__AMovement_startMovementTrigger[this]+6] , function s__AMovement_triggerActionTurnLeft)
				call s__AHashTable_storeHandleInteger(AGetCharacterHashTable(),s___AMovement_startMovementTrigger[s__AMovement_startMovementTrigger[this]+6] , "movement" , this) //AClassCharacterCharacterHashTable
				set triggerEvent = null
				set triggerAction = null
	
				//stop left
				set s___AMovement_startMovementTrigger[s__AMovement_startMovementTrigger[this]+7]=CreateTrigger()
				set triggerEvent = TriggerRegisterKeyEventForPlayer(s__AAbstractCharacterSystem_getUser(this) , s___AMovement_startMovementTrigger[s__AMovement_startMovementTrigger[this]+7] , KEY_LEFT , false) //ALibraryInterfaceMisc
				set triggerAction = TriggerAddAction(s___AMovement_startMovementTrigger[s__AMovement_startMovementTrigger[this]+7] , function s__AMovement_triggerActionStopTurningLeft)
				call s__AHashTable_storeHandleInteger(AGetCharacterHashTable(),s___AMovement_startMovementTrigger[s__AMovement_startMovementTrigger[this]+7] , "movement" , this) //AClassCharacterCharacterHashTable
				set triggerEvent = null
				set triggerAction = null
			endif
  endfunction

  function s__AMovement_triggerActionFpsUp takes nothing returns nothing
   local trigger triggeringTrigger= GetTriggeringTrigger()
   local integer movement= s__AHashTable_getHandleInteger(AGetCharacterHashTable(),triggeringTrigger , "movement") //AClassCharacterCharacterHashTable
   local integer triggerKey
			if ( triggerKey == s__AMovement_fpsKeyMoveForward ) then
				set s___AMovement_state[s__AMovement_state[movement]+s__AMovement_stateMoveForward]=false
			endif
			if ( triggerKey == s__AMovement_fpsKeyMoveBackward ) then
				set s___AMovement_state[s__AMovement_state[movement]+s__AMovement_stateMoveBackward]=false
			endif
			if ( triggerKey == s__AMovement_fpsKeyTurnRight ) then
				set s___AMovement_state[s__AMovement_state[movement]+s__AMovement_stateTurnRight]=false
			endif
			if ( triggerKey == s__AMovement_fpsKeyTurnLeft ) then
				set s___AMovement_state[s__AMovement_state[movement]+s__AMovement_stateTurnLeft]=false
			endif
			set triggeringTrigger = null
  endfunction

  function s__AMovement_createFpsTriggerUp takes integer this returns nothing
   local triggeraction triggerAction
			if ( s__AMovement_useFps ) then
				set s__AMovement_fpsTriggerUp[this]=CreateTrigger()
				//call TriggerRegisterKeyEvent(this.fpsTriggerUp, 0) //fpscommon.j
				set triggerAction = TriggerAddAction(s__AMovement_fpsTriggerUp[this] , function s__AMovement_triggerActionFpsUp)
				call s__AHashTable_storeHandleInteger(AGetCharacterHashTable(),s__AMovement_fpsTriggerUp[this] , "movement" , this) //AClassCharacterCharacterHashTable
				set triggerAction = null
			endif
  endfunction

  function s__AMovement_triggerActionFpsDown takes nothing returns nothing
   local trigger triggeringTrigger= GetTriggeringTrigger()
   local integer movement= s__AHashTable_getHandleInteger(AGetCharacterHashTable(),triggeringTrigger , "movement") //AClassCharacterCharacterHashTable
   local integer triggerKey
			if ( triggerKey == s__AMovement_fpsKeyMoveForward ) then
				set s___AMovement_state[s__AMovement_state[movement]+s__AMovement_stateMoveForward]=true
			endif
			if ( triggerKey == s__AMovement_fpsKeyMoveBackward ) then
				set s___AMovement_state[s__AMovement_state[movement]+s__AMovement_stateMoveBackward]=true
			endif
			if ( triggerKey == s__AMovement_fpsKeyTurnRight ) then
				set s___AMovement_state[s__AMovement_state[movement]+s__AMovement_stateTurnRight]=true
			endif
			if ( triggerKey == s__AMovement_fpsKeyTurnLeft ) then
				set s___AMovement_state[s__AMovement_state[movement]+s__AMovement_stateTurnLeft]=true
			endif
			set triggeringTrigger = null
  endfunction

  function s__AMovement_createFpsTriggerDown takes integer this returns nothing
   local triggeraction triggerAction
			if ( s__AMovement_useFps ) then
				set s__AMovement_fpsTriggerDown[this]=CreateTrigger()
				//call TriggerRegisterKeyEvent(this.fpsTriggerDown, 1) //fpscommon.j
				set triggerAction = TriggerAddAction(s__AMovement_fpsTriggerDown[this] , function s__AMovement_triggerActionFpsDown)
				call s__AHashTable_storeHandleInteger(AGetCharacterHashTable(),s__AMovement_fpsTriggerDown[this] , "movement" , this) //AClassCharacterCharacterHashTable
				set triggerAction = null
			endif
  endfunction

  function s__AMovement_create takes integer character returns integer
   local integer this= s__AMovement__allocate(character)

			call s__AMovement_createMovementTriggers(this)
			call s__AMovement_createFpsTriggerUp(this)
			call s__AMovement_createFpsTriggerDown(this)
			return this
  endfunction

  function s__AMovement_destroyKeyMovementTriggers takes integer this returns nothing
   local integer i
			call s__AHashTable_destroyTrigger(AGetCharacterHashTable(),s__AMovement_movementTrigger[this]) //AClassCharacterCharacterHashTable
			set s__AMovement_movementTrigger[this]=null
			if ( not s__AMovement_useFps ) then
				set i = 0
				loop
					exitwhen ( i == s__AMovement_maxMovementTriggers )
					call s__AHashTable_destroyTrigger(AGetCharacterHashTable(),s___AMovement_startMovementTrigger[s__AMovement_startMovementTrigger[this]+i]) //AClassCharacterCharacterHashTable
					set s___AMovement_startMovementTrigger[s__AMovement_startMovementTrigger[this]+i]=null
					set i = i + 1
				endloop
			endif
  endfunction

  function s__AMovement_destroyFpsTriggerUp takes integer this returns nothing
			if ( s__AMovement_useFps ) then
				call s__AHashTable_destroyTrigger(AGetCharacterHashTable(),s__AMovement_fpsTriggerUp[this]) //AClassCharacterCharacterHashTable
				set s__AMovement_fpsTriggerUp[this]=null
			endif
  endfunction

  function s__AMovement_destroyFpsTriggerDown takes integer this returns nothing
			if ( s__AMovement_useFps ) then
				call s__AHashTable_destroyTrigger(AGetCharacterHashTable(),s__AMovement_fpsTriggerDown[this]) //AClassCharacterCharacterHashTable
				set s__AMovement_fpsTriggerDown[this]=null
			endif
  endfunction

  function s__AMovement_onDestroy takes integer this returns nothing

			call s__AMovement_destroyKeyMovementTriggers(this)
			call s__AMovement_destroyFpsTriggerUp(this)
			call s__AMovement_destroyFpsTriggerDown(this)
  endfunction

		/// @param useFps false //new implementation
		/// @param fpsKeyMoveForward 87 //W
		/// @param fpsKeyMoveBackward 83 //S
		/// @param fpsKeyTurnRight 68 //D
		/// @param fpsKeyTurnLeft 65 //A
		/// @param refreshRate 0.01
		/// @param speed 5.0
		/// @param angle 90.0
		/// @param stopWhileStanding false //If no key is pressed the
  function s__AMovement_init takes boolean useFps,integer fpsKeyMoveForward,integer fpsKeyMoveBackward,integer fpsKeyTurnRight,integer fpsKeyTurnLeft,real refreshRate,real speed,real angle,boolean stopWhileStanding returns nothing
			//static start members
			set s__AMovement_useFps=useFps
			set s__AMovement_fpsKeyMoveForward=fpsKeyMoveForward
			set s__AMovement_fpsKeyMoveBackward=fpsKeyMoveBackward
			set s__AMovement_fpsKeyTurnRight=fpsKeyTurnRight
			set s__AMovement_fpsKeyTurnLeft=fpsKeyTurnLeft
			set s__AMovement_refreshRate=refreshRate
			set s__AMovement_speed=speed
			set s__AMovement_angle=angle
			set s__AMovement_stopWhileStanding=stopWhileStanding
  endfunction


//library AStructSystemsCharacterMovement ends
//library AStructSystemsCharacterRevival:

		//static start members
		//dynamic members
		//members

//textmacro instance: A_STRUCT_DEBUG("\"ARevival\"")
   function s__ARevival_print takes integer this,string message returns nothing
    call Print("ARevival" + " - " + I2S(this) + ": " + message)
   endfunction

   function s__ARevival_staticPrint takes string message returns nothing
    call Print("ARevival" + ": " + message)
   endfunction
//end of: A_STRUCT_DEBUG("\"ARevival\"")

		//dynamic members

  function s__ARevival_setTime takes integer this,real time returns nothing
			set s__ARevival_time[this]=time
  endfunction

  function s__ARevival_getTime takes integer this returns real
			return s__ARevival_time[this]
  endfunction

  function s__ARevival_setX takes integer this,real x returns nothing
			set s__ARevival_x[this]=x
  endfunction

  function s__ARevival_getX takes integer this returns real
			return s__ARevival_x[this]
  endfunction

  function s__ARevival_setY takes integer this,real y returns nothing
			set s__ARevival_y[this]=y
  endfunction

  function s__ARevival_getY takes integer this returns real
			return s__ARevival_y[this]
  endfunction

  function s__ARevival_setFacing takes integer this,real facing returns nothing
			set s__ARevival_facing[this]=facing
  endfunction

  function s__ARevival_getFacing takes integer this returns real
			return s__ARevival_facing[this]
  endfunction

		//methods

  function s__ARevival_enable takes integer this returns nothing
			call EnableTrigger(s__ARevival_revivalTrigger[this])
			if ( TimerGetRemaining(s__ARevival_usedTimer[this]) > 0.0 ) then
				call PauseTimerBJ(false , s__ARevival_usedTimer[this])
				if ( s__ARevival_showDialog ) then //Der bersicht halber nicht in die Funktion bergeben
					call TimerDialogDisplay(s__ARevival_timerDialog[this] , true)
				endif
			endif
  endfunction

  function s__ARevival_disable takes integer this returns nothing
			call DisableTrigger(s__ARevival_revivalTrigger[this])
			if ( TimerGetRemaining(s__ARevival_usedTimer[this]) > 0.0 ) then
				call PauseTimerBJ(true , s__ARevival_usedTimer[this])
				if ( s__ARevival_showDialog ) then
					call TimerDialogDisplay(s__ARevival_timerDialog[this] , false)
				endif
			endif
  endfunction
		
  function s__ARevival_revive takes integer this returns nothing
			call ReviveHero(s__AAbstractCharacterSystem_getUnit(this) , s__ARevival_x[this] , s__ARevival_y[this] , true)
			call SetUnitFacing(s__AAbstractCharacterSystem_getUnit(this) , s__ARevival_facing[this])
  endfunction

  function s__ARevival_timerFunctionRevival takes nothing returns nothing
   local timer expiredTimer= GetExpiredTimer()
   local integer revival= s__AHashTable_getHandleInteger(AGetCharacterHashTable(),expiredTimer , "revival") //AClassCharacterCharacterHashTable
    call s__ARevival_print(revival,"Finished.")
			call s__ARevival_revive(revival)
			call sc__ARevival_end(revival)
			//select unit
			call s__ACharacter_setMovable(s__AAbstractCharacterSystem_getCharacter(revival),true)
			set expiredTimer = null
  endfunction

  function s__ARevival_start takes integer this returns nothing
    if ( s__ARevival_usedTimer[this] == null ) then
     call s__ARevival_print(this,"TIMER IS NULLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL")
    endif
			call TimerStart(s__ARevival_usedTimer[this] , s__ARevival_time[this] , false , null) //function ARevival.timerFunctionRevival //this.Time //Verursacht Bug
			if ( s__ARevival_showDialog ) then
     call s__ARevival_print(this,"Display, start with time " + R2S(s__ARevival_time[this]) + ".")
     if ( s__ARevival_timerDialog[this] == null ) then
      call s__ARevival_print(this,"Is null.")
     endif
				call TimerDialogDisplay(s__ARevival_timerDialog[this] , true)
			endif
  endfunction

  function s__ARevival_end takes integer this returns nothing
			call PauseTimerBJ(true , s__ARevival_usedTimer[this]) //Zur Sicherheit auch stoppen
			if ( s__ARevival_showDialog ) then
				call TimerDialogDisplay(s__ARevival_timerDialog[this] , false)
			endif
  endfunction

  function s__ARevival_createTimer takes integer this returns nothing
			set s__ARevival_usedTimer[this]=CreateTimer()
			call s__AHashTable_storeHandleInteger(AGetCharacterHashTable(),s__ARevival_usedTimer[this] , "revival" , this) //AClassCharacterCharacterHashTable
			if ( s__ARevival_showDialog ) then
				set s__ARevival_timerDialog[this]=CreateTimerDialog(s__ARevival_usedTimer[this])
				call TimerDialogSetTitle(s__ARevival_timerDialog[this] , "test") //GetModifiedPlayerName(this.getUser()) //ALibraryInterfaceMisc
				//call TimerDialogDisplay(this.timerDialog, false) //test
			endif
  endfunction

  function s__ARevival_triggerActionRevival takes nothing returns nothing
   local trigger triggeringTrigger= GetTriggeringTrigger()
   local integer revival= s__AHashTable_getHandleInteger(AGetCharacterHashTable(),triggeringTrigger , "revival") //AClassCharacterCharacterHashTable
    call s__ARevival_print(revival,"Character " + I2S(s__AAbstractCharacterSystem_getCharacter(revival)) + " died and will be revived.")
			if ( s__ARevival_time[revival] > 0.0 ) then
     call s__ARevival_print(revival,"Start revival")
				call s__ARevival_start(revival)
			else
				call s__ARevival_revive(revival)
			endif
			//set unmovable
			set triggeringTrigger = null
  endfunction

  function s__ARevival_createRevivalTrigger takes integer this returns nothing
   local event triggerEvent
   local triggeraction triggerAction
			set s__ARevival_revivalTrigger[this]=CreateTrigger()
			set triggerEvent = TriggerRegisterDeathEvent(s__ARevival_revivalTrigger[this] , s__AAbstractCharacterSystem_getUnit(this))
			set triggerAction = TriggerAddAction(s__ARevival_revivalTrigger[this] , function s__ARevival_triggerActionRevival)
			call s__AHashTable_storeHandleInteger(AGetCharacterHashTable(),s__ARevival_revivalTrigger[this] , "revival" , this) //AClassCharacterCharacterHashTable
			set triggerEvent = null
			set triggerAction = null
  endfunction

  function s__ARevival_create takes integer character returns integer
   local integer this= s__ARevival__allocate(character)

			call s__ARevival_createTimer(this)
			call s__ARevival_createRevivalTrigger(this)
			return this
  endfunction

  function s__ARevival_destroyTimer takes integer this returns nothing
			call s__AHashTable_destroyTimer(AGetCharacterHashTable(),s__ARevival_usedTimer[this]) //AClassCharacterCharacterHashTable
			set s__ARevival_usedTimer[this]=null
			if ( s__ARevival_showDialog ) then
				call DestroyTimerDialog(s__ARevival_timerDialog[this])
				set s__ARevival_timerDialog[this]=null
			endif
  endfunction

  function s__ARevival_destroyRevivalTrigger takes integer this returns nothing
			call s__AHashTable_destroyTrigger(AGetCharacterHashTable(),s__ARevival_revivalTrigger[this]) //AClassCharacterCharacterHashTable
			set s__ARevival_revivalTrigger[this]=null
  endfunction

  function s__ARevival_onDestroy takes integer this returns nothing

			call s__ARevival_destroyTimer(this)
			call s__ARevival_destroyRevivalTrigger(this)
  endfunction

  function s__ARevival_init takes boolean showDialog returns nothing
			//static start members
			set s__ARevival_showDialog=showDialog
  endfunction


//library AStructSystemsCharacterRevival ends
//library AStructSystemsCharacterTalk:

		//start members
		//members

//textmacro instance: A_STRUCT_DEBUG("\"AInfo\"")
   function s__AStructSystemsCharacterTalk___AInfo_print takes integer this,string message returns nothing
    call Print("AInfo" + " - " + I2S(this) + ": " + message)
   endfunction

   function s__AStructSystemsCharacterTalk___AInfo_staticPrint takes string message returns nothing
    call Print("AInfo" + ": " + message)
   endfunction
//end of: A_STRUCT_DEBUG("\"AInfo\"")

		//members

  function s__AStructSystemsCharacterTalk___AInfo_setWasPressed takes integer this,integer playerId,boolean wasPressed returns nothing
			set s___AStructSystemsCharacterTalk___AInfo_wasPressed[s__AStructSystemsCharacterTalk___AInfo_wasPressed[this]+playerId]=wasPressed
  endfunction

		//methods

  function s__AStructSystemsCharacterTalk___AInfo_show takes integer this returns nothing
    if ( sc__ATalk_getCharacter(s__AStructSystemsCharacterTalk___AInfo_talk[this]) == 0 ) then
     call s__AStructSystemsCharacterTalk___AInfo_print(this,"Talk is not enabled.")
     return 
    endif

			if ( not s__AStructSystemsCharacterTalk___AInfo_permanent[this] ) then
				if ( s___AStructSystemsCharacterTalk___AInfo_wasPressed[s__AStructSystemsCharacterTalk___AInfo_wasPressed[this]+GetPlayerId(s__ACharacter_getUser(sc__ATalk_getCharacter(s__AStructSystemsCharacterTalk___AInfo_talk[this])))] ) then
					return 
				endif
			endif

			if ( s__AStructSystemsCharacterTalk___AInfo_condition[this] != 0 and not sc___prototype844_evaluate(s__AStructSystemsCharacterTalk___AInfo_condition[this],s__AStructSystemsCharacterTalk___AInfo_talk[this]) ) then
				return 
			endif

			if ( s__AStructSystemsCharacterTalk___AInfo_important[this] ) then
				set s___AStructSystemsCharacterTalk___AInfo_wasPressed[s__AStructSystemsCharacterTalk___AInfo_wasPressed[this]+GetPlayerId(s__ACharacter_getUser(sc__ATalk_getCharacter(s__AStructSystemsCharacterTalk___AInfo_talk[this])))]=true
				call sc__ATalk_hide(s__AStructSystemsCharacterTalk___AInfo_talk[this])
				call sc__ATalk_speech(s__AStructSystemsCharacterTalk___AInfo_talk[this],s__AStructSystemsCharacterTalk___AInfo_text[this] , s__AStructSystemsCharacterTalk___AInfo_usedSound[this] , true) /// @todo trigger sleep action in method
				call sc___prototype843_execute(s__AStructSystemsCharacterTalk___AInfo_buttonAction[this],s__AStructSystemsCharacterTalk___AInfo_talk[this])
			else
				call sc__ATalk_addButton(s__AStructSystemsCharacterTalk___AInfo_talk[this],s__AStructSystemsCharacterTalk___AInfo_text[this] , s__AStructSystemsCharacterTalk___AInfo_buttonAction[this] , this)
			endif
  endfunction

  function s__AStructSystemsCharacterTalk___AInfo_run takes integer this returns nothing
			set s___AStructSystemsCharacterTalk___AInfo_wasPressed[s__AStructSystemsCharacterTalk___AInfo_wasPressed[this]+GetPlayerId(s__ACharacter_getUser(sc__ATalk_getCharacter(s__AStructSystemsCharacterTalk___AInfo_talk[this])))]=true
			call sc__ATalk_speech(s__AStructSystemsCharacterTalk___AInfo_talk[this],s__AStructSystemsCharacterTalk___AInfo_text[this] , s__AStructSystemsCharacterTalk___AInfo_usedSound[this] , false) /// @todo Bug 2: Does not wait!
  endfunction

  function s__AStructSystemsCharacterTalk___AInfo_create takes integer talk,string text,sound usedSound,boolean permanent,boolean important,integer condition,integer buttonAction returns integer
   local integer this= s__AStructSystemsCharacterTalk___AInfo__allocate()
			//start members
			set s__AStructSystemsCharacterTalk___AInfo_talk[this]=talk
			set s__AStructSystemsCharacterTalk___AInfo_text[this]=text
			set s__AStructSystemsCharacterTalk___AInfo_usedSound[this]=usedSound
			set s__AStructSystemsCharacterTalk___AInfo_permanent[this]=permanent
			set s__AStructSystemsCharacterTalk___AInfo_important[this]=important
			set s__AStructSystemsCharacterTalk___AInfo_condition[this]=condition
			set s__AStructSystemsCharacterTalk___AInfo_buttonAction[this]=buttonAction

			return this
  endfunction

  function s__AStructSystemsCharacterTalk___AInfo_onDestroy takes integer this returns nothing
			//start members
			set s__AStructSystemsCharacterTalk___AInfo_usedSound[this]=null
  endfunction

//Generated destructor of AStructSystemsCharacterTalk___AInfo
function s__AStructSystemsCharacterTalk___AInfo_destroy takes integer this returns nothing
    if this==null then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: AStructSystemsCharacterTalk___AInfo")
        return
    elseif (si__AStructSystemsCharacterTalk___AInfo_V[this]!=-1) then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: AStructSystemsCharacterTalk___AInfo")
        return
    endif
    call s__AStructSystemsCharacterTalk___AInfo_onDestroy(this)
    set si__AStructSystemsCharacterTalk___AInfo_V[this]=si__AStructSystemsCharacterTalk___AInfo_F
    set si__AStructSystemsCharacterTalk___AInfo_F=this
endfunction

	/// @todo Should be a part of @struct ATalk, vJass bug.
//processed: 	function interface ATalkStartAction takes ATalk talk returns nothing

	/// @todo Should be a part of @struct ATalk, vJass bug.
//processed: 	function interface ATalkButtonCondition takes ATalk talk returns boolean

	/// @todo Should be a part of @struct ATalk, vJass bug.
//processed: 	function interface ATalkButtonAction takes ATalk talk returns nothing

	/// @todo Should be a part of @struct ATalk, vJass bug.
 function AStructSystemsCharacterTalk___GuiDialogButtonActionTalkAction takes integer gui,integer index returns nothing
  local integer talk= s__ACharacter_getTalk(s__ACharacter_getPlayerCharacter(s__AGui_getUser(gui)))
		call sc__ATalk_runButtonAction(talk,index)
	endfunction

	/// @todo Should be a part of @struct ATalk, vJass bug.
 function AStructSystemsCharacterTalk___talkButtonActionExit takes integer talk returns nothing
		call sc__ATalk_disable(talk)
	endfunction

	/// @todo Should be a part of @struct ATalk, vJass bug.
 function AStructSystemsCharacterTalk___talkButtonActionBackToFirstPage takes integer talk returns nothing
		call sc__ATalk_showFirstPage(talk)
	endfunction
	
		//static constant members
		//static start members
		//static members
		//start members
		//members

//textmacro instance: A_STRUCT_DEBUG("\"ATalk\"")
   function s__ATalk_print takes integer this,string message returns nothing
    call Print("ATalk" + " - " + I2S(this) + ": " + message)
   endfunction

   function s__ATalk_staticPrint takes string message returns nothing
    call Print("ATalk" + ": " + message)
   endfunction
//end of: A_STRUCT_DEBUG("\"ATalk\"")

		//members

  function s__ATalk_getCharacter takes integer this returns integer
			return s__ATalk_character[this]
  endfunction
		
		//comfort methods
		
  function s__ATalk_showSimpleButton takes integer this,string text,integer buttonAction returns nothing
			call sc__ATalk_addButton(this,text , buttonAction , 0)
  endfunction

		//Eine einfache Vorlage ohne spezielle Funktion
  function s__ATalk_showExitButton takes integer this returns nothing
			call sc__ATalk_addButton(this,s__ATalk_textExit , (1) , 0)
  endfunction

  function s__ATalk_showBackButton takes integer this,integer buttonAction returns nothing
			call sc__ATalk_addButton(this,s__ATalk_textBack , buttonAction , 0)
  endfunction
		
  function s__ATalk_showBackToFirstPageButton takes integer this returns nothing
			call s__ATalk_showBackButton(this,(2))
  endfunction

		//methods

		/// @todo trigger sleep action in method
  function s__ATalk_speech takes integer this,string text,sound usedSound,boolean toCharacter returns nothing
   local real time= sc__ATalk_getTime(usedSound)
			call SetUnitAnimation(s__ACharacter_getUsedUnit(s__ATalk_character[this]) , s__ATalk_speechAnimation) //Falls vorhanden
			call SetUnitAnimation(s__ATalk_usedUnit[this] , s__ATalk_listenAnimation) //Falls vorhanden
			if ( usedSound != null ) then
				call PlaySoundForPlayer(s__ACharacter_getUser(s__ATalk_character[this]) , usedSound) //ALibraryEnvironmentSound
			endif
			call sc__ATalk_refreshView(this,toCharacter)
			if ( toCharacter ) then
				call SetCinematicSceneForPlayer(s__ACharacter_getUser(s__ATalk_character[this]) , GetUnitTypeId(s__ATalk_usedUnit[this]) , GetUnitName(s__ATalk_usedUnit[this]) , text , time , time) //ALibraryInterfaceCinematic
			else
				call SetCinematicSceneForPlayer(s__ACharacter_getUser(s__ATalk_character[this]) , GetUnitTypeId(s__ACharacter_getUsedUnit(s__ATalk_character[this])) , GetUnitName(s__ACharacter_getUsedUnit(s__ATalk_character[this])) , text , time , time) //ALibraryInterfaceCinematic
			endif
    call s__ATalk_print(this,"Before wait.")
			//call StopSound(usedSound, true, false) //Eventuell den zweiten Parameter auf false setzen
			call sc__ATalk_wait(this,usedSound)
    call s__ATalk_print(this,"After wait.")
			call sc__ATalk_resetAnimations(this)
  endfunction

		/// @param important The NPC tells the info to the character when the character wants to start a talk with him.
  function s__ATalk_addInfo takes integer this,string text,sound usedSound,boolean permanent,boolean important,integer condition,integer buttonAction returns nothing
   local integer id= s__ATalk_infos[this]
    if ( id == s__ATalk_maxInfos ) then
     call s__ATalk_print(this,"Info maximum reached.")
     return 
    endif

			set s__ATalk_infos[this]=s__ATalk_infos[this] + 1
			set s___ATalk_info[s__ATalk_info[this]+id]=s__AStructSystemsCharacterTalk___AInfo_create(this , text , usedSound , permanent , important , condition , buttonAction)
  endfunction
		
  function s__ATalk_clear takes integer this returns nothing
			set s__ATalk_buttons[this]=0
			call s__AGui_clearDialog(s__AGui_getPlayerGui(s__ACharacter_getUser(s__ATalk_character[this]))) //You do not have to clear the dialog in the start action!
  endfunction

  function s__ATalk_showFirstPage takes integer this returns nothing
			call s__ATalk_clear(this)
			call sc___prototype843_execute(s__ATalk_startAction[this],this) //create buttons
			//call this.show() //don't call this beacause the start action is often called by button actions
  endfunction

  function s__ATalk_showInfo takes integer this,integer index returns nothing
    if ( s___ATalk_info[s__ATalk_info[this]+index] == 0 ) then
     call s__ATalk_print(this,"Empty info.")
    endif
			call s__AStructSystemsCharacterTalk___AInfo_show(s___ATalk_info[s__ATalk_info[this]+index])
  endfunction

		//call this method at the end of each dialog
  function s__ATalk_show takes integer this returns nothing
			call s__AGui_setDialogTitle(s__AGui_getPlayerGui(s__ACharacter_getUser(s__ATalk_character[this])),GetUnitName(s__ATalk_usedUnit[this]))
			call s__AGui_showDialog(s__AGui_getPlayerGui(s__ACharacter_getUser(s__ATalk_character[this])))
  endfunction

		//call this if you want to hide the dialog (not cancel)
  function s__ATalk_hide takes integer this returns nothing
			call s__AGui_hideDialog(s__AGui_getPlayerGui(s__ACharacter_getUser(s__ATalk_character[this])))
  endfunction

		//Call this to disable the dialog during the talk.
  function s__ATalk_disable takes integer this returns nothing
			call s__AGui_hideDialog(s__AGui_getPlayerGui(s__ACharacter_getUser(s__ATalk_character[this])))
			call sc__ATalk_resetFacings(this)
			call SetUserInterfaceForPlayer(s__ACharacter_getUser(s__ATalk_character[this]) , true , true)
			call ResetToGameCameraForPlayer(s__ACharacter_getUser(s__ATalk_character[this]) , 0.0)
			call s__ACharacter_setTalk(s__ATalk_character[this],0)
			call s__ACharacter_setMovable(s__ATalk_character[this],true)
			set s__ATalk_character[this]=0

			call PauseUnit(s__ATalk_usedUnit[this] , false) //Disables routines or something else
  endfunction

		/// Friend relation to library (To AInfo). Don't use this method!
  function s__ATalk_addButton takes integer this,string text,integer buttonAction,integer info returns nothing
   local integer id= s__ATalk_buttons[this]
    if ( id == s__ATalk_maxButtons ) then
     call s__ATalk_print(this,"Button maximum reached.")
     return 
    endif

			if ( s__AGui_addDialogButton(s__AGui_getPlayerGui(s__ACharacter_getUser(s__ATalk_character[this])),"[" + I2S(s__ATalk_buttons[this] + 1) + "] " + text , id + SHORTCUT_1 , (1)) != - 1 ) then //AClassGuiGui, ALibraryInterfaceMisc
				set s__ATalk_buttons[this]=s__ATalk_buttons[this] + 1
				set s___ATalk_buttonAction[s__ATalk_buttonAction[this]+id]=buttonAction
				set s___ATalk_buttonInfo[s__ATalk_buttonInfo[this]+id]=info
			endif
  endfunction

		/// Friend relation to the function interface.
		/// Don't use this method!
  function s__ATalk_runButtonAction takes integer this,integer index returns nothing
			if ( s___ATalk_buttonInfo[s__ATalk_buttonInfo[this]+index] != 0 ) then
				call s__ATalk_hide(this)
				call s__AStructSystemsCharacterTalk___AInfo_run(s___ATalk_buttonInfo[s__ATalk_buttonInfo[this]+index])
			endif
			//No clear if no info
			if ( s___ATalk_buttonAction[s__ATalk_buttonAction[this]+index] != 0 ) then
				call sc___prototype843_execute(s___ATalk_buttonAction[s__ATalk_buttonAction[this]+index],this)
			else
				call s__ATalk_showFirstPage(this)
			endif
  endfunction
		
  function s__ATalk_wait takes integer this,sound usedSound returns nothing
   local real time= sc__ATalk_getTime(usedSound)
    call s__ATalk_print(this,"Wait " + R2S(time) + ".")
			if ( s__ATalk_skipKey == - 1 ) then
				call TriggerSleepAction(time)
			else
				loop
					exitwhen ( time <= 0.0 )
      call s__ATalk_print(this,"Before trigger sleep with time: " + R2S(time))
					call TriggerSleepAction(s__ATalk_skipCheckRate)
					set time = time - s__ATalk_skipCheckRate
      call s__ATalk_print(this,"Loop with remaining time: " + R2S(time))
					if ( time <= 0.0 ) then
						return 
					elseif ( s__s__ATalk_playerHasSkipped[GetPlayerId(s__ACharacter_getUser(s__ATalk_character[this]))] ) then
       call s__ATalk_print(this,"Talk " + I2S(this) + " was skipped.")
						if ( s__ATalk_skipKey != KEY_ESCAPE ) then //ALibraryInterfaceMisc
							call ClearScreenMessagesForPlayer(s__ACharacter_getUser(s__ATalk_character[this])) //ALibraryInterfaceCinematic
						endif
						call StopSound(usedSound , true , false) //Eventuell den zweiten Parameter auf false setzen
						call sc__ATalk_resetAnimations(this)
						set s__s__ATalk_playerHasSkipped[GetPlayerId(s__ACharacter_getUser(s__ATalk_character[this]))]= false
						return 
					endif
				endloop
			endif
  endfunction

		//Normally you do not need this method
  function s__ATalk_enable takes integer this,integer character returns nothing
    if ( s__ATalk_character[this] != 0 ) then
     call s__ATalk_print(this,"Character is not 0 in talk " + I2S(this) + ".")
    else
     call s__ATalk_print(this,"Character is 0. Important!")
    endif
    call s__ATalk_print(this,"Enable talk for character " + I2S(character) + ".")
			call PauseUnit(s__ATalk_usedUnit[this] , true) //Disables routines or something else
			set s__ATalk_character[this]=character
			call SetUserInterfaceForPlayer(s__ACharacter_getUser(character) , false , true)
			call s__ACharacter_setTalk(character,this)
			call s__ACharacter_setMovable(character,false)
			call sc__ATalk_refreshView(this,false)
			call sc__ATalk_refreshFacings(this)
			call s__ATalk_clear(this)
			
    if ( s__ATalk_startAction[this] == 0 ) then
     call s__ATalk_print(this,"Start action is 0")
    else
     call s__ATalk_print(this,"Start action is NOT 0")
    endif
			
			call sc___prototype843_execute(s__ATalk_startAction[this],this) /// @todo execute? //create buttons
    call s__ATalk_print(this,"After start action")
			//call this.show() //don't call this beacause the start action is often called by button actions
  endfunction

  function s__ATalk_refreshView takes integer this,boolean toCharacter returns nothing
			call CameraSetupApplyForPlayer(true , s__ATalk_cameraSetup , s__ACharacter_getUser(s__ATalk_character[this]) , 0.0)
			if ( toCharacter ) then
				call SetCameraFieldForPlayer(s__ACharacter_getUser(s__ATalk_character[this]) , CAMERA_FIELD_ROTATION , GetUnitFacing(s__ATalk_usedUnit[this]) - 180.0 , 0.0)
				call SetCameraFieldForPlayer(s__ACharacter_getUser(s__ATalk_character[this]) , CAMERA_FIELD_ZOFFSET , CameraSetupGetField(s__ATalk_cameraSetup , CAMERA_FIELD_ZOFFSET) + GetUnitFlyHeight(s__ATalk_usedUnit[this]) , 0.0)
				call SetCameraTargetControllerNoZForPlayer(s__ACharacter_getUser(s__ATalk_character[this]) , s__ATalk_usedUnit[this] , 0.0 , 0.0 , false)
			else
				call SetCameraFieldForPlayer(s__ACharacter_getUser(s__ATalk_character[this]) , CAMERA_FIELD_ROTATION , GetUnitFacing(s__ACharacter_getUsedUnit(s__ATalk_character[this])) - 180.0 , 0.0)
				call SetCameraFieldForPlayer(s__ACharacter_getUser(s__ATalk_character[this]) , CAMERA_FIELD_ZOFFSET , CameraSetupGetField(s__ATalk_cameraSetup , CAMERA_FIELD_ZOFFSET) + GetUnitFlyHeight(s__ACharacter_getUsedUnit(s__ATalk_character[this])) , 0.0)
				call SetCameraTargetControllerNoZForPlayer(s__ACharacter_getUser(s__ATalk_character[this]) , s__ACharacter_getUsedUnit(s__ATalk_character[this]) , 0.0 , 0.0 , false)
			endif
  endfunction

  function s__ATalk_refreshFacings takes integer this returns nothing
			call SetUnitFacing(s__ACharacter_getUsedUnit(s__ATalk_character[this]) , GetAngleBetweenUnits(s__ACharacter_getUsedUnit(s__ATalk_character[this]) , s__ATalk_usedUnit[this])) //ALibraryMathsHandle
			call SetUnitFacing(s__ATalk_usedUnit[this] , GetAngleBetweenUnits(s__ACharacter_getUsedUnit(s__ATalk_character[this]) , s__ATalk_usedUnit[this]) - 180.0) //ALibraryMathsHandle
			call SetUnitLookAt(s__ACharacter_getUsedUnit(s__ATalk_character[this]) , "bone_head" , s__ATalk_usedUnit[this] , 0.0 , 0.0 , GetUnitFlyHeight(s__ATalk_usedUnit[this]) + 90.0)
			call SetUnitLookAt(s__ATalk_usedUnit[this] , "bone_head" , s__ACharacter_getUsedUnit(s__ATalk_character[this]) , 0.0 , 0.0 , GetUnitFlyHeight(s__ACharacter_getUsedUnit(s__ATalk_character[this])) + 90.0)
  endfunction

  function s__ATalk_resetFacings takes integer this returns nothing
			call ResetUnitLookAt(s__ACharacter_getUsedUnit(s__ATalk_character[this]))
			call ResetUnitLookAt(s__ATalk_usedUnit[this])
  endfunction

  function s__ATalk_resetAnimations takes integer this returns nothing
			call ResetUnitAnimation(s__ACharacter_getUsedUnit(s__ATalk_character[this]))
			call ResetUnitAnimation(s__ATalk_usedUnit[this])
  endfunction

  function s__ATalk_triggerConditionEnable takes nothing returns boolean
   local trigger triggeringTrigger
   local unit triggerUnit
   local player owner
   local unit orderTargetUnit
   local integer talk
   local boolean result= false
			if ( GetIssuedOrderId() == OrderId(s__ATalk_order) ) then //Rechtsklick
				set triggerUnit = GetTriggerUnit()
				set owner = GetOwningPlayer(triggerUnit)
				//Is character
				if ( triggerUnit == s__ACharacter_getUsedUnit(s__ACharacter_getPlayerCharacter(owner)) ) then //AClassCharacterCharacter
					set triggeringTrigger = GetTriggeringTrigger()
					set talk = s__AHashTable_getHandleInteger(AGetCharacterHashTable(),triggeringTrigger , "talk") //ACharacterClassClassHashTable
					set orderTargetUnit = GetOrderTargetUnit()
					if ( orderTargetUnit == s__ATalk_usedUnit[talk] ) then
						if ( GetDistanceBetweenUnits(triggerUnit , orderTargetUnit , 0.0 , 0.0) <= s__ATalk_maxDistance ) then //ALibraryMathsHandle, Z-Wert wird nicht �berpr�ft
							set result = ( s__ATalk_character[talk] == 0 )
							if ( not result ) then
								call s__ACharacter_displayMessage(s__ACharacter_getPlayerCharacter(owner),s__ACharacter_messageTypeError , s__ATalk_textErrorMessage)
							endif
						endif
					endif
					set triggeringTrigger = null
					set orderTargetUnit = null
				endif
				set triggerUnit = null
				set owner = null
			endif
    if ( result ) then
     call Print("Talk dialog " + I2S(talk) + " was enabled.")
    endif
			return result
  endfunction

  function s__ATalk_triggerActionEnable takes nothing returns nothing
   local trigger triggeringTrigger= GetTriggeringTrigger()
   local player triggerPlayer= GetTriggerPlayer()
   local integer talk= s__AHashTable_getHandleInteger(AGetCharacterHashTable(),triggeringTrigger , "talk") //AClassCharacterCharacterHashTable
			call IssueImmediateOrder(s__ACharacter_getUsedUnit(s__ACharacter_getPlayerCharacter(triggerPlayer)) , "stop") //AClassCharacterCharacter
			call s__ATalk_enable(talk,s__ACharacter_getPlayerCharacter(triggerPlayer)) //AClassCharacterCharacter
    call Print("Enable talk for player " + GetPlayerName(triggerPlayer))
			set triggeringTrigger = null
			set triggerPlayer = null
  endfunction

  function s__ATalk_createOrderTrigger takes integer this returns nothing
   local conditionfunc conditionFunction
   local triggercondition triggerCondition
   local triggeraction triggerAction
			set s__ATalk_orderTrigger[this]=CreateTrigger()
			call TriggerRegisterAnyUnitEventBJ(s__ATalk_orderTrigger[this] , EVENT_PLAYER_UNIT_ISSUED_UNIT_ORDER) //Returned nichts
			set conditionFunction = Condition(function s__ATalk_triggerConditionEnable)
			set triggerCondition = TriggerAddCondition(s__ATalk_orderTrigger[this] , conditionFunction)
			set triggerAction = TriggerAddAction(s__ATalk_orderTrigger[this] , function s__ATalk_triggerActionEnable)
			call s__AHashTable_storeHandleInteger(AGetCharacterHashTable(),s__ATalk_orderTrigger[this] , "talk" , this) //AClassCharacterCharacterHashTable
			set conditionFunction = null
			set triggerCondition = null
			set triggerAction = null
  endfunction

  function s__ATalk_create takes unit usedUnit,integer startAction returns integer
   local integer this= s__ATalk__allocate()
			//start members
			set s__ATalk_usedUnit[this]=usedUnit
			set s__ATalk_startAction[this]=startAction
			//members
			set s__ATalk_buttons[this]=0
			set s__ATalk_infos[this]=0
			set s__ATalk_character[this]=0

			call s__ATalk_createOrderTrigger(this)
			if ( s__ATalk_effectPath != null ) then
				set s__ATalk_usedEffect[this]=AddSpecialEffectTarget(s__ATalk_effectPath , s__ATalk_usedUnit[this] , "overhead")
			endif
			return this
  endfunction

  function s__ATalk_destroyOrderTrigger takes integer this returns nothing
			call s__AHashTable_destroyTrigger(AGetCharacterHashTable(),s__ATalk_orderTrigger[this]) //AClassCharacterCharacterHashTable
			set s__ATalk_orderTrigger[this]=null
  endfunction

  function s__ATalk_destroyEffect takes integer this returns nothing
			if ( s__ATalk_effectPath != null ) then
				call DestroyEffect(s__ATalk_usedEffect[this])
				set s__ATalk_usedEffect[this]=null
			endif
  endfunction

  function s__ATalk_destroyInfos takes integer this returns nothing
   local integer i= 0
			loop
				exitwhen ( i == s__ATalk_infos[this] )
				call s__AStructSystemsCharacterTalk___AInfo_destroy(s___ATalk_info[s__ATalk_info[this]+i])
				set i = i + 1
			endloop
  endfunction

  function s__ATalk_onDestroy takes integer this returns nothing

			call s__ATalk_destroyOrderTrigger(this)
			call s__ATalk_destroyEffect(this)
			call s__ATalk_destroyInfos(this)
  endfunction

//Generated destructor of ATalk
function s__ATalk_destroy takes integer this returns nothing
    if this==null then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: ATalk")
        return
    elseif (si__ATalk_V[this]!=-1) then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: ATalk")
        return
    endif
    call s__ATalk_onDestroy(this)
    set si__ATalk_V[this]=si__ATalk_F
    set si__ATalk_F=this
endfunction

		/// @param skipKey If this value is -1 players can not skip talks.
		/// @param effectPath If this value is null there is no effect
  function s__ATalk_init takes camerasetup cameraSetup,real noSoundTime,integer skipKey,real skipCheckRate,string order,real maxDistance,string effectPath,string speechAnimation,string listenAnimation,string textErrorMessage,string textExit,string textBack returns nothing
			//static start members
			set s__ATalk_cameraSetup=cameraSetup
			set s__ATalk_noSoundTime=noSoundTime
			set s__ATalk_skipKey=skipKey
			set s__ATalk_skipCheckRate=skipCheckRate
			set s__ATalk_order=order
			set s__ATalk_maxDistance=maxDistance
			set s__ATalk_effectPath=effectPath
			set s__ATalk_speechAnimation=speechAnimation
			set s__ATalk_listenAnimation=listenAnimation
			set s__ATalk_textErrorMessage=textErrorMessage
			set s__ATalk_textExit=textExit
			set s__ATalk_textBack=textBack
			if ( skipKey != - 1 ) then
				call sc__ATalk_createSkipTrigger()
			endif
  endfunction
		
  function s__ATalk_triggerActionSkip takes nothing returns nothing
   local player user= GetTriggerPlayer()
			if ( s__ACharacter_getTalk(s__ACharacter_getPlayerCharacter(user)) != 0 ) then
				set s__s__ATalk_playerHasSkipped[GetPlayerId(user)]= true
     call Print("Player " + GetPlayerName(user) + " skips talk.")
			endif
			set user = null
  endfunction
		
  function s__ATalk_createSkipTrigger takes nothing returns nothing
   local integer i
   local player user
   local event triggerEvent
   local triggeraction triggerAction
			set s__ATalk_skipTrigger=CreateTrigger()
			set i = 0
			loop
				exitwhen ( i == bj_MAX_PLAYERS )
				set user = Player(i)
				if ( IsPlayerPlayingUser(user) ) then //ALibraryGeneralPlayer
					set triggerEvent = TriggerRegisterKeyEventForPlayer(user , s__ATalk_skipTrigger , s__ATalk_skipKey , true) //ALibraryInterfaceMisc
					set triggerEvent = null
				endif
				set user = null
				set i = i + 1
			endloop
			set triggerAction = TriggerAddAction(s__ATalk_skipTrigger , function s__ATalk_triggerActionSkip)
			set triggerAction = null
  endfunction
		
  function s__ATalk_getTime takes sound usedSound returns real
			if ( usedSound != null ) then
				return GetSoundDurationBJ(usedSound)
			endif
			return s__ATalk_noSoundTime
  endfunction


//library AStructSystemsCharacterTalk ends
//library AStructSystemsCharacterVideo:

	/// @todo Should be a part of @struct AVideo, vJass bug.
//processed: 	function interface AVideoPlayAction takes AVideo video returns nothing

		//static start members
		//static members
		//start members

//textmacro instance: A_STRUCT_DEBUG("\"AVideo\"")
   function s__AVideo_print takes integer this,string message returns nothing
    call Print("AVideo" + " - " + I2S(this) + ": " + message)
   endfunction

   function s__AVideo_staticPrint takes string message returns nothing
    call Print("AVideo" + ": " + message)
   endfunction
//end of: A_STRUCT_DEBUG("\"AVideo\"")

		//methods
		
  function s__AVideo_play takes integer this returns nothing
   local force playersAll
    if ( s__AVideo_runningVideo != 0 ) then
     call s__AVideo_print(this,"Another Video is already running.") //ALibraryGeneralDebug
    endif
			call s__ACharacter_setAllMovable(false) //AClassCharacterCharacter

			call ClearSelection()
			call CinematicFadeBJ(bj_CINEFADETYPE_FADEOUTIN , s__AVideo_filterDuration , "ReplaceableTextures\\CameraMasks\\White_mask.blp" , 0 , 0 , 0 , 0)
			//call CinematicFadeCommonBJ(100.0, 100.0, 100.0, AVideo.filterDuration, "ReplaceableTextures\\CameraMasks\\Black_mask.blp", 0.0, 0.0)
			set playersAll = GetPlayersAll()
			call CinematicModeExBJ(true , playersAll , 0.0)
			call EnableUserControl(true) //otherwise we could not catch the press event (just the escape key)
			set playersAll = null
			set s__AVideo_runningVideo=this
    call Print("Before video")

			call TriggerSleepAction(s__AVideo_filterDuration + 0.50)

			call EnableTrigger(s__AVideo_skipTrigger)
			call sc___prototype845_execute(s__AVideo_playAction[this],this)
  endfunction

		/// You have to call this method at the end of your video action.
		/// Since there is an execution of the action, TriggerSleepAction functions will be ignored, so this method could not be called by the play method.
  function s__AVideo_stop takes integer this returns nothing
   local force playersAll
			call DisableTrigger(s__AVideo_skipTrigger)
			
			set s__AVideo_runningVideo=0
			set s__AVideo_skipped=false
			set s__AVideo_skippingPlayers=0

			call CinematicFadeBJ(bj_CINEFADETYPE_FADEOUTIN , s__AVideo_filterDuration , "ReplaceableTextures\\CameraMasks\\White_mask.blp" , 0 , 0 , 0 , 0)
			//call CinematicFadeCommonBJ(100.0, 100.0, 100.0, AVideo.filterDuration, "ReplaceableTextures\\CameraMasks\\Black_mask.blp", 0.0, 0.0)
			set playersAll = GetPlayersAll()
			call CinematicModeExBJ(false , playersAll , 0.0)
			set playersAll = null
			call ResetToGameCamera(0.0)

			call TriggerSleepAction(s__AVideo_filterDuration + 0.50)

			call s__ACharacter_setAllMovable(true) //AClassCharacterCharacter
  endfunction
		
		/// Waits in video.
		/// @return Returns true if video was skipped
  function s__AVideo_wait takes integer this,real seconds returns boolean
    call s__AVideo_print(this,"Wait in video " + R2S(seconds) + ".")
			loop
				call TriggerSleepAction(s__AVideo_waitInterval)
				set seconds = seconds - s__AVideo_waitInterval
     call s__AVideo_print(this,"Remaining seconds: " + R2S(seconds) + ".")
				if ( s__AVideo_skipped ) then
      call s__AVideo_print(this,"Skip in wait method.")
					call s__AVideo_stop(this)
					return true
				elseif ( seconds <= 0 ) then
      call s__AVideo_print(this,"Was not skipped.")
					return false
				endif
			endloop
			return false
  endfunction

  function s__AVideo_create takes integer playAction returns integer
   local integer this= s__AVideo__allocate()
			//start members
			set s__AVideo_playAction[this]=playAction

			return this
  endfunction

		/// @param divident This value represents the divident which is used for comparing the number of skipping players with the number of requested skipping players for skipping the video.
  function s__AVideo_init takes integer divident,real filterDuration,real waitInterval,string textPlayerSkips,string textSkip returns nothing
			//static start members
			set s__AVideo_divident=divident
			set s__AVideo_filterDuration=filterDuration
			set s__AVideo_waitInterval=waitInterval
			set s__AVideo_textPlayerSkips=textPlayerSkips
			set s__AVideo_textSkip=textSkip
			//static members
			set s__AVideo_runningVideo=0
			set s__AVideo_skipped=false
			set s__AVideo_skippingPlayers=0

			call sc__AVideo_createSkipTrigger()
  endfunction
		
		//static members

  function s__AVideo_wasSkipped takes nothing returns boolean
    if ( s__AVideo_skipped ) then
     call Print("Skipped is true.")
    endif
			return s__AVideo_skipped
  endfunction
		
		//static methods
		
		/// Waits until no video is running.
		/// @param interval Check interval.
  function s__AVideo_waitForVideo takes real interval returns nothing
			loop
				exitwhen ( s__AVideo_runningVideo == 0 )
				call TriggerSleepAction(interval)
			endloop
  endfunction

  function s__AVideo_triggerConditionSkip takes nothing returns boolean
    if ( s__AVideo_runningVideo == 0 ) then
     call s__AVideo_staticPrint("Running video is 0.")
    else
     call s__AVideo_staticPrint("Running video is not 0.")
    endif
			return s__AVideo_runningVideo != 0
  endfunction

  function s__AVideo_triggerActionSkip takes nothing returns nothing
   local integer i
   local player triggerPlayer= GetTriggerPlayer()
   local player user
   local integer skipablePlayers= 0
			set s__AVideo_skippingPlayers=s__AVideo_skippingPlayers + 1
			call s__ACharacter_displayMessageToAll(s__ACharacter_messageTypeInfo , StringArg(s__AVideo_textPlayerSkips , GetPlayerName(triggerPlayer))) //AClassCharacterCharacter, ALibraryStringConversion
			set triggerPlayer = null

			//Jedes Mal neu berechnen, da Spieler as Spiel auch verlassen haben könnten.
			set i = 0
			loop
				exitwhen ( i == bj_MAX_PLAYERS )
					set user = Player(i)
					if ( IsPlayerPlayingUser(user) ) then //ALibraryGeneralPlayer
						set skipablePlayers = skipablePlayers + 1
					endif
					set user = null
				set i = i + 1
			endloop

			if ( s__AVideo_skippingPlayers >= skipablePlayers / 2 ) then
				set s__AVideo_skipped=true
				call DisableTrigger(s__AVideo_skipTrigger) //do not allow skipping at twice!

				call s__ACharacter_displayMessageToAll(s__ACharacter_messageTypeInfo , s__AVideo_textSkip)
			endif
  endfunction

  function s__AVideo_createSkipTrigger takes nothing returns nothing
   local integer i
   local player user
   local event triggerEvent
   local conditionfunc conditionFunction
   local triggercondition triggerCondition
   local triggeraction triggerAction
			set s__AVideo_skipTrigger=CreateTrigger()
			call DisableTrigger(s__AVideo_skipTrigger) //will be enabled by first running video
			set i = 0
			loop
				exitwhen ( i == bj_MAX_PLAYERS )
				set user = Player(i)
				if ( IsPlayerPlayingUser(user) ) then
      call s__AVideo_staticPrint("Create skip trigger for player " + I2S(i) + ".")
					set triggerEvent = TriggerRegisterKeyEventForPlayer(user , s__AVideo_skipTrigger , KEY_RIGHT , true) //ALibraryInterfaceMisc, important: If it is the escape key it is the same key as in the character selection.
					set triggerEvent = null
				endif
				set user = null
				set i = i + 1
			endloop
			set conditionFunction = Condition(function s__AVideo_triggerConditionSkip)
			set triggerCondition = TriggerAddCondition(s__AVideo_skipTrigger , conditionFunction)
			set triggerAction = TriggerAddAction(s__AVideo_skipTrigger , function s__AVideo_triggerActionSkip)
			set triggerEvent = null
			set conditionFunction = null
			set triggerCondition = null
			set triggerAction = null
  endfunction


//library AStructSystemsCharacterVideo ends
//library AStructSystemsGuiWidget:

	/// @todo Should be a static method of @struct AWidget, vJass bug.
//processed: 	function interface AWidgetOnHitAction takes AWidget usedWidget returns nothing

	/// @todo Should be a static method of @struct AWidget, vJass bug.
//processed: 	function interface AWidgetOnTrackAction takes AWidget usedWidget returns nothing
	
	/// @todo Should be a static method of @struct AWidget, vJass bug.
	/// Use this method as track action if you want to have the generic tooltip.
	/// You can also use another track action and call this method in your custom action.
 function onTrackActionShowTooltip takes integer usedWidget returns nothing
		call sc__AMainWindow_showTooltip(sc__AWidget_getMainWindow(usedWidget),usedWidget)
	endfunction

		//static start members
		//dynamic members
		//start members
		//members

		//dynamic members

  function s__AWidget_setShown takes integer this,boolean shown returns nothing
			if ( s__AWidget_m_shown[this] == shown ) then
				return 
			endif
			if ( shown ) then
				call sc__AWidget_show(this)
			else
				call sc__AWidget_hide(this)
			endif
  endfunction

  function s__AWidget_isShown takes integer this returns boolean
			return s__AWidget_m_shown[this]
  endfunction

		/// Important: Set all shortcuts when before showing the GUI.
		/// When hiding the GUI all shortcut actions will be reseted (because of the different main windows).
  function s__AWidget_setShortcut takes integer this,integer shortcut returns nothing
			//clear old action
			if ( s__AWidget_shortcut[this] != 0 ) then
				call s__AGui_setOnPressShortcutAction(sc__AMainWindow_getGui(s__AWidget_mainWindow[this]),shortcut , 0 , 0) //AClassGuiGui
			endif
			set s__AWidget_shortcut[this]=shortcut
			if ( s__AWidget_onHitAction[this] != 0 ) then
				call s__AGui_setOnPressShortcutAction(sc__AMainWindow_getGui(s__AWidget_mainWindow[this]),shortcut , s__AWidget_onHitAction[this] , this) //AClassGuiGui
			endif
  endfunction

  function s__AWidget_getShortcut takes integer this returns integer
			return s__AWidget_shortcut[this]
  endfunction

  function s__AWidget_setTooltip takes integer this,string tooltip returns nothing
			set s__AWidget_tooltip[this]=tooltip
  endfunction

  function s__AWidget_getTooltip takes integer this returns string
			return s__AWidget_tooltip[this]
  endfunction

  function s__AWidget_setTooltipSize takes integer this,real tooltipSize returns nothing
			set s__AWidget_tooltipSize[this]=tooltipSize
  endfunction

  function s__AWidget_getTooltipSize takes integer this returns real
			return s__AWidget_tooltipSize[this]
  endfunction

		//start members

  function s__AWidget_getMainWindow takes integer this returns integer
			return s__AWidget_mainWindow[this]
  endfunction

  function s__AWidget_getX takes integer this returns real
			return s__AWidget_x[this]
  endfunction

  function s__AWidget_getY takes integer this returns real
			return s__AWidget_y[this]
  endfunction

  function s__AWidget_getSizeX takes integer this returns real
			return s__AWidget_sizeX[this]
  endfunction

  function s__AWidget_getSizeY takes integer this returns real
			return s__AWidget_sizeY[this]
  endfunction
		
		//comfort methods
		
  function s__AWidget_getGui takes integer this returns integer
			return sc__AMainWindow_getGui(s__AWidget_mainWindow[this])
  endfunction

  function s__AWidget_getUser takes integer this returns player
			return sc__AMainWindow_getUser(s__AWidget_mainWindow[this])
  endfunction

		//methods

  function s__AWidget_show takes integer this returns nothing
			call sc__AWidget_enableOnHitTrigger(this)
			call sc__AWidget_enableOnTrackTrigger(this)
			set s__AWidget_m_shown[this]=true
  endfunction

  function s__AWidget_hide takes integer this returns nothing
			call sc__AWidget_disableOnHitTrigger(this)
			call sc__AWidget_disableOnTrackTrigger(this)
			set s__AWidget_m_shown[this]=false
  endfunction

  function s__AWidget_enableOnHitTrigger takes integer this returns nothing
			if ( s__AWidget_onHitAction[this] != 0 ) then
				call EnableTrigger(s__AWidget_onHitTrigger[this])
			endif
  endfunction

  function s__AWidget_enableOnTrackTrigger takes integer this returns nothing
			if ( s__AWidget_onTrackAction[this] != 0 ) then
				call EnableTrigger(s__AWidget_onTrackTrigger[this])
			endif
  endfunction

  function s__AWidget_disableOnHitTrigger takes integer this returns nothing
			if ( s__AWidget_onHitAction[this] != 0 ) then
				call DisableTrigger(s__AWidget_onHitTrigger[this])
			endif
  endfunction

  function s__AWidget_disableOnTrackTrigger takes integer this returns nothing
			if ( s__AWidget_onTrackAction[this] != 0 ) then
				call DisableTrigger(s__AWidget_onTrackTrigger[this])
			endif
  endfunction

  function s__AWidget_createTrackable takes integer this returns nothing
			if ( ( s__AWidget_onHitAction[this] != 0 ) or ( s__AWidget_onTrackAction[this] != 0 ) ) then
				set s__AWidget_usedTrackable[this]=CreateTrackableForPlayer(s__AGui_getUser(sc__AMainWindow_getGui(s__AWidget_mainWindow[this])) , sc__AWidget_getTrackablePathBySize(s__AWidget_sizeX[this] , s__AWidget_sizeY[this]) , sc__AMainWindow_getX(s__AWidget_mainWindow[this],s__AWidget_x[this]) , sc__AMainWindow_getY(s__AWidget_mainWindow[this],s__AWidget_y[this]) , 0.0) //ALibraryInterfaceTrackable
			endif
  endfunction

  function s__AWidget_triggerActionOnHit takes nothing returns nothing
   local trigger triggeringTrigger= GetTriggeringTrigger()
   local integer usedWidget= s__AHashTable_getHandleInteger(AGetInterfaceHashTable(),triggeringTrigger , "widget") //AClassInterfaceInterfaceHashTable
			call sc___prototype846_execute(s__AWidget_onHitAction[usedWidget],usedWidget)
			if ( s__AWidget_onHitSoundPath != null ) then
				call PlaySoundPathForPlayer(s__AGui_getUser(sc__AMainWindow_getGui(s__AWidget_mainWindow[usedWidget])) , s__AWidget_onHitSoundPath) //ALibraryEnvironmentSound
			endif
			set triggeringTrigger = null
  endfunction

  function s__AWidget_createOnHitTrigger takes integer this returns nothing
   local event triggerEvent
   local triggeraction triggerAction
			if ( s__AWidget_onHitAction[this] != 0 ) then
				set s__AWidget_onHitTrigger[this]=CreateTrigger()
				set triggerEvent = TriggerRegisterTrackableHitEvent(s__AWidget_onHitTrigger[this] , s__AWidget_usedTrackable[this])
				set triggerAction = TriggerAddAction(s__AWidget_onHitTrigger[this] , function s__AWidget_triggerActionOnHit)
				call s__AHashTable_storeHandleInteger(AGetInterfaceHashTable(),s__AWidget_onHitTrigger[this] , "widget" , this) //AClassInterfaceInterfaceHashTable
				set triggerEvent = null
				set triggerAction = null
			endif
  endfunction

  function s__AWidget_triggerActionOnTrack takes nothing returns nothing
   local trigger triggeringTrigger= GetTriggeringTrigger()
   local integer usedWidget= s__AHashTable_getHandleInteger(AGetInterfaceHashTable(),triggeringTrigger , "widget") //AClassInterfaceInterfaceHashTable
			call sc___prototype846_execute(s__AWidget_onTrackAction[usedWidget],usedWidget)
			if ( s__AWidget_onTrackSoundPath != null ) then
				call PlaySoundPathForPlayer(s__AGui_getUser(sc__AMainWindow_getGui(s__AWidget_mainWindow[usedWidget])) , s__AWidget_onTrackSoundPath) //ALibraryEnvironmentSound
			endif
			set triggeringTrigger = null
  endfunction

  function s__AWidget_createOnTrackTrigger takes integer this returns nothing
   local event triggerEvent
   local triggeraction triggerAction
			if ( s__AWidget_onTrackAction[this] != 0 ) then
				set s__AWidget_onTrackTrigger[this]=CreateTrigger()
				set triggerEvent = TriggerRegisterTrackableTrackEvent(s__AWidget_onTrackTrigger[this] , s__AWidget_usedTrackable[this])
				set triggerAction = TriggerAddAction(s__AWidget_onTrackTrigger[this] , function s__AWidget_triggerActionOnTrack)
				call s__AHashTable_storeHandleInteger(AGetInterfaceHashTable(),s__AWidget_onTrackTrigger[this] , "widget" , this) //AClassInterfaceInterfaceHashTable
				set triggerEvent = null
				set triggerAction = null
			endif
  endfunction

  function s__AWidget_create takes integer mainWindow,real x,real y,real sizeX,real sizeY,integer onHitAction,integer onTrackAction returns integer
   local integer this= s__AWidget__allocate()
			//dynamic members
			set s__AWidget_m_shown[this]=false
			//start members
			set s__AWidget_mainWindow[this]=mainWindow
			set s__AWidget_x[this]=x
			set s__AWidget_y[this]=y
			set s__AWidget_sizeX[this]=sizeX
			set s__AWidget_sizeY[this]=sizeY
			set s__AWidget_onHitAction[this]=onHitAction
			set s__AWidget_onTrackAction[this]=onTrackAction

			call s__AWidget_createTrackable(this)
			call s__AWidget_createOnHitTrigger(this)
			call s__AWidget_createOnTrackTrigger(this)

			if ( mainWindow != 0 ) then
				call sc__AMainWindow_dockWidget(mainWindow,this)
			endif

			return this
  endfunction

  function s__AWidget_destroyTrackable takes integer this returns nothing
			if ( ( s__AWidget_onHitAction[this] != 0 ) or ( s__AWidget_onTrackAction[this] != 0 ) ) then
				//we can't destroy trackables :-[
				set s__AWidget_usedTrackable[this]=null
			endif
  endfunction

  function s__AWidget_destroyOnHitTrigger takes integer this returns nothing
			if ( s__AWidget_onHitAction[this] != 0 ) then
				call s__AHashTable_destroyTrigger(AGetInterfaceHashTable(),s__AWidget_onHitTrigger[this]) //AClassInterfaceInterfaceHashTable
				set s__AWidget_onHitTrigger[this]=null
			endif
  endfunction

  function s__AWidget_destroyOnTrackTrigger takes integer this returns nothing
			if ( s__AWidget_onTrackAction[this] != 0 ) then
				call s__AHashTable_destroyTrigger(AGetInterfaceHashTable(),s__AWidget_onTrackTrigger[this]) //AClassInterfaceInterfaceHashTable
				set s__AWidget_onTrackTrigger[this]=null
			endif
  endfunction

  function s__AWidget_onDestroy takes integer this returns nothing

			call s__AWidget_destroyOnHitTrigger(this)
			call s__AWidget_destroyOnTrackTrigger(this)

			if ( s__AWidget_mainWindow[this] != 0 ) then
				call sc__AMainWindow_undockWidget(s__AWidget_mainWindow[this],this)
			endif
  endfunction

  function s__AWidget_init takes string onHitSoundPath,string onTrackSoundPath returns nothing
			set s__AWidget_onHitSoundPath=onHitSoundPath
			set s__AWidget_onTrackSoundPath=onTrackSoundPath

			if ( onHitSoundPath != null ) then
				call PreloadSoundPath(onHitSoundPath) //ALibraryEnvironmentSound
			endif
			if ( onTrackSoundPath != null ) then
				call PreloadSoundPath(onTrackSoundPath) //ALibraryEnvironmentSound
			endif
  endfunction

  function s__AWidget_getTrackablePathBySize takes real sizeX,real sizeY returns string
			//I need a list of models, which has the specific sizes of trackables
			return "units\\nightelf\\Wisp\\Wisp.mdx"
  endfunction


//library AStructSystemsGuiWidget ends
//library ASystemWorld:

//library ASystemWorld ends
//library ALibraryCoreDebugInterface:


 function ALibraryCoreDebugInterface__MultiboardBarValueFunctionGetValue takes integer multiboardBar returns real
		return 100.0
	endfunction

 function ALibraryCoreDebugInterface__MultiboardBarValueFunctionGetMaxValue takes integer multiboardBar returns real
		return 100.0
	endfunction

 function ALibraryCoreDebugInterface__GetMultiboardBarDebug takes player user returns nothing
  local integer multiboardBar
		if ( ALibraryCoreDebugInterface__usedMultiboard[GetPlayerId(user)] == null ) then
			set ALibraryCoreDebugInterface__usedMultiboard[GetPlayerId(user)]=CreateMultiboard()
			//function ShowMultiboardForPlayer takes player user, multiboard usedMultiboard, boolean show
			call ShowMultiboardForPlayer(user , ALibraryCoreDebugInterface__usedMultiboard[GetPlayerId(user)] , true)
			//static method create takes multiboard usedMultiboard, integer column, integer row, integer length, real refreshRate, boolean horizontal, real value, real maxValue, AMultiboardBarValueFunction valueFunction, AMultiboardBarValueFunction maxValueFunction returns AMultiboardBar
			set multiboardBar = s__AMultiboardBar_create(ALibraryCoreDebugInterface__usedMultiboard[GetPlayerId(user)] , 0 , 0 , 10 , 1.0 , true , 100.0 , 100.0 , (1) , (2))
			//method setAllIcons takes string icon, boolean valueIcon
			call s__AMultiboardBar_setAllIcons(multiboardBar,"ReplaceableTextures\\CommandButtons\\BTNAlleriaFlute.blp" , true)
			call s__AMultiboardBar_setAllIcons(multiboardBar,"ReplaceableTextures\\CommandButtons\\BTNSpellShieldAmulet.blp" , false)
			call s__AMultiboardBar_refresh(multiboardBar)
		endif
	endfunction

 function GetInterfaceDebug takes nothing returns nothing
  local player triggerPlayer= GetTriggerPlayer()
		call ALibraryCoreDebugInterface__GetMultiboardBarDebug(triggerPlayer)
		set triggerPlayer = null
	endfunction


//library ALibraryCoreDebugInterface ends
//library AStructSystemsCharacterInventory:

		//static constant members
		//static start members
		//members

		//members

  function s__AInventory_getEquipmentItemType takes integer this,integer equipmentType returns integer
			return s___AInventory_equipmentItemType[s__AInventory_equipmentItemType[this]+equipmentType]
  endfunction

  function s__AInventory_getRucksackItemType takes integer this,integer slot returns integer
			return s___AInventory_rucksackItemType[s__AInventory_rucksackItemType[this]+slot]
  endfunction

  function s__AInventory_getRucksackItemCharges takes integer this,integer slot returns integer
			return s___AInventory_rucksackItemCharges[s__AInventory_rucksackItemCharges[this]+slot]
  endfunction

		//methods

		/// Shows the current page in the inventory of the character's unit
		/// In general you do not have to call this method. The system handles itself.
  function s__AInventory_enable takes integer this returns nothing
			if ( s__AInventory_rucksackIsEnabled[this] ) then
				call sc__AInventory_enableRucksack(this)
			else
				call sc__AInventory_enableEquipment(this)
			endif

			call EnableTrigger(s__AInventory_openTrigger[this])
			call EnableTrigger(s__AInventory_orderTrigger[this])
			call EnableTrigger(s__AInventory_pickupTrigger[this])
			call EnableTrigger(s__AInventory_dropTrigger[this])
  endfunction

		/// In general you do not have to call this method. The system handles itself.
  function s__AInventory_disable takes integer this returns nothing
			if ( s__AInventory_rucksackIsEnabled[this] ) then
				call sc__AInventory_disableRucksack(this)
			else
				call sc__AInventory_disableEquipment(this)
			endif

			call DisableTrigger(s__AInventory_openTrigger[this])
			call DisableTrigger(s__AInventory_orderTrigger[this])
			call DisableTrigger(s__AInventory_pickupTrigger[this])
			call DisableTrigger(s__AInventory_dropTrigger[this])
  endfunction

		/// @return Returns the slot of the equipped item. If no item was found it returns -1.
  function s__AInventory_hasItemEquipped takes integer this,integer itemType returns integer
   local integer i= 0
			loop
				exitwhen ( i == s__AInventory_maxEquipmentTypes )
				if ( s___AInventory_equipmentItemType[s__AInventory_equipmentItemType[this]+i] == itemType ) then
					return i
				endif
				set i = i + 1
			endloop
			return - 1
  endfunction

		/// @return Returns the slot of the rucksack item. If not item was found it returns -1.
  function s__AInventory_hasItemInRucksack takes integer this,integer itemType returns integer
   local integer i= 0
			loop
				exitwhen ( i == s__AInventory_maxRucksackItems )
				if ( s___AInventory_rucksackItemType[s__AInventory_rucksackItemType[this]+i] == itemType ) then
					return i
				endif
				set i = i + 1
			endloop
			return - 1
  endfunction

  function s__AInventory_enableEquipment takes integer this returns nothing
   local integer i
			call DisableTrigger(s__AInventory_orderTrigger[this])
			call DisableTrigger(s__AInventory_pickupTrigger[this])
			set i = 0
			loop
				exitwhen ( i == s__AInventory_maxEquipmentTypes )
				if ( s___AInventory_equipmentItemType[s__AInventory_equipmentItemType[this]+i] != 0 ) then
					call sc__AInventory_showEquipmentItem(this,i)
				endif
				set i = i + 1
			endloop
			call EnableTrigger(s__AInventory_orderTrigger[this])
			call EnableTrigger(s__AInventory_pickupTrigger[this])
  endfunction

  function s__AInventory_disableEquipment takes integer this returns nothing
   local integer i
			call DisableTrigger(s__AInventory_orderTrigger[this])
			call DisableTrigger(s__AInventory_dropTrigger[this])
			set i = 0
			loop
				exitwhen ( i == s__AInventory_maxEquipmentTypes )
				if ( s___AInventory_equipmentItemType[s__AInventory_equipmentItemType[this]+i] != 0 ) then
					call sc__AInventory_hideEquipmentItem(this,i)
				endif
				set i = i + 1
			endloop
			call EnableTrigger(s__AInventory_orderTrigger[this])
			call EnableTrigger(s__AInventory_dropTrigger[this])
  endfunction

  function s__AInventory_enableRucksack takes integer this returns nothing
   local item leftArrowItem
   local item rightArrowItem
			set s__AInventory_rucksackIsEnabled[this]=true
			call DisableTrigger(s__AInventory_orderTrigger[this]) //Disable it otherwise it thinks the player wants to drop the items
			call DisableTrigger(s__AInventory_pickupTrigger[this])
			call UnitAddItemToSlotById(s__AAbstractCharacterSystem_getUnit(this) , s__AInventory_leftArrowItemType , s__AInventory_maxRucksackItemsPerPage)
			call UnitAddItemToSlotById(s__AAbstractCharacterSystem_getUnit(this) , s__AInventory_rightArrowItemType , s__AInventory_maxRucksackItemsPerPage + 1)
			set leftArrowItem = UnitItemInSlot(s__AAbstractCharacterSystem_getUnit(this) , s__AInventory_maxRucksackItemsPerPage)
			set rightArrowItem = UnitItemInSlot(s__AAbstractCharacterSystem_getUnit(this) , s__AInventory_maxRucksackItemsPerPage + 1)
			call SetItemDroppable(leftArrowItem , false)
			call SetItemDroppable(rightArrowItem , false)
			call SetItemCharges(rightArrowItem , s__AInventory_rucksackPage[this])
			set leftArrowItem = null
			set rightArrowItem = null
			call sc__AInventory_showRucksackPage(this,s__AInventory_rucksackPage[this] , true)
			call EnableTrigger(s__AInventory_orderTrigger[this])
			call EnableTrigger(s__AInventory_pickupTrigger[this])
			call EnableTrigger(s__AInventory_useTrigger[this]) //just required in rucksack
  endfunction

  function s__AInventory_disableRucksack takes integer this returns nothing
   local item leftArrowItem
   local item rightArrowItem
			set s__AInventory_rucksackIsEnabled[this]=false
			call DisableTrigger(s__AInventory_orderTrigger[this])
			call DisableTrigger(s__AInventory_dropTrigger[this])
			set leftArrowItem = UnitItemInSlot(s__AAbstractCharacterSystem_getUnit(this) , s__AInventory_maxRucksackItemsPerPage)
			set rightArrowItem = UnitItemInSlot(s__AAbstractCharacterSystem_getUnit(this) , s__AInventory_maxRucksackItemsPerPage + 1)
			call RemoveItem(leftArrowItem)
			call RemoveItem(rightArrowItem)
			set leftArrowItem = null
			set rightArrowItem = null
			call sc__AInventory_hideCurrentRucksackPage(this)
			call EnableTrigger(s__AInventory_orderTrigger[this])
			call EnableTrigger(s__AInventory_dropTrigger[this])
			call DisableTrigger(s__AInventory_useTrigger[this]) //just required in rucksack
  endfunction

  function s__AInventory_equipItem takes integer this,item usedItem,boolean fromRucksack returns nothing
   local integer itemType= s__AItemType_getItemTypeOfItem(usedItem) //AClassCharacterItemType
   local integer equipmentType= s__AItemType_getEquipmentType(itemType) //AClassCharacterItemType

			if ( itemType == 0 ) then
     call Print("AItemType is 0 of item " + GetItemName(usedItem) + " in instance " + I2S(this) + ".")
				return 
			endif

			if ( itemType != 0 and s___AInventory_equipmentItemType[s__AInventory_equipmentItemType[this]+equipmentType] == 0 ) then
				if ( s__AItemType_checkRequirement(itemType,s__AAbstractCharacterSystem_getCharacter(this)) ) then //AClassCharacterItemType
					call sc__AInventory_setEquipmentItem(this,usedItem , itemType , not s__AInventory_rucksackIsEnabled[this])
					return 
				endif
			endif

			//move to rucksack
			if ( not fromRucksack ) then
				call sc__AInventory_addItemToRucksack(this,usedItem , true)
			else
				call s__ACharacter_displayMessage(s__AAbstractCharacterSystem_getCharacter(this),s__ACharacter_messageTypeError , s__AInventory_textUnableToEquipItem) //AClassCharacterCharacter
			endif
  endfunction

  function s__AInventory_addItemToRucksack takes integer this,item usedItem,boolean fromEquipment returns nothing
   local integer i= 0
			loop
				exitwhen ( i == s__AInventory_maxRucksackItems )
				if ( s___AInventory_rucksackItemType[s__AInventory_rucksackItemType[this]+i] == 0 ) then
					call sc__AInventory_setRucksackItem(this,usedItem , i , ( s__AInventory_rucksackIsEnabled[this] and sc__AInventory_getItemRucksackPage(this,i) == s__AInventory_rucksackPage[this] ))
					return 
				endif
				set i = i + 1
			endloop

			//equip
			if ( not fromEquipment ) then
				call s__AInventory_equipItem(this,usedItem , true)
			else
				call s__ACharacter_displayMessage(s__AAbstractCharacterSystem_getCharacter(this),s__ACharacter_messageTypeError , s__AInventory_textUnableToAddRucksackItem) //AClassCharacterCharacter
			endif
  endfunction

  function s__AInventory_getItemRucksackPage takes integer this,integer index returns integer
   local integer i= 0
			loop
				exitwhen ( i == s__AInventory_maxRucksackPages )
				if ( index < i + s__AInventory_maxRucksackItemsPerPage ) then
					return i
				endif
				set i = i + 1
			endloop
			return - 1
  endfunction

  function s__AInventory_getRucksackItemSlot takes integer this,integer index returns integer
			return index - s__AInventory_rucksackPage[this] * s__AInventory_maxRucksackItemsPerPage
  endfunction

  function s__AInventory_getSlotRucksackIndex takes integer this,integer slot returns integer
			return s__AInventory_rucksackPage[this] * s__AInventory_maxRucksackItemsPerPage + slot
  endfunction

		/// Just required for the move order and for item dropping.
  function s__AInventory_getItemIndex takes integer this,item usedItem returns integer
			return s__AHashTable_getHandleInteger(AGetCharacterHashTable(),usedItem , "AInventory_index") //AClassCharacterCharacterHashTable
  endfunction

  function s__AInventory_setEquipmentItem takes integer this,item usedItem,integer equipmentType,boolean add returns nothing
   local item slotItem
			if ( add ) then
     call Print("Add equipment item, rucksack is not enabled.")
				call UnitAddItemToSlotById(s__AAbstractCharacterSystem_getUnit(this) , GetItemTypeId(usedItem) , equipmentType)
				set slotItem = UnitItemInSlot(s__AAbstractCharacterSystem_getUnit(this) , equipmentType)
				call s__AHashTable_storeHandleInteger(AGetCharacterHashTable(),slotItem , "AInventory_index" , equipmentType) //AClassCharacterCharacterHashTable
				//Setting charges is not required.
				set slotItem = null
			endif
			set s___AInventory_equipmentItemType[s__AInventory_equipmentItemType[this]+equipmentType]=GetItemTypeId(usedItem)
			call RemoveItem(usedItem)
  endfunction

  function s__AInventory_clearEquipmentItem takes integer this,integer equipmentType,boolean drop returns nothing
   local item slotItem= UnitItemInSlot(s__AAbstractCharacterSystem_getUnit(this) , equipmentType)
			call s__AHashTable_flushHandleInteger(AGetCharacterHashTable(),slotItem , "AInventory_index") //AClassCharacterCharacterHashTable
			set s___AInventory_equipmentItemType[s__AInventory_equipmentItemType[this]+equipmentType]=0
			if ( drop ) then
				call UnitDropItemPoint(s__AAbstractCharacterSystem_getUnit(this) , slotItem , GetUnitX(s__AAbstractCharacterSystem_getUnit(this)) , GetUnitY(s__AAbstractCharacterSystem_getUnit(this)))
			else
				call RemoveItem(slotItem)
			endif
			set slotItem = null
			call sc__AInventory_checkEquipment(this) //added
  endfunction

  function s__AInventory_showEquipmentItem takes integer this,integer equipmentType returns nothing
   local item slotItem
			call UnitAddItemToSlotById(s__AAbstractCharacterSystem_getUnit(this) , s___AInventory_equipmentItemType[s__AInventory_equipmentItemType[this]+equipmentType] , equipmentType)
			set slotItem = UnitItemInSlot(s__AAbstractCharacterSystem_getUnit(this) , equipmentType)
			call s__AHashTable_storeHandleInteger(AGetCharacterHashTable(),slotItem , "AInventory_index" , equipmentType) //AClassCharacterCharacterHashTable
			set slotItem = null
  endfunction

  function s__AInventory_hideEquipmentItem takes integer this,integer equipmentType returns nothing
   local item slotItem= UnitItemInSlot(s__AAbstractCharacterSystem_getUnit(this) , equipmentType)
			call RemoveItem(slotItem)
			set slotItem = null
  endfunction

  function s__AInventory_checkEquipment takes integer this returns nothing
   local item slotItem
   local integer itemType
   local integer i= 0
			loop
				exitwhen ( i == s__AInventory_maxEquipmentTypes )
				if ( s___AInventory_equipmentItemType[s__AInventory_equipmentItemType[this]+i] != 0 ) then
					set slotItem = UnitItemInSlot(s__AAbstractCharacterSystem_getUnit(this) , i)
					set itemType = s__AItemType_getItemTypeOfItem(slotItem) //AClassCharacterItemType
      if ( itemType == 0 ) then
       call Print("AItemType of item " + GetItemName(slotItem) + " in instance " + I2S(this) + " and slot " + I2S(i) + " is 0.")
      endif
					if ( not s__AItemType_checkRequirement(itemType,s__AAbstractCharacterSystem_getCharacter(this)) ) then
						call s__AInventory_clearEquipmentItem(this,i , true)
					endif
					set slotItem = null
				endif
				set i = i + 1
			endloop
  endfunction

  function s__AInventory_setRucksackItem takes integer this,item usedItem,integer index,boolean add returns nothing
   local integer slot
   local item slotItem
			if ( add ) then
				set slot = s__AInventory_getRucksackItemSlot(this,index)
				call UnitAddItemToSlotById(s__AAbstractCharacterSystem_getUnit(this) , GetItemTypeId(usedItem) , slot)
				set slotItem = UnitItemInSlot(s__AAbstractCharacterSystem_getUnit(this) , slot)
				call s__AHashTable_storeHandleInteger(AGetCharacterHashTable(),slotItem , "AInventory_index" , index) //AClassCharacterCharacterHashTable
				call SetItemCharges(slotItem , GetItemCharges(usedItem))
				set slotItem = null
			endif
			set s___AInventory_rucksackItemType[s__AInventory_rucksackItemType[this]+index]=GetItemTypeId(usedItem)
			set s___AInventory_rucksackItemCharges[s__AInventory_rucksackItemCharges[this]+index]=GetItemCharges(usedItem)
			call RemoveItem(usedItem)
  endfunction

  function s__AInventory_clearRucksackItem takes integer this,integer index,boolean drop returns nothing
   local item slotItem= UnitItemInSlot(s__AAbstractCharacterSystem_getUnit(this) , s__AInventory_getRucksackItemSlot(this,index))
			call s__AHashTable_flushHandleInteger(AGetCharacterHashTable(),slotItem , "AInventory_index") //AClassCharacterCharacterHashTable
			set s___AInventory_rucksackItemType[s__AInventory_rucksackItemType[this]+index]=0
			set s___AInventory_rucksackItemCharges[s__AInventory_rucksackItemCharges[this]+index]=0
			if ( drop ) then
				call UnitDropItemPoint(s__AAbstractCharacterSystem_getUnit(this) , slotItem , GetUnitX(s__AAbstractCharacterSystem_getUnit(this)) , GetUnitY(s__AAbstractCharacterSystem_getUnit(this)))
			else
				call RemoveItem(slotItem)
			endif
			set slotItem = null
  endfunction

  function s__AInventory_showRucksackItem takes integer this,integer index returns nothing
   local integer slot= s__AInventory_getRucksackItemSlot(this,index)
   local item slotItem
			call UnitAddItemToSlotById(s__AAbstractCharacterSystem_getUnit(this) , s___AInventory_rucksackItemType[s__AInventory_rucksackItemType[this]+index] , slot)
			set slotItem = UnitItemInSlot(s__AAbstractCharacterSystem_getUnit(this) , slot)
			call SetItemCharges(slotItem , s___AInventory_rucksackItemCharges[s__AInventory_rucksackItemCharges[this]+index])
			call s__AHashTable_storeHandleInteger(AGetCharacterHashTable(),slotItem , "AInventory_index" , index) //AClassCharacterCharacterHashTable
			set slotItem = null
  endfunction

  function s__AInventory_hideRucksackItem takes integer this,integer index returns nothing
   local integer slot= s__AInventory_getRucksackItemSlot(this,index)
   local item slotItem= UnitItemInSlot(s__AAbstractCharacterSystem_getUnit(this) , slot)
			call RemoveItem(slotItem)
			set slotItem = null
  endfunction

  function s__AInventory_showRucksackPage takes integer this,integer page,boolean firstCall returns nothing
   local integer i
   local integer exitValue
    if ( page > s__AInventory_maxRucksackPages ) then
     call Print("AInventory: Page value is too high.")
     return 
    endif

			set s__AInventory_rucksackPage[this]=page

			if ( not firstCall ) then
				call sc__AInventory_hideCurrentRucksackPage(this)
			endif

			//add inventory items
			set i = page * s__AInventory_maxRucksackItemsPerPage
			set exitValue = i + s__AInventory_maxRucksackItemsPerPage
			loop
				exitwhen ( i == exitValue )
				if ( s___AInventory_rucksackItemType[s__AInventory_rucksackItemType[this]+i] != 0 ) then
					call s__AInventory_showRucksackItem(this,i)
				endif
				set i = i + 1
			endloop
  endfunction

  function s__AInventory_hideCurrentRucksackPage takes integer this returns nothing
   local integer i= s__AInventory_rucksackPage[this] * s__AInventory_maxRucksackItemsPerPage
   local integer exitValue= i + s__AInventory_maxRucksackItemsPerPage
			loop
				exitwhen ( i == exitValue )
				if ( s___AInventory_rucksackItemType[s__AInventory_rucksackItemType[this]+i] != 0 ) then
					call s__AInventory_hideRucksackItem(this,i)
				endif
				set i = i + 1
			endloop
  endfunction

  function s__AInventory_showNextRucksackPage takes integer this returns nothing
			if ( s__AInventory_rucksackPage[this] == s__AInventory_maxRucksackPages ) then
				call s__AInventory_showRucksackPage(this,s__AInventory_rucksackPage[this] + 1 , false)
			else
				call s__AInventory_showRucksackPage(this,0 , false)
			endif
  endfunction

  function s__AInventory_showPreviousRucksackPage takes integer this returns nothing
			if ( s__AInventory_rucksackPage[this] == 0 ) then
				call s__AInventory_showRucksackPage(this,s__AInventory_maxRucksackPages , false)
			else
				call s__AInventory_showRucksackPage(this,s__AInventory_rucksackPage[this] - 1 , false)
			endif
  endfunction

  function s__AInventory_moveRucksackItemToPage takes integer this,integer slot,boolean next returns nothing
   local integer i
   local integer exitValue
   local integer j
   local integer index
   local item slotItem
   local boolean result= false
			set i = s__AInventory_rucksackPage[this]

			if ( next ) then
				set exitValue = s__AInventory_maxRucksackPages
			else
				set exitValue = 0
			endif
			loop
				exitwhen ( i == exitValue or result )
					set j = 0
					loop
						exitwhen ( j == s__AInventory_maxRucksackItemsPerPage )
						set index = i * j
						if ( s___AInventory_rucksackItemType[s__AInventory_rucksackItemType[this]+index] == 0 ) then
							set slotItem = UnitItemInSlot(s__AAbstractCharacterSystem_getUnit(this) , slot)
							call s__AInventory_addItemToRucksack(this,slotItem , false)
							set slotItem = null
							set result = true
							exitwhen ( true )
						endif
						set j = j + 1
					endloop
				if ( next ) then
					set i = i + 1
				else
					set i = i - 1
				endif
			endloop

			if ( not result ) then
				call s__ACharacter_displayMessage(s__AAbstractCharacterSystem_getCharacter(this),s__ACharacter_messageTypeError , s__AInventory_textUnableToMoveRucksackItem) //AClassCharacterCharacter
			endif
  endfunction

  function s__AInventory_swapRucksackItemData takes integer this,integer firstIndex,integer secondIndex returns nothing
   local integer itemType= s___AInventory_rucksackItemType[s__AInventory_rucksackItemType[this]+firstIndex]
   local integer itemCharges= s___AInventory_rucksackItemCharges[s__AInventory_rucksackItemCharges[this]+firstIndex]
			set s___AInventory_rucksackItemType[s__AInventory_rucksackItemType[this]+firstIndex]=s___AInventory_rucksackItemType[s__AInventory_rucksackItemType[this]+secondIndex]
			set s___AInventory_rucksackItemCharges[s__AInventory_rucksackItemCharges[this]+firstIndex]=s___AInventory_rucksackItemCharges[s__AInventory_rucksackItemCharges[this]+secondIndex]
			set s___AInventory_rucksackItemType[s__AInventory_rucksackItemType[this]+secondIndex]=itemType
			set s___AInventory_rucksackItemCharges[s__AInventory_rucksackItemCharges[this]+secondIndex]=itemCharges
  endfunction

  function s__AInventory_moveRucksackItem takes integer this,item movedItem,integer slot returns nothing
   local item targetItem
   local integer index0= s__AInventory_getItemIndex(this,movedItem)
   local integer index1= s__AInventory_getSlotRucksackIndex(this,slot)

			//equip
			if ( index0 == index1 ) then
				call s__AInventory_equipItem(this,movedItem , true) //test
				call s__AInventory_clearRucksackItem(this,index0 , false)
				return 
			endif

			//stack
			set targetItem = UnitItemInSlot(s__AAbstractCharacterSystem_getUnit(this) , slot)
			if ( GetItemTypeId(movedItem) == GetItemTypeId(targetItem) ) then
				set s___AInventory_rucksackItemCharges[s__AInventory_rucksackItemCharges[this]+index1]=s___AInventory_rucksackItemCharges[s__AInventory_rucksackItemCharges[this]+index1] + s___AInventory_rucksackItemCharges[s__AInventory_rucksackItemCharges[this]+index0]
				call SetItemCharges(targetItem , s___AInventory_rucksackItemCharges[s__AInventory_rucksackItemCharges[this]+index1])
				call s__AInventory_clearRucksackItem(this,index0 , false)
				set targetItem = null
				return 
			endif
			set targetItem = null

			//swap
			call s__AInventory_swapRucksackItemData(this,index0 , index1)
  endfunction

  function s__AInventory_triggerConditionOpen takes nothing returns boolean
			return GetSpellAbilityId() == s__AInventory_openRucksackAbilityId
  endfunction

  function s__AInventory_triggerActionOpen takes nothing returns nothing
   local trigger triggeringTrigger= GetTriggeringTrigger()
   local integer inventory= s__AHashTable_getHandleInteger(AGetCharacterHashTable(),triggeringTrigger , "inventory") //AClassCharacterCharacterHashTable
			if ( s__AInventory_rucksackIsEnabled[inventory] ) then
				call s__AInventory_disableRucksack(inventory)
				call s__AInventory_enableEquipment(inventory)
			else
				call s__AInventory_disableEquipment(inventory)
				call s__AInventory_enableRucksack(inventory)
			endif
			set triggeringTrigger = null
  endfunction

  function s__AInventory_createOpenTrigger takes integer this returns nothing
   local event triggerEvent
   local conditionfunc conditionFunction
   local triggercondition triggerCondition
   local triggeraction triggerAction
			set s__AInventory_openTrigger[this]=CreateTrigger()
			set triggerEvent = TriggerRegisterUnitEvent(s__AInventory_openTrigger[this] , s__AAbstractCharacterSystem_getUnit(this) , EVENT_UNIT_SPELL_CAST)
			set conditionFunction = Condition(function s__AInventory_triggerConditionOpen)
			set triggerCondition = TriggerAddCondition(s__AInventory_openTrigger[this] , conditionFunction)
			set triggerAction = TriggerAddAction(s__AInventory_openTrigger[this] , function s__AInventory_triggerActionOpen)
			call s__AHashTable_storeHandleInteger(AGetCharacterHashTable(),s__AInventory_openTrigger[this] , "inventory" , this) //AClassCharacterCharacterHashTable
			set triggerEvent = null
			set conditionFunction = null
			set triggerCondition = null
			set triggerAction = null
  endfunction

  function s__AInventory_triggerActionOrder takes nothing returns nothing
   local trigger triggeringTrigger= GetTriggeringTrigger()
   local integer inventory= s__AHashTable_getHandleInteger(AGetCharacterHashTable(),triggeringTrigger , "inventory") //AClassCharacterCharacterHashTable
   local integer order= GetIssuedOrderId()
   local item usedItem= GetManipulatedItem()

			if ( s__AInventory_rucksackIsEnabled[inventory] ) then
				set order = order - 852002
				// move item next - player drops an item on the next page item
				if ( order == s__AInventory_maxRucksackItemsPerPage ) then
					call s__AInventory_moveRucksackItemToPage(inventory,order , true)
				// move item previous - player drops an item on the previous page item
				elseif ( order == s__AInventory_maxRucksackItemsPerPage + 1 ) then
					call s__AInventory_moveRucksackItemToPage(inventory,order , false)
				// equip item/stack items/swap items
				elseif ( order >= 0 and order < s__AInventory_maxRucksackItemsPerPage ) then
					call s__AInventory_moveRucksackItem(inventory,usedItem , order)
				endif
			else
				//unequip?
				//drop the item on its own slot
				//if you want to swap equipment items it is not possible!
			endif
			set triggeringTrigger = null
			set usedItem = null
  endfunction

  function s__AInventory_createOrderTrigger takes integer this returns nothing
   local event triggerEvent
   local triggeraction triggerAction
			set s__AInventory_orderTrigger[this]=CreateTrigger()
			set triggerEvent = TriggerRegisterUnitEvent(s__AInventory_orderTrigger[this] , s__AAbstractCharacterSystem_getUnit(this) , EVENT_UNIT_ISSUED_ORDER)
			set triggerAction = TriggerAddAction(s__AInventory_orderTrigger[this] , function s__AInventory_triggerActionOrder)
			call s__AHashTable_storeHandleInteger(AGetCharacterHashTable(),s__AInventory_orderTrigger[this] , "inventory" , this) //AClassCharacterCharacterHashTable
			set triggerEvent = null
			set triggerAction = null
			//add, drop, move item next, move item previous, stack items
  endfunction

  function s__AInventory_triggerActionPickup takes nothing returns nothing
   local trigger triggeringTrigger= GetTriggeringTrigger()
   local integer inventory= s__AHashTable_getHandleInteger(AGetCharacterHashTable(),triggeringTrigger , "inventory") //AClassCharacterCharacterHashTable
   local item usedItem= GetManipulatedItem()
    call Print("Pickup")
			if ( s__AInventory_rucksackIsEnabled[inventory] ) then
				call s__AInventory_addItemToRucksack(inventory,usedItem , false)
			else
				call s__AInventory_equipItem(inventory,usedItem , false)
			endif
			set triggeringTrigger = null
			set usedItem = null
  endfunction

  function s__AInventory_createPickupTrigger takes integer this returns nothing
   local event triggerEvent
   local triggeraction triggerAction
			set s__AInventory_pickupTrigger[this]=CreateTrigger()
			set triggerEvent = TriggerRegisterUnitEvent(s__AInventory_pickupTrigger[this] , s__AAbstractCharacterSystem_getUnit(this) , EVENT_UNIT_PICKUP_ITEM) //pawn?
			set triggerAction = TriggerAddAction(s__AInventory_pickupTrigger[this] , function s__AInventory_triggerActionPickup)
			call s__AHashTable_storeHandleInteger(AGetCharacterHashTable(),s__AInventory_pickupTrigger[this] , "inventory" , this) //AClassCharacterCharacterHashTable
			set triggerEvent = null
			set triggerAction = null
  endfunction

  function s__AInventory_triggerActionDrop takes nothing returns nothing
   local trigger triggeringTrigger= GetTriggeringTrigger()
   local integer inventory= s__AHashTable_getHandleInteger(AGetCharacterHashTable(),triggeringTrigger , "inventory") //AClassCharacterCharacterHashTable
   local item usedItem= GetManipulatedItem()
			if ( s__AInventory_rucksackIsEnabled[inventory] ) then
				call s__AInventory_clearRucksackItem(inventory,s__AInventory_getItemIndex(inventory,usedItem) , true)
			else
				call s__AInventory_clearEquipmentItem(inventory,s__AInventory_getItemIndex(inventory,usedItem) , true)
			endif
			set triggeringTrigger = null
			set usedItem = null
  endfunction

  function s__AInventory_createDropTrigger takes integer this returns nothing
   local event triggerEvent
   local triggeraction triggerAction
			set s__AInventory_useTrigger[this]=CreateTrigger()
			set triggerEvent = TriggerRegisterUnitEvent(s__AInventory_useTrigger[this] , s__AAbstractCharacterSystem_getUnit(this) , EVENT_UNIT_DROP_ITEM)
			set triggerAction = TriggerAddAction(s__AInventory_useTrigger[this] , function s__AInventory_triggerActionDrop)
			call s__AHashTable_storeHandleInteger(AGetCharacterHashTable(),s__AInventory_useTrigger[this] , "inventory" , this) //AClassCharacterCharacterHashTable
			set triggerEvent = null
			set triggerAction = null
  endfunction

  function s__AInventory_triggerActionUse takes nothing returns nothing
   local trigger triggeringTrigger= GetTriggeringTrigger()
   local integer inventory= s__AHashTable_getHandleInteger(AGetCharacterHashTable(),triggeringTrigger , "inventory") //AClassCharacterCharacterHashTable
   local item usedItem= GetManipulatedItem()
   local integer itemTypeId= GetItemTypeId(usedItem)
			//if (inventory.rucksackIsEnabled) then
				//show next page
				if ( itemTypeId == s__AInventory_rightArrowItemType ) then
					call s__AInventory_showNextRucksackPage(inventory)
				//show previous page
				elseif ( itemTypeId == s__AInventory_leftArrowItemType ) then
					call s__AInventory_showPreviousRucksackPage(inventory)
				endif
			//endif
			set triggeringTrigger = null
			set usedItem = null
  endfunction

  function s__AInventory_createUseTrigger takes integer this returns nothing
   local event triggerEvent
   local triggeraction triggerAction
			set s__AInventory_useTrigger[this]=CreateTrigger()
			set triggerEvent = TriggerRegisterUnitEvent(s__AInventory_useTrigger[this] , s__AAbstractCharacterSystem_getUnit(this) , EVENT_UNIT_USE_ITEM)
			set triggerAction = TriggerAddAction(s__AInventory_useTrigger[this] , function s__AInventory_triggerActionUse)
			call s__AHashTable_storeHandleInteger(AGetCharacterHashTable(),s__AInventory_useTrigger[this] , "inventory" , this) //AClassCharacterCharacterHashTable
			set triggerEvent = null
			set triggerAction = null
  endfunction

  function s__AInventory_create takes integer character returns integer
   local integer this= s__AInventory__allocate(character)
			//members
			set s__AInventory_rucksackPage[this]=0
			set s__AInventory_rucksackIsEnabled[this]=false

			call UnitAddAbility(s__AAbstractCharacterSystem_getUnit(this) , s__AInventory_openRucksackAbilityId)

			call s__AInventory_createOpenTrigger(this)
			call s__AInventory_createOrderTrigger(this)
			call s__AInventory_createPickupTrigger(this)
			call s__AInventory_createDropTrigger(this)
			call s__AInventory_createUseTrigger(this)
			return this
  endfunction

  function s__AInventory_destroyOpenTrigger takes integer this returns nothing
			call s__AHashTable_destroyTrigger(AGetCharacterHashTable(),s__AInventory_openTrigger[this]) //AClassCharacterCharacterHashTable
			set s__AInventory_openTrigger[this]=null
  endfunction

  function s__AInventory_destroyOrderTrigger takes integer this returns nothing
			call s__AHashTable_destroyTrigger(AGetCharacterHashTable(),s__AInventory_orderTrigger[this]) //AClassCharacterCharacterHashTable
			set s__AInventory_orderTrigger[this]=null
  endfunction

  function s__AInventory_destroyPickupTrigger takes integer this returns nothing
			call s__AHashTable_destroyTrigger(AGetCharacterHashTable(),s__AInventory_pickupTrigger[this]) //AClassCharacterCharacterHashTable
			set s__AInventory_pickupTrigger[this]=null
  endfunction

  function s__AInventory_destroyDropTrigger takes integer this returns nothing
			call s__AHashTable_destroyTrigger(AGetCharacterHashTable(),s__AInventory_dropTrigger[this]) //AClassCharacterCharacterHashTable
			set s__AInventory_dropTrigger[this]=null
  endfunction

  function s__AInventory_destroyUseTrigger takes integer this returns nothing
			call s__AHashTable_destroyTrigger(AGetCharacterHashTable(),s__AInventory_useTrigger[this]) //AClassCharacterCharacterHashTable
			set s__AInventory_useTrigger[this]=null
  endfunction

  function s__AInventory_onDestroy takes integer this returns nothing
			call UnitRemoveAbility(s__AAbstractCharacterSystem_getUnit(this) , s__AInventory_openRucksackAbilityId)

			call s__AInventory_destroyOpenTrigger(this)
			call s__AInventory_destroyOrderTrigger(this)
			call s__AInventory_destroyPickupTrigger(this)
			call s__AInventory_destroyDropTrigger(this)
			call s__AInventory_destroyUseTrigger(this)
  endfunction

  function s__AInventory_init takes integer leftArrowItemType,integer rightArrowItemType,integer openRucksackAbilityId,string textUnableToEquipItem,string textUnableToAddRucksackItem,string textUnableToMoveRucksackItem returns nothing
			//static start members
			set s__AInventory_leftArrowItemType=leftArrowItemType
			set s__AInventory_rightArrowItemType=rightArrowItemType
			set s__AInventory_openRucksackAbilityId=openRucksackAbilityId
			set s__AInventory_textUnableToEquipItem=textUnableToEquipItem
			set s__AInventory_textUnableToAddRucksackItem=textUnableToAddRucksackItem
			set s__AInventory_textUnableToMoveRucksackItem=textUnableToMoveRucksackItem
  endfunction


//library AStructSystemsCharacterInventory ends
//library AStructSystemsCharacterQuest:

		//static start members
		//dynamic members
		//properties

//textmacro instance: A_STRUCT_DEBUG("\"AQuest\"")
   function s__AQuest_print takes integer this,string message returns nothing
    call Print("AQuest" + " - " + I2S(this) + ": " + message)
   endfunction

   function s__AQuest_staticPrint takes string message returns nothing
    call Print("AQuest" + ": " + message)
   endfunction
//end of: A_STRUCT_DEBUG("\"AQuest\"")

		//dynamic members

  function s__AQuest_addQuestItem takes integer this,integer questItem returns integer
   local integer id= s__AQuest_questItems[this]
			if ( id < s__AQuest_maxQuestItems ) then
				set s__AQuest_questItems[this]=s__AQuest_questItems[this] + 1
				set s___AQuest_questItem[s__AQuest_questItem[this]+id]=questItem
				return id
			endif
			return - 1
  endfunction

  function s__AQuest_getQuestItem takes integer this,integer id returns integer
			return s___AQuest_questItem[s__AQuest_questItem[this]+id]
  endfunction
		
  function s__AQuest_setIconPath takes integer this,string iconPath returns nothing
    if ( not s__AQuest_useQuestLog ) then
     call s__AQuest_print(this,"setIconPath() was called (quest log is disabled).")
    endif
			set s__AQuest_iconPath[this]=iconPath
			call QuestSetIconPath(s__AQuest_questLogQuest[this] , iconPath)
  endfunction
		
  function s__AQuest_getIconPath takes integer this returns string
			return s__AQuest_iconPath[this]
  endfunction

		/// No flash, just when you change the state!
		/// Description also is not used as start property because you do not always use the quest log.
  function s__AQuest_setDescription takes integer this,string description returns nothing
    if ( not s__AQuest_useQuestLog ) then
     call s__AQuest_print(this,"setDescription() was called (quest log is disabled).")
    endif
			set s__AQuest_description[this]=description
			call QuestSetDescription(s__AQuest_questLogQuest[this] , description)
  endfunction

  function s__AQuest_getDescription takes integer this returns string
			return s__AQuest_description[this]
  endfunction

		//members

		/// Used by AQuestItem, do not use.
  function s__AQuest_getQuestLogQuest takes integer this returns quest
			return s__AQuest_questLogQuest[this]
  endfunction

		//methods

  function s__AQuest_setState takes integer this,integer state returns nothing
			//local integer i
			call s__AAbstractQuest_setState(this,state)
			//set i = 0
			//loop
				//exitwhen (i == this.questItems)
				//if (this.questItem[i].getState() != state) then
					//call this.questItem[i].setState(state)  //AClassCharacterAbstractQuest
				//endif
				//set i = i + 1
			//endloop
			if ( s__AQuest_useQuestLog ) then
				call QuestSetTitle(s__AQuest_questLogQuest[this] , s__AAbstractQuest_getTitle(this))
				//call QuestSetDescription(this.questLogQuest, this.description)
				if ( state == s__AAbstractQuest_stateNew ) then
					call QuestSetDiscovered(s__AQuest_questLogQuest[this] , true)
				elseif ( state == s__AAbstractQuest_stateCompleted ) then
					call QuestSetCompleted(s__AQuest_questLogQuest[this] , true)
				elseif ( state == s__AAbstractQuest_stateFailed ) then
					call QuestSetFailed(s__AQuest_questLogQuest[this] , true)
				endif
				call FlashQuestDialogButton()
				call ForceQuestDialogUpdate() //required?
			endif
  endfunction

  function s__AQuest_displayUpdateMessage takes integer this,string message returns nothing
			call DisplayTimedTextToPlayer(s__ACharacter_getUser(s__AAbstractQuest_getCharacter(this)) , 0.0 , 0.0 , 20.0 , s__AAbstractQuest_getTitle(this))
			call DisplayTimedTextToPlayer(s__ACharacter_getUser(s__AAbstractQuest_getCharacter(this)) , 0.0 , 0.0 , 20.0 , message)
			call PlaySoundPathForPlayer(s__ACharacter_getUser(s__AAbstractQuest_getCharacter(this)) , s__AQuest_updateSoundPath) //ALibraryEnvironmentSound
  endfunction

		//Wenn alle QuestItems den gleichen State haben, erhlt das Quest ebenfalls diesen State
  function s__AQuest_checkQuestItemsForState takes integer this,integer state returns boolean
   local integer i
   local boolean result
			//Hat noch nicht den State
			if ( s__AAbstractQuest_getState(this) != state ) then
				set result = true
				set i = 0
				loop
					exitwhen ( i == s__AQuest_questItems[this] )
					if ( s__AAbstractQuest_getState(s___AQuest_questItem[s__AQuest_questItem[this]+i]) != state ) then
						set result = false
					endif
					set i = ( i + 1 )
				endloop
				if ( result ) then
					call sc__AAbstractQuest_setState(this,state)
				endif
			endif
			return result
  endfunction

  function s__AQuest_createQuestLogQuest takes integer this returns nothing
			if ( s__AQuest_useQuestLog ) then
				set s__AQuest_questLogQuest[this]=CreateQuest()
				call QuestSetDiscovered(s__AQuest_questLogQuest[this] , false) //hide quest before setting state
				call QuestSetRequired(s__AQuest_questLogQuest[this] , s__AAbstractQuest_getCharacter(this) == 0)
			endif
  endfunction

  function s__AQuest_create takes integer character,string title,real pingRate returns integer
   local integer this= s__AQuest__allocate(character , title , pingRate)
			//members
			set s__AQuest_questItems[this]=0

			call s__AQuest_createQuestLogQuest(this)
			return this
  endfunction

  function s__AQuest_destroyQuestLogQuest takes integer this returns nothing
			if ( s__AQuest_useQuestLog ) then
				call DestroyQuest(s__AQuest_questLogQuest[this])
				set s__AQuest_questLogQuest[this]=null
			endif
  endfunction
	
		//Alle QuestItems werden auch zerstrt
  function s__AQuest_destroyQuestItems takes integer this returns nothing
   local integer i= 0
			loop
				exitwhen ( i == s__AQuest_questItems[this] )
				call sc__AAbstractQuest_destroy(s__AQuest_questItem[this])
				set i = i + 1
			endloop
  endfunction

  function s__AQuest_onDestroy takes integer this returns nothing
			call s__AQuest_destroyQuestLogQuest(this)
			call s__AQuest_destroyQuestItems(this)
  endfunction

		//init is already used
  function s__AQuest_init0 takes boolean useQuestLog,string updateSoundPath returns nothing
			//static start members
			set s__AQuest_useQuestLog=useQuestLog
			set s__AQuest_updateSoundPath=updateSoundPath
  endfunction

		//static start members

		//AQuestItem need access
  function s__AQuest_isQuestLogUsed takes nothing returns boolean
			return s__AQuest_useQuestLog
  endfunction


//library AStructSystemsCharacterQuest ends
//library AStructSystemsCharacterShrine:

		//static start members
		//start members
		//members

//textmacro instance: A_STRUCT_DEBUG("\"AShrine\"")
   function s__AShrine_print takes integer this,string message returns nothing
    call Print("AShrine" + " - " + I2S(this) + ": " + message)
   endfunction

   function s__AShrine_staticPrint takes string message returns nothing
    call Print("AShrine" + ": " + message)
   endfunction
//end of: A_STRUCT_DEBUG("\"AShrine\"")

		//start members

  function s__AShrine_getUsedDestructable takes integer this returns destructable
			return s__AShrine_usedDestructable[this]
  endfunction

  function s__AShrine_getDiscoverRect takes integer this returns rect
			return s__AShrine_discoverRect[this]
  endfunction

  function s__AShrine_getRevivalRect takes integer this returns rect
			return s__AShrine_revivalRect[this]
  endfunction

		//methods

  function s__AShrine_enableForCharacter takes integer this,integer character returns nothing
			call s__ACharacter_setShrine(character,this) //AClassCharacterCharacter
			call s__ARevival_setX(s__ACharacter_getRevival(character),GetRandomReal(GetRectMinX(s__AShrine_revivalRect[this]) , GetRectMaxX(s__AShrine_revivalRect[this]))) //AClassCharacterCharacter, AClassCharacterRevival
			call s__ARevival_setY(s__ACharacter_getRevival(character),GetRandomReal(GetRectMinY(s__AShrine_revivalRect[this]) , GetRectMaxY(s__AShrine_revivalRect[this]))) //AClassCharacterCharacter, AClassCharacterRevival
			call s__ARevival_setFacing(s__ACharacter_getRevival(character),GetRandomReal(0.0 , 360.0)) //AClassCharacterCharacter, AClassCharacterRevival
			if ( s__AShrine_effectPath != null ) then
				set s__AShrine_discoverEffect[this]=CreateSpecialEffectForPlayer(s__ACharacter_getUser(character) , s__AShrine_effectPath , GetDestructableX(s__AShrine_usedDestructable[this]) , GetDestructableY(s__AShrine_usedDestructable[this])) //ALibraryEnvironmentSpecialEffect
			endif
			if ( s__AShrine_soundPath != null ) then
				call PlaySoundPathForPlayer(s__ACharacter_getUser(character) , s__AShrine_soundPath)
			endif
			call s__ACharacter_displayMessage(character,s__ACharacter_messageTypeInfo , s__AShrine_textMessage)
  endfunction

  function s__AShrine_disableForCharacter takes integer this,integer character returns nothing
    if ( s__ACharacter_getShrine(character) == this ) then //AClassCharacterCharacter
				call s__ACharacter_setShrine(character,0)
				if ( s__AShrine_effectPath != null ) then
					call DestroyEffect(s__AShrine_discoverEffect[this])
					set s__AShrine_discoverEffect[this]=null
				endif
    else
     call s__AShrine_print(this,"Ist nicht der Schrein des Charakters " + I2S(character) + ".")
    endif
  endfunction

  function s__AShrine_createDiscoverRegion takes integer this returns nothing
			set s__AShrine_discoverRegion[this]=CreateRegion()
			call RegionAddRect(s__AShrine_discoverRegion[this] , s__AShrine_discoverRect[this])
  endfunction

  function s__AShrine_triggerConditionEnable takes nothing returns boolean
   local trigger triggeringTrigger
   local unit triggerUnit= GetTriggerUnit()
   local player owner= GetOwningPlayer(triggerUnit)
   local integer shrine
   local boolean result= false
			if ( triggerUnit == s__ACharacter_getUsedUnit(s__ACharacter_getPlayerCharacter(owner)) ) then
				set triggeringTrigger = GetTriggeringTrigger()
				set shrine = s__AHashTable_getHandleInteger(AGetCharacterHashTable(),triggeringTrigger , "shrine")
				if ( s__ACharacter_getShrine(s__ACharacter_getPlayerCharacter(owner)) != shrine ) then
					set result = s__ACharacter_getMovable(s__ACharacter_getPlayerCharacter(owner))
				endif
				set triggeringTrigger = null
			endif
			set triggerUnit = null
			set owner = null
			return result
  endfunction

  function s__AShrine_triggerActionEnable takes nothing returns nothing
   local trigger triggeringTrigger= GetTriggeringTrigger()
   local unit triggerUnit= GetTriggerUnit()
   local player owner= GetOwningPlayer(triggerUnit)
   local integer shrine= s__AHashTable_getHandleInteger(AGetCharacterHashTable(),triggeringTrigger , "shrine") //AClassCharacterCharacterHashTable
			call s__AShrine_disableForCharacter(s__ACharacter_getShrine(s__ACharacter_getPlayerCharacter(owner)),s__ACharacter_getPlayerCharacter(owner)) //AClassCharacterCharacter, disable old
			call s__AShrine_enableForCharacter(shrine,s__ACharacter_getPlayerCharacter(owner)) //AClassCharacterCharacter
			set triggeringTrigger = null
			set triggerUnit = null
			set owner = null
  endfunction

  function s__AShrine_createShrineTrigger takes integer this returns nothing
   local event triggerEvent
   local conditionfunc conditionFunction
   local triggercondition triggerCondition
   local triggeraction triggerAction
			set s__AShrine_shrineTrigger[this]=CreateTrigger()
			set triggerEvent = TriggerRegisterEnterRegion(s__AShrine_shrineTrigger[this] , s__AShrine_discoverRegion[this] , null)
			set conditionFunction = Condition(function s__AShrine_triggerConditionEnable)
			set triggerCondition = TriggerAddCondition(s__AShrine_shrineTrigger[this] , conditionFunction)
			set triggerAction = TriggerAddAction(s__AShrine_shrineTrigger[this] , function s__AShrine_triggerActionEnable)
			call s__AHashTable_storeHandleInteger(AGetCharacterHashTable(),s__AShrine_shrineTrigger[this] , "shrine" , this) //AClassCharacterCharacterHashTable
			set triggerEvent = null
			set conditionFunction = null
			set triggerCondition = null
			set triggerAction = null
  endfunction

  function s__AShrine_create takes destructable usedDestructable,rect discoverRect,rect revivalRect returns integer
   local integer this= s__AShrine__allocate()
			//start members
			set s__AShrine_usedDestructable[this]=usedDestructable
			set s__AShrine_discoverRect[this]=discoverRect
			set s__AShrine_revivalRect[this]=revivalRect

			call s__AShrine_createDiscoverRegion(this)
			call s__AShrine_createShrineTrigger(this)
			return this
  endfunction

  function s__AShrine_destroyDiscoverRegion takes integer this returns nothing
			call RemoveRegion(s__AShrine_discoverRegion[this])
			set s__AShrine_discoverRegion[this]=null
  endfunction

  function s__AShrine_destroyShrineTrigger takes integer this returns nothing
			call s__AHashTable_destroyTrigger(AGetCharacterHashTable(),s__AShrine_shrineTrigger[this]) //AClassCharacterCharacterHashTable
			set s__AShrine_shrineTrigger[this]=null
  endfunction

  function s__AShrine_destroyDiscoverRect takes integer this returns nothing
			call RemoveRect(s__AShrine_discoverRect[this])
			set s__AShrine_discoverRect[this]=null
  endfunction

  function s__AShrine_destroyDiscoverEffect takes integer this returns nothing
			if ( s__AShrine_effectPath != null ) then
				if ( s__AShrine_discoverEffect[this] != null ) then
					call DestroyEffect(s__AShrine_discoverEffect[this])
					set s__AShrine_discoverEffect[this]=null
				endif
			endif
  endfunction

  function s__AShrine_onDestroy takes integer this returns nothing
			//start members
			set s__AShrine_usedDestructable[this]=null

			call s__AShrine_destroyDiscoverRegion(this)
			call s__AShrine_destroyShrineTrigger(this)
			call s__AShrine_destroyDiscoverRect(this)
			call s__AShrine_destroyDiscoverEffect(this)
  endfunction

//Generated destructor of AShrine
function s__AShrine_destroy takes integer this returns nothing
    if this==null then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: AShrine")
        return
    elseif (si__AShrine_V[this]!=-1) then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: AShrine")
        return
    endif
    call s__AShrine_onDestroy(this)
    set si__AShrine_V[this]=si__AShrine_F
    set si__AShrine_F=this
endfunction

		/// @param effectPath If this value is null there is no effect
		/// @param soundPath If this value is null there is no sound.
  function s__AShrine_init takes string effectPath,string soundPath,string textMessage returns nothing
			//static start properties
			set s__AShrine_effectPath=effectPath
			set s__AShrine_soundPath=soundPath
			set s__AShrine_textMessage=textMessage

			if ( soundPath != null ) then
				call PreloadSoundPath(soundPath) //ALibraryEnvironmentSound
			endif
  endfunction


//library AStructSystemsCharacterShrine ends
//library AStructSystemsGuiButton:



//library AStructSystemsGuiButton ends
//library AStructSystemsGuiImage:

		//dynamic members
		//start members
		//members

		//dynamic members

  function s__AImage_setColour takes integer this,integer red,integer green,integer blue,integer alpha returns nothing
			call SetImageColor(s__AImage_usedImage[this] , red , green , blue , alpha)
  endfunction

  function s__AImage_getRed takes integer this returns integer
			return s__AImage_red[this]
  endfunction

  function s__AImage_getGreen takes integer this returns integer
			return s__AImage_green[this]
  endfunction

  function s__AImage_getBlue takes integer this returns integer
			return s__AImage_blue[this]
  endfunction

  function s__AImage_getAlpha takes integer this returns integer
			return s__AImage_alpha[this]
  endfunction

		//start members

  function s__AImage_getFile takes integer this returns string
			return s__AImage_file[this]
  endfunction

		//methods

  function s__AImage_show takes integer this returns nothing
			call s__AWidget_show(this)
			call ShowImage(s__AImage_usedImage[this] , true)
  endfunction

  function s__AImage_hide takes integer this returns nothing
			call s__AWidget_hide(this)
			call ShowImage(s__AImage_usedImage[this] , false)
  endfunction

  function s__AImage_create takes string file,integer mainWindow,real x,real y,real sizeX,real sizeY,integer onHitAction,integer onTrackAction returns integer
   local integer this= s__AImage__allocate(mainWindow , x , y , sizeX , sizeY , onHitAction , onTrackAction)
			//start members
			set s__AImage_file[this]=file
			//members
			set s__AImage_usedImage[this]=CreateImageForPlayer(s__AGui_getUser(sc__AMainWindow_getGui(mainWindow)) , file , x , y , 0.0 , sizeX , sizeY) //ALibraryInterfaceImage

			return this
  endfunction

  function s__AImage_onDestroy takes integer this returns nothing
			call DestroyImage(s__AImage_usedImage[this])
			set s__AImage_usedImage[this]=null
  endfunction


//library AStructSystemsGuiImage ends
//library AStructSystemsGuiMainWindow:

	/// @todo Use @member AMainWindow.maxWidgets instead of 100.
//textmacro instance: A_CONTAINER("AWidget", "Widget", "100")

		/// @state untested
		/// An operation function interface with two elements.
		/// The return value is the result of the operation.
		/// Examples are addition and subtraction etc.
//processed: 		function interface AWidgetContainerOperation takes AWidget element0, AWidget element1 returns AWidget

		/// @state untested
		/// Unary predicate.
		/// A comparision function interface for one element.
//processed: 		function interface AWidgetContainerUnaryPredicate takes AWidget element returns boolean

		/// @state untested
		/// Binary predicate.
		/// A comparisan function interface for two elements.
//processed: 		function interface AWidgetContainerBinaryPredicate takes AWidget element0, AWidget element1 returns boolean

		/// @state works
		/// Unary function.
		/// Allows the call of an user-definied function for each element.
//processed: 		function interface AWidgetContainerUnaryFunction takes AWidget element returns nothing //Rückgabewert wurde vorerst rausgenommen, bis ich weiß, was er bringt

		/// Generator.
		/// Allows filling some elements with the return value.
//processed: 		function interface AWidgetContainerGenerator takes nothing returns AWidget

			//dynamic members
			//Quicksort statics

			//dynamic members

   function s__AWidgetContainer_setElement takes integer this,integer index,integer element returns nothing
     call sc__AWidgetContainer_debugCheckIndex(this,index)
				set s___AWidgetContainer_element[s__AWidgetContainer_element[this]+index]=element
   endfunction

   function s__AWidgetContainer_getElement takes integer this,integer index returns integer
     call sc__AWidgetContainer_debugCheckIndex(this,index)
				return s___AWidgetContainer_element[s__AWidgetContainer_element[this]+index]
   endfunction

			//start members

   function s__AWidgetContainer_getSize takes integer this returns integer
				return s___AWidgetContainer_element_size
   endfunction

			//methods

			/// Checks the start position.
    function s__AWidgetContainer_debugCheckStart takes integer this,integer start returns nothing
     if ( ( start < 0 ) or ( start >= 100 ) ) then
      call Print("Wrong start value of container " + I2S(this) + ": start " + I2S(start) + ".")
     endif
    endfunction

			/// Checks the number.
    function s__AWidgetContainer_debugCheckNumber takes integer this,integer number returns nothing
     if ( ( number > 100 ) or ( number <= 0 ) ) then
      call Print("Wrong number value of container " + I2S(this) + ": number " + I2S(number) + ".")
     endif
    endfunction

			/// Checks both values.
    function s__AWidgetContainer_debugCheckStartAndNumber takes integer this,integer start,integer number returns nothing
     call s__AWidgetContainer_debugCheckStart(this,start)
     call s__AWidgetContainer_debugCheckNumber(this,number)
     if ( start + number > 100 ) then
      call Print("Wrong start or number value of container " + I2S(this) + ": start " + I2S(start) + " number " + I2S(number) + ".")
     endif
    endfunction

			/// Checks over- and underflow of the size.
    function s__AWidgetContainer_debugCheckSize takes integer this,integer size returns nothing
     if ( size > 100 ) then
      call Print("Wrong size of container " + I2S(this) + ": " + I2S(size) + ".")
     endif
    endfunction
	
			/// Checks over- and underflow of the index.
    function s__AWidgetContainer_debugCheckIndex takes integer this,integer index returns nothing
     if ( ( index < 0 ) or ( index >= 100 ) ) then
      call Print("Wrong index of container " + I2S(this) + ": " + I2S(index) + ".")
     endif
    endfunction

			/// Common quick sort algorithm.
   function s__AWidgetContainer_quickSort takes integer this,integer left,integer right,integer binaryPredicate returns nothing
    local integer i
    local integer temp
				if ( right > left ) then
					set s__AWidgetContainer_m[this]=s___AWidgetContainer_element[s__AWidgetContainer_element[this]+right]
					set i = left - 1
					set s__AWidgetContainer_j[this]=right
					loop
						loop
							set i = i + 1
							exitwhen ( not sc___prototype849_evaluate(binaryPredicate,s___AWidgetContainer_element[s__AWidgetContainer_element[this]+i] , s__AWidgetContainer_m[this]) )
						endloop
						
						loop
							set s__AWidgetContainer_j[this]=s__AWidgetContainer_j[this] - 1
							exitwhen ( sc___prototype849_evaluate(binaryPredicate,s___AWidgetContainer_element[s__AWidgetContainer_element[this]+s__AWidgetContainer_j[this]] , s__AWidgetContainer_m[this]) )
						endloop
		
						exitwhen ( i >= s__AWidgetContainer_j[this] )
						set temp = s___AWidgetContainer_element[s__AWidgetContainer_element[this]+i]
						set s___AWidgetContainer_element[s__AWidgetContainer_element[this]+i]=s___AWidgetContainer_element[s__AWidgetContainer_element[this]+s__AWidgetContainer_j[this]]
						set s___AWidgetContainer_element[s__AWidgetContainer_element[this]+s__AWidgetContainer_j[this]]=temp
					endloop
					
					set temp = s___AWidgetContainer_element[s__AWidgetContainer_element[this]+i]
					set s___AWidgetContainer_element[s__AWidgetContainer_element[this]+i]=s___AWidgetContainer_element[s__AWidgetContainer_element[this]+right]
					set s___AWidgetContainer_element[s__AWidgetContainer_element[this]+right]=temp
					
					call s__AWidgetContainer_quickSort(this,left , i - 1 , binaryPredicate)
					call s__AWidgetContainer_quickSort(this,i + 1 , right , binaryPredicate)
				endif
   endfunction

			/// Sorts elements by using the quick sort algorithm in ascending order.
			/// @param start Index of first element.
			/// @param number Number of elements.
			/// @param binaryPredicate Binary comparison function.
   function s__AWidgetContainer_sort takes integer this,integer start,integer number,integer binaryPredicate returns nothing
     call s__AWidgetContainer_debugCheckStartAndNumber(this,start , number)
				call s__AWidgetContainer_quickSort(this,start , start + number - 1 , binaryPredicate)
   endfunction

			/// Reverses elements.
			/// @param start Index of first element.
			/// @param number Number of elements.
			/// @todo I'm not sure if this is best solution.
   function s__AWidgetContainer_reverse takes integer this,integer start,integer number returns nothing
    local integer i= start
    local integer exitValue= start + ( number / 2 )
    local integer temp
    local integer swapindex
     call s__AWidgetContainer_debugCheckStartAndNumber(this,start , number)
				loop
					exitwhen ( i == exitValue )
					set swapindex = ( ( 2 * start ) + number - i - 1 )
					set temp = s___AWidgetContainer_element[s__AWidgetContainer_element[this]+i]
					set s___AWidgetContainer_element[s__AWidgetContainer_element[this]+i]=s___AWidgetContainer_element[s__AWidgetContainer_element[this]+swapindex]
					set s___AWidgetContainer_element[s__AWidgetContainer_element[this]+swapindex]=temp
					set i = i + 1
				endloop
   endfunction

			//C++ algorithm

			/// @state untested
			/// Orientiert sich an accumulate und adjacent_difference.
			/// Man kann allerdings nicht jeden Datentyp addieren oder subtrahieren.
			/// Führt eine Operation mit allen Elementen in einem Bereich durch.
			/// @param start Startposition
			/// @param number Anzahl der Elemente
			/// @param value Der Startwert des Ergebnis
			/// @param operation Operationsfunktion
			/// @return Ergebnis aller Operationen
   function s__AWidgetContainer_operation takes integer this,integer start,integer number,integer value,integer operation returns integer
    local integer i= start
    local integer exitValue= start + number
    local integer result= value
     call s__AWidgetContainer_debugCheckStartAndNumber(this,start , number)
				loop
					exitwhen ( i == exitValue )
					set result = sc___prototype847_evaluate(operation,result , s___AWidgetContainer_element[s__AWidgetContainer_element[this]+i]) //Returns something
					set i = i + 1
				endloop
				return result
   endfunction

			/// @state untested
			/// Sucht nach zwei aneinander liegenden gleichen Elementen.
			/// @param start Startposition
			/// @param number Anzahl der Elemente
			/// @return Index des ersten Treffers oder -1
   function s__AWidgetContainer_adjacentFind takes integer this,integer start,integer number returns integer
    local integer i= start
    local integer exitValue= start + number - 1 //-1 da beim Vergleich + 1 angewendet wird
     call s__AWidgetContainer_debugCheckStartAndNumber(this,start , number)
				loop
					exitwhen ( i == exitValue )
					if ( s___AWidgetContainer_element[s__AWidgetContainer_element[this]+i] == s___AWidgetContainer_element[s__AWidgetContainer_element[this]+i + 1] ) then
						return i
					endif
					set i = i + 1
				endloop
				return - 1
   endfunction

			/// @state untested
			/// Sucht mit Hilfe einer benutzerdefinierten Vergleichsfunktion nach zwei aneinander liegenden gleichen Elementen.
			/// @param start Startposition
			/// @param number Anzahl der Elemente
			/// @param binaryPredicate Vergleichsfunktion
			/// @return Index des ersten Treffers oder -1
   function s__AWidgetContainer_adjacentFindIf takes integer this,integer start,integer number,integer binaryPredicate returns integer
    local integer i= start
    local integer exitValue= start + number - 1 //-1 da beim Vergleich + 1 angewendet wird
     call s__AWidgetContainer_debugCheckStartAndNumber(this,start , number)
				loop
					exitwhen ( i == exitValue )
					if ( sc___prototype849_evaluate(binaryPredicate,s___AWidgetContainer_element[s__AWidgetContainer_element[this]+i] , s___AWidgetContainer_element[s__AWidgetContainer_element[this]+i + 1]) ) then
						return i
					endif
					set i = i + 1
				endloop
				return - 1
   endfunction

			/// @state untested
			/// Die binäre Suche funktioniert nur wenn die Elemente in Reihenfolge sortiert sind.
			/// @todo Noch implementieren.
			/// @todo bool binary_search( iterator start, iterator end, const TYPE& val );
			/// @todo bool binary_search( iterator start, iterator end, const TYPE& val, Comp f );
   function s__AWidgetContainer_binarySearch takes integer this returns nothing
   endfunction

			/// @state untested
			/// Kopiert einen Elementebereich des Containers in einen Ziel-Container.
			/// @param start0 Index of first element.
			/// @param number0 Number of elements.
			/// @param start1 Index of first element in container @param desitination.
			/// @param destination Container where elements are copied to.
   function s__AWidgetContainer_copy takes integer this,integer start0,integer number0,integer start1,integer destination returns nothing
    local integer i= start0
    local integer j= start1
    local integer exitValue= start0 + number0
     call s__AWidgetContainer_debugCheckStartAndNumber(this,start0 , number0)
     call s__AWidgetContainer_debugCheckStart(destination,start1)
				loop
					exitwhen ( i == exitValue )
					set s___AWidgetContainer_element[s__AWidgetContainer_element[destination]+j]=s___AWidgetContainer_element[s__AWidgetContainer_element[this]+i]
					set i = i + 1
					set j = j + 1
				endloop
   endfunction

			/// @state untested
			/// Kopiert einen Elementebereich des Containers in einen Ziel-Container.
			/// Im Gegensatz zur copy-Methode fängt diese Methode beim letzten zu kopierenden Wert an.
			/// @param start0 Startposition
			/// @param number0 Anzahl der Elemente
			/// @param start1 Startposition im Ziel-Container
			/// @param destination Ziel-Container
   function s__AWidgetContainer_copyBackward takes integer this,integer start0,integer number0,integer start1,integer destination returns nothing
    local integer i= start0 + number0 - 1
    local integer j= start1 + number0 - 1
    local integer exitValue= start0 - 1
     call s__AWidgetContainer_debugCheckStartAndNumber(this,start0 , number0)
     call s__AWidgetContainer_debugCheckStart(destination,start1)
				loop
					exitwhen ( i == exitValue )
					set s___AWidgetContainer_element[s__AWidgetContainer_element[destination]+j]=s___AWidgetContainer_element[s__AWidgetContainer_element[this]+i]
					set i = i - 1
					set j = j - 1
				endloop
   endfunction

			/// Diese Methode tut das, was die Methoden dieses Containers von C++-Containern unterscheidet.
			/// Sie verwendet als zweiten Parameter die Anzahl der Elemente und keinen Ziel-Iterator.
			/// Sie ist daher überflüssig.
			/// iterator copy_n( iterator from, size_t num, iterator to );
   function s__AWidgetContainer_copyN takes integer this returns nothing
   endfunction

			/// @state untested
			/// Vergleicht einen Elementebereich mit einem Wert.
			/// @param start Startposition
			/// @param number Anzahl der Elemente
			/// @param value Vergleichswert
			/// @return Anzahl der Treffer
   function s__AWidgetContainer_count takes integer this,integer start,integer number,integer value returns integer
    local integer i= start
    local integer exitValue= start + number
    local integer result= 0
     call s__AWidgetContainer_debugCheckStartAndNumber(this,start , number)
				loop
					exitwhen ( i == exitValue )
					if ( s___AWidgetContainer_element[s__AWidgetContainer_element[this]+i] == value ) then
						set result = result + 1
					endif
					set i = i + 1
				endloop
				return result
   endfunction

			/// @state untested
			/// Vergleicht einen Elementebereich mit Hilfe einer benutzerdefinierten Funktion.
			/// @param start Startposition
			/// @param number Anzahl der Elemente
			/// @param unaryPredicate Vergleichsfunktion
			/// @return Anzahl der Treffer
   function s__AWidgetContainer_countIf takes integer this,integer start,integer number,integer unaryPredicate returns integer
    local integer i= start
    local integer exitValue= start + number
    local integer result= 0
     call s__AWidgetContainer_debugCheckStartAndNumber(this,start , number)
				loop
					exitwhen ( i == exitValue )
					if ( sc___prototype848_evaluate(unaryPredicate,s___AWidgetContainer_element[s__AWidgetContainer_element[this]+i]) ) then
						set result = result + 1
					endif
					set i = i + 1
				endloop
				return result
   endfunction

			/// @state untested
			/// Prüft ob ein Elementebereich einem anderen entspricht.
			/// Verwendet dabei den Standard ==-Operator, der normalerweise bei allen Datentypen anwendbar ist.
			/// @param start1 Startposition
			/// @param number1 Anzahl der Elemente
			/// @param start2 Startposition im Vergleichs-Container
			/// @param destination Vergleichs-Container
			/// @return Übereinstimmung aller Elemente
   function s__AWidgetContainer_equal takes integer this,integer start1,integer number1,integer start2,integer destination returns boolean
    local integer i= start1
    local integer j= start2
    local integer exitValue= start1 + number1
     call s__AWidgetContainer_debugCheckStartAndNumber(this,start1 , number1)
     call s__AWidgetContainer_debugCheckStart(destination,start2)
				loop
					exitwhen ( i == exitValue )
						if ( not ( s___AWidgetContainer_element[s__AWidgetContainer_element[this]+i] == s___AWidgetContainer_element[s__AWidgetContainer_element[destination]+j] ) ) then
							return false
						endif
					set i = i + 1
					set j = j + 1
				endloop
				return true
   endfunction

			/// @state untested
			/// Prüft mit Hilfe einer benutzerdefinierten Vergleichsfunktion ob ein Elementebereich einem anderen entspricht.
			/// @param start0 Startposition
			/// @param number0 Anzahl der Elemente
			/// @param start1 Startposition im Vergleichs-Container
			/// @param destination Vergleichs-Container
			/// @param binaryPredicate Vergleichsfunktion
			/// @return Übereinstimmung aller Elemente
   function s__AWidgetContainer_equalIf takes integer this,integer start0,integer number0,integer start1,integer destination,integer binaryPredicate returns boolean
    local integer i= start0
    local integer j= start1
    local integer exitValue= start0 + number0
     call s__AWidgetContainer_debugCheckStartAndNumber(this,start0 , number0)
     call s__AWidgetContainer_debugCheckStart(destination,start1)
				loop
					exitwhen ( i == exitValue )
						if ( not sc___prototype849_evaluate(binaryPredicate,s___AWidgetContainer_element[s__AWidgetContainer_element[this]+i] , s___AWidgetContainer_element[s__AWidgetContainer_element[destination]+j]) ) then
							return false
						endif
					set i = i + 1
					set j = j + 1
				endloop
				return true
   endfunction

			/// @state untested
			/// Füllt einen Elementebereich mit einem Wert.
			/// @param start Startposition
			/// @param number Anzahl der Elemente
			/// @param value Zu füllender Wert
   function s__AWidgetContainer_fill takes integer this,integer start,integer number,integer value returns nothing
    local integer i= start
    local integer exitValue= start + number
     call s__AWidgetContainer_debugCheckStartAndNumber(this,start , number)
				loop
					exitwhen ( i == exitValue )
						set s___AWidgetContainer_element[s__AWidgetContainer_element[this]+i]=value
					set i = i + 1
				endloop
   endfunction

			/// Diese Methode tut das, was die Methoden dieses Containers von C++-Containern unterscheidet.
			/// Sie verwendet als zweiten Parameter die Anzahl der Elemente und keinen Ziel-Iterator.
			/// Sie ist daher überflüssig.
			/// iterator fill_n( iterator start, size_t n, const TYPE& val );
   function s__AWidgetContainer_fillN takes integer this returns nothing
   endfunction

			/// @state untested
			/// Sucht im Container nach einem Element mit einem bestimmten Wert.
			/// @param start Index of first element which is checked for the searched value.
			/// @param number Number of elements which are checked for the searched value.
			/// @param value Searched value.
			/// @return Returns the index of the first hit. If there was no hit it returns -1.
   function s__AWidgetContainer_find takes integer this,integer start,integer number,integer value returns integer
    local integer i= start
    local integer exitValue= start + number
     call s__AWidgetContainer_debugCheckStartAndNumber(this,start , number)
				loop
					exitwhen ( i == exitValue )
					if ( s___AWidgetContainer_element[s__AWidgetContainer_element[this]+i] == value ) then
						return i
					endif
					set i = i + 1
				endloop
				return - 1
   endfunction

			/// @todo iterator find_end( iterator start, iterator end, iterator seq_start, iterator seq_end );
			/// @todo iterator find_end( iterator start, iterator end, iterator seq_start, iterator seq_end, BinPred bp );
   function s__AWidgetContainer_findEnd takes integer this returns nothing
   endfunction

			/// @todo iterator find_first_of( iterator start, iterator end, iterator find_start, iterator find_end );
			/// @todo iterator find_first_of( iterator start, iterator end, iterator find_start, iterator find_end, BinPred bp );
   function s__AWidgetContainer_findFirstOf takes integer this returns nothing
   endfunction

			/// @state untested
			/// Sucht mit Hilfe einer benutzerdefinierten Funktion ein Element im Container.
			/// @param start Startposition
			/// @param number Anzahl der Elemente
			/// @param unaryPredicate Vergleichsfunktion
			/// @return Index des ersten Treffers oder -1
   function s__AWidgetContainer_findIf takes integer this,integer start,integer number,integer unaryPredicate returns integer
    local integer i= start
    local integer exitValue= start + number
     call s__AWidgetContainer_debugCheckStartAndNumber(this,start , number)
				loop
					exitwhen ( i == exitValue )
						if ( sc___prototype848_evaluate(unaryPredicate,s___AWidgetContainer_element[s__AWidgetContainer_element[this]+i]) ) then
							return i
						endif
					set i = i + 1
				endloop
				return - 1
   endfunction

			/// @state untested
			/// Führt eine benutzerdefinierte Funktion für einen Elementebereich aus.
			/// @param start Startposition
			/// @param number Anzahl der Elemente
			/// @param unaryFunction Benutzerdefinierte Funktion
   function s__AWidgetContainer_forEach takes integer this,integer start,integer number,integer unaryFunction returns nothing
    local integer i= start
    local integer exitValue= start + number
     call s__AWidgetContainer_debugCheckStartAndNumber(this,start , number)
				loop
					exitwhen ( i == exitValue )
						call sc___prototype846_execute(unaryFunction,s___AWidgetContainer_element[s__AWidgetContainer_element[this]+i])
					set i = i + 1
				endloop
   endfunction

			/// void generate( iterator start, iterator end, Generator g );
			/// @state untested
			/// Füllt einen Elementebereich mit dem Rückgabewert einer benutzerdefinierten Funktion.
			/// Funktion wurde so in Quell-Code des GCCs nachgeschlagen.
			/// @param start Startposition
			/// @param number Anzahl der Elemente
			/// @param generator Benutzerdefinierte Funktion
   function s__AWidgetContainer_generate takes integer this,integer start,integer number,integer generator returns nothing
    local integer i= start
    local integer exitValue= start + number
     call s__AWidgetContainer_debugCheckStartAndNumber(this,start , number)
				loop
					exitwhen ( i == exitValue )
						set s___AWidgetContainer_element[s__AWidgetContainer_element[this]+i]=sc___prototype850_evaluate(generator)
					set i = i + 1
				endloop
   endfunction

			/// Diese Methode tut das, was die Methoden dieses Containers von C++-Containern unterscheidet.
			/// Sie verwendet als zweiten Parameter die Anzahl der Elemente und keinen Ziel-Iterator.
			/// Sie ist daher überflüssig.
			/// iterator generate_n( iterator result, size_t num, Generator g );
   function s__AWidgetContainer_generate_n takes integer this returns nothing
   endfunction

			/// @todo bool includes( iterator start1, iterator end1, iterator start2, iterator end2 );
			/// @todo bool includes( iterator start1, iterator end1, iterator start2, iterator end2, StrictWeakOrdering cmp );
			/// @todo The includes() algorithm returns true if every element in [start2,end2) is also in [start1,end1). Both of the given ranges must be sorted in ascending order.
			/// @todo By default, the < operator is used to compare elements. If the strict weak ordering function object cmp is given, then it is used instead.
   function s__AWidgetContainer_includes takes integer this returns nothing
   endfunction

			/// @todo TYPE inner_product( iterator start1, iterator end1, iterator start2, TYPE val );
			/// @todo TYPE inner_product( iterator start1, iterator end1, iterator start2, TYPE val, BinaryFunction f1, BinaryFunction f2 );
			/// @todo The inner_product() function computes the inner product of [start1,end1) and a range of the same size starting at start2.
   function s__AWidgetContainer_inner_product takes integer this returns nothing
   endfunction

			/// @todo inline void inplace_merge( iterator start, iterator middle, iterator end );
			/// @todo inline void inplace_merge( iterator start, iterator middle, iterator end, StrictWeakOrdering cmp );
			/// @todo The inplace_merge() function is similar to the merge() function, but instead of creating a new sorted range of elements, inplace_merge() alters the existing ranges to perform the merge in-place.
   function s__AWidgetContainer_inplace_merge takes integer this returns nothing
   endfunction

			/// @state untested
			/// iterator max_element( iterator start, iterator end );
			/// iterator max_element( iterator start, iterator end, BinPred p );
			/// Sucht mit Hilfe einer benutzerdefinierten Vergleichsfunktion nach dem größten Element in einem Elementebereich.
			/// Das Prädikat stellt in diesem Fall den <-Operator dar.
			/// @param start Startposition
			/// @param number Anzahl der Elemente
			/// @param binaryPredicate Benutzerdefinierte Vergleichsfunktion
			/// @return Index des größten Elements
   function s__AWidgetContainer_max_element takes integer this,integer start,integer number,integer binaryPredicate returns integer
    local integer i= start + 1
    local integer exitValue= start + number
    local integer result= start
     call s__AWidgetContainer_debugCheckStartAndNumber(this,start , number)
				loop
					exitwhen ( i == exitValue )
						//x < y
						if ( sc___prototype849_evaluate(binaryPredicate,s___AWidgetContainer_element[s__AWidgetContainer_element[this]+result] , s___AWidgetContainer_element[s__AWidgetContainer_element[this]+i]) ) then
							set result = i
						endif
					set i = i + 1
				endloop
				return result
   endfunction

			//iterator min_element( iterator start, iterator end );
			//iterator min_element( iterator start, iterator end, BinPred p );
			/// Sucht mit Hilfe einer benutzerdefinierten Vergleichsfunktion nach dem kleinsten Element in einem Elementebereich.
			/// Das Prädikat stellt in diesem Fall den <-Operator dar.
			/// @param start Startposition
			/// @param number Anzahl der Elemente
			/// @param binaryPredicate Benutzerdefinierte Vergleichsfunktion
			/// @return Index des kleinsten Elements
   function s__AWidgetContainer_min_element takes integer this,integer start,integer number,integer binaryPredicate returns integer
    local integer i= start + 1
    local integer exitValue= start + number
    local integer result= start
     call s__AWidgetContainer_debugCheckStartAndNumber(this,start , number)
				loop
					exitwhen ( i == exitValue )
						//x < y
						if ( sc___prototype849_evaluate(binaryPredicate,s___AWidgetContainer_element[s__AWidgetContainer_element[this]+i] , s___AWidgetContainer_element[s__AWidgetContainer_element[this]+result]) ) then
							set result = i
						endif
					set i = i + 1
				endloop
				return result
   endfunction

			/// Mit dem []-Operator kann man auf ein Element des Containers zugreifen.
			/// @param index Index des Elements
			/// @return Das Element
   function s__AWidgetContainer__getindex takes integer this,integer index returns integer
				return s__AWidgetContainer_getElement(this,index)
   endfunction

			/// Mit dem []=-Operator kann man einem Element des Containers einen Wert zuweisen.
			/// @param index Index des Elements
			/// @param value Zuzuweisender Wert
   function s__AWidgetContainer__setindex takes integer this,integer index,integer value returns nothing
				call s__AWidgetContainer_setElement(this,index , value)
   endfunction

			/// Mit dem <-Operator kann man prüfen, ob der Container eine kleinere Größe als ein anderer hat.
			/// @param destination Vergleichs-Container
			/// @return Gibt wahr zurück, wenn der Container eine kleinere Größe als der Ziel-Container hat.
   function s__AWidgetContainer__lessthan takes integer this,integer destination returns boolean
				return s___AWidgetContainer_element_size < s___AWidgetContainer_element_size
   endfunction

			// Mit dem >-Operator kann man prüfen, ob der Container eine größere Größe als ein anderer hat.
			// @param destination Vergleichs-Container
			// @return Gibt wahr zurück, wenn der Container eine kleinere Größe als der Ziel-Container hat.
			//public method operator> takes AWidgetContainer destination returns boolean
				//return this.size > destionation.size
			//endmethod

		//Basic algorithm

		//The binary predicate represents the < operator.
		//function AMax takes AWidget x, AWidget y, AWidgetContainerBinaryPredicate binaryPredicate returns $ELEMENTTYPE
		//	if (binaryPredicate.evaluate(x, y)) then
		//		return y
		//	endif
		//	return x
		//endfunction

		//function AMin takes AWidget x, AWidget y, AWidgetContainerBinaryPredicate binaryPredicate returns $ELEMENTTYPE
		//	if (binaryPredicate.evaluate(x, y)) then
		//		return x
		//	endif
		//	return y
		//endfunction
//end of: A_CONTAINER("AWidget", "Widget", "100")

	/// @todo Should be a static method of @struct AMainWindow, vJass bug.
 function AStructSystemsGuiMainWindow__unaryFunctionShowWidget takes integer element returns nothing
		call sc__AWidget_show(element)
	endfunction

	/// @todo Should be a static method of @struct AMainWindow, vJass bug.
 function AStructSystemsGuiMainWindow__unaryFunctionHideWidget takes integer element returns nothing
		call sc__AWidget_hide(element)
	endfunction

	/// @todo Should be a static method of @struct AMainWindow, vJass bug.
 function AStructSystemsGuiMainWindow__unaryFunctionDestroyWidget takes integer element returns nothing
		//saver
		if ( element != 0 ) then
			call sc__AWidget_destroy(element)
		endif
	endfunction

		//static constant members
		//static start members
		//start members
		//members

//textmacro instance: A_STRUCT_DEBUG("\"AMainWindow\"")
   function s__AMainWindow_print takes integer this,string message returns nothing
    call Print("AMainWindow" + " - " + I2S(this) + ": " + message)
   endfunction

   function s__AMainWindow_staticPrint takes string message returns nothing
    call Print("AMainWindow" + ": " + message)
   endfunction
//end of: A_STRUCT_DEBUG("\"AMainWindow\"")

		//start members

  function s__AMainWindow_getGui takes integer this returns integer
			return s__AMainWindow_gui[this]
  endfunction

  function s__AMainWindow_getX takes integer this,real x returns real
			return ( s__AMainWindow_x[this] + x )
  endfunction

  function s__AMainWindow_getY takes integer this,real y returns real
			return ( s__AMainWindow_y[this] + y )
  endfunction

  function s__AMainWindow_getSizeX takes integer this returns real
			return s__AMainWindow_sizeX[this]
  endfunction

  function s__AMainWindow_getSizeY takes integer this returns real
			return s__AMainWindow_sizeY[this]
  endfunction

		//members

  function s__AMainWindow_getIsShown takes integer this returns boolean
			return s__AMainWindow_isShown[this]
  endfunction
		
		//convenience methods
		
  function s__AMainWindow_getUser takes integer this returns player
			return s__AGui_getUser(s__AMainWindow_gui[this])
  endfunction

		//methods

  function s__AMainWindow_showTooltip takes integer this,integer usedWidget returns nothing
			if ( s__AMainWindow_tooltip[this] == null ) then
				set s__AMainWindow_tooltip[this]=CreateTextTag()
			endif
			call SetTextTagTextBJ(s__AMainWindow_tooltip[this] , s__AWidget_getTooltip(usedWidget) , s__AWidget_getTooltipSize(usedWidget))
			call SetTextTagPos(s__AMainWindow_tooltip[this] , s__AWidget_getX(usedWidget) , s__AWidget_getY(usedWidget) , 0.0)
			call ShowTextTagForPlayer(s__AGui_getUser(s__AMainWindow_gui[this]) , s__AMainWindow_tooltip[this] , true) //ALibraryInterfaceTextTag
			if ( s__AMainWindow_tooltipSoundPath != null ) then
				call PlaySoundPathForPlayer(s__AGui_getUser(s__AMainWindow_gui[this]) , s__AMainWindow_tooltipSoundPath) //ALibraryEnvironmentSound
			endif
  endfunction

  function s__AMainWindow_hideTooltip takes integer this returns nothing
			call ShowTextTagForPlayer(s__AGui_getUser(s__AMainWindow_gui[this]) , s__AMainWindow_tooltip[this] , false) //ALibraryInterfaceTextTag
  endfunction

  function s__AMainWindow_dockWidget takes integer this,integer usedWidget returns integer
   local integer i= 0
			loop
				exitwhen ( i == s__AMainWindow_maxWidgets )
				if ( s__AWidgetContainer__getindex(s__AMainWindow_container[this],i) == 0 ) then
					call s__AWidgetContainer__setindex(s__AMainWindow_container[this],i, usedWidget)
					return i
				endif
				set i = i + 1
			endloop
    call s__AMainWindow_print(this,"Could not dock widget. Maximum reached.")
			return - 1
  endfunction

  function s__AMainWindow_undockWidget takes integer this,integer usedWidget returns nothing
   local integer i= 0
			loop
				exitwhen ( i == s__AMainWindow_maxWidgets )
				if ( s__AWidgetContainer__getindex(s__AMainWindow_container[this],i) == usedWidget ) then
					call s__AWidgetContainer__setindex(s__AMainWindow_container[this],i, 0)
					return 
				endif
				set i = i + 1
			endloop
    call s__AMainWindow_print(this,"Could not undock widget. Widget was not found.")
  endfunction

  function s__AMainWindow_show takes integer this returns nothing
   local real x= s__AMainWindow_x[this] + ( s__AMainWindow_sizeX[this] / 2.0 )
   local real y= s__AMainWindow_y[this] + ( s__AMainWindow_sizeY[this] / 2.0 )
			call s__AGui_savePlayerData(s__AMainWindow_gui[this])
			call ClearScreenMessagesForPlayer(s__AGui_getUser(s__AMainWindow_gui[this])) //ALibraryInterfaceCinematic
			call PanCameraToForPlayer(s__AGui_getUser(s__AMainWindow_gui[this]) , x , y)
			call SetCameraBoundsToPointForPlayer(s__AGui_getUser(s__AMainWindow_gui[this]) , x , y) //ALibraryInterfaceCamera
			call CameraSetupApplyForPlayer(true , s__AMainWindow_cameraSetup , s__AGui_getUser(s__AMainWindow_gui[this]) , 0.0)
			//widgets
			call s__AWidgetContainer_forEach(s__AMainWindow_container[this],0 , s__AMainWindow_maxWidgets , (1))

			if ( s__AMainWindow_useShortcuts[this] ) then
				call s__AGui_enableShortcuts(s__AMainWindow_gui[this])
			endif
			set s__AMainWindow_isShown[this]=true
			call s__AGui_hideShownMainWindowAndSetNew(s__AMainWindow_gui[this],this)
  endfunction

  function s__AMainWindow_hide takes integer this returns nothing
			call ResetCameraBoundsToMapRectForPlayer(s__AGui_getUser(s__AMainWindow_gui[this])) //ALibraryInterfaceCamera
			call ResetToGameCameraForPlayer(s__AGui_getUser(s__AMainWindow_gui[this]) , 0.0)
			call s__AGui_loadPlayerData(s__AMainWindow_gui[this])
			call s__AMainWindow_hideTooltip(this)
			//widgets
			call s__AWidgetContainer_forEach(s__AMainWindow_container[this],0 , s__AMainWindow_maxWidgets , (2))

			if ( s__AMainWindow_useShortcuts[this] ) then
				call s__AGui_disableShortcuts(s__AMainWindow_gui[this])
			endif
			set s__AMainWindow_isShown[this]=false
  endfunction
		
  function s__AMainWindow_triggerActionPressShortcut takes nothing returns nothing
   local trigger triggeringTrigger= GetTriggeringTrigger()
   local integer mainWindow= s__AHashTable_getHandleInteger(AGetInterfaceHashTable(),triggeringTrigger , "mainWindow") //AClassInterfaceInterfaceHashTable
			if ( not s__AMainWindow_isShown[mainWindow] ) then
				call s__AMainWindow_show(mainWindow)
			else
				call s__AMainWindow_hide(mainWindow)
			endif
			set triggeringTrigger = null
  endfunction
		
  function s__AMainWindow_createShortcutTrigger takes integer this returns nothing
   local event triggerEvent
   local triggeraction triggerAction
			set s__AMainWindow_shortcutTrigger[this]=CreateTrigger()
			set triggerEvent = TriggerRegisterKeyEventForPlayer(s__AGui_getUser(s__AMainWindow_gui[this]) , s__AMainWindow_shortcutTrigger[this] , s__AMainWindow_shortcut[this] , true) //ALibraryInterfaceMisc
			set triggerAction = TriggerAddAction(s__AMainWindow_shortcutTrigger[this] , function s__AMainWindow_triggerActionPressShortcut)
			call s__AHashTable_storeHandleInteger(AGetInterfaceHashTable(),s__AMainWindow_shortcutTrigger[this] , "mainWindow" , this) //AClassInterfaceInterfaceHashTable
			set triggerEvent = null
			set triggerAction = null
  endfunction

		/// @param shortcut If this value is 0 main window won't have any shortcut.
  function s__AMainWindow_create takes integer gui,real x,real y,real sizeX,real sizeY,boolean useShortcuts,integer shortcut returns integer
   local integer this= s__AMainWindow__allocate()
			//start members
			set s__AMainWindow_gui[this]=gui
			set s__AMainWindow_x[this]=x //insert a debug if the coordinates are out of map range
			set s__AMainWindow_y[this]=y
			set s__AMainWindow_sizeX[this]=sizeX
			set s__AMainWindow_sizeY[this]=sizeY
			set s__AMainWindow_useShortcuts[this]=useShortcuts
			set s__AMainWindow_shortcut[this]=shortcut
			//members
			set s__AMainWindow_container[this]=s__AWidgetContainer__allocate()
			set s__AMainWindow_isShown[this]=false

			if ( gui != 0 ) then
				call s__AGui_dockMainWindow(gui,this)
			endif

			if ( shortcut != 0 ) then
				call s__AMainWindow_createShortcutTrigger(this)
			endif
			return this
  endfunction

  function s__AMainWindow_destroyDockedWidgets takes integer this returns nothing
			call s__AWidgetContainer_forEach(s__AMainWindow_container[this],0 , s__AMainWindow_maxWidgets , (3))
  endfunction

  function s__AMainWindow_onDestroy takes integer this returns nothing
			//members
			call DestroyTextTag(s__AMainWindow_tooltip[this])
			set s__AMainWindow_tooltip[this]=null
			if ( s__AMainWindow_shortcut[this] != 0 ) then
				call s__AHashTable_destroyTrigger(AGetInterfaceHashTable(),s__AMainWindow_shortcutTrigger[this]) //AClassInterfaceInterfaceHashTable
				set s__AMainWindow_shortcutTrigger[this]=null
			endif

			call s__AMainWindow_destroyDockedWidgets(this)
			call s__AWidgetContainer_destroy(s__AMainWindow_container[this])

			if ( s__AMainWindow_gui[this] != 0 ) then
				call s__AGui_undockMainWindow(s__AMainWindow_gui[this],this)
			endif
  endfunction

//Generated destructor of AMainWindow
function s__AMainWindow_destroy takes integer this returns nothing
    if this==null then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: AMainWindow")
        return
    elseif (si__AMainWindow_V[this]!=-1) then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: AMainWindow")
        return
    endif
    call s__AMainWindow_onDestroy(this)
    set si__AMainWindow_V[this]=si__AMainWindow_F
    set si__AMainWindow_F=this
endfunction

		/// @param cameraSetup The camera setup which is used as the players view on the main window.
		/// @param tooltipSoundPath The path of the sound which is played when player drags the cursor over the related object. If this value is null there won't be played any sound.
  function s__AMainWindow_init takes camerasetup cameraSetup,string tooltipSoundPath returns nothing
			set s__AMainWindow_cameraSetup=cameraSetup
			set s__AMainWindow_tooltipSoundPath=tooltipSoundPath

			if ( tooltipSoundPath != null ) then
				call PreloadSoundPath(tooltipSoundPath) //ALibraryEnvironmentSound
			endif
  endfunction


//library AStructSystemsGuiMainWindow ends
//library AStructSystemsGuiText:

		//dynamic members
		//private boolean permanent //Textes are always permanent
		//private real lifespan //Textes are always permanent
		//private real age
		//Don't change permanent
		//members

		//dynamic members

		//Do not change x and y
		//These values are always static!
  function s__AText_setHeightOffset takes integer this,real heightOffset returns nothing
			set s__AText_heightOffset[this]=heightOffset
			call SetTextTagPos(s__AText_textTag[this] , s__AWidget_getX(this) , s__AWidget_getY(this) , heightOffset)
  endfunction

		//We don't need SetTextTagPosUnit.
		//It's a GUI...

  function s__AText_setTextAndSize takes integer this,string text,real size returns nothing
			set s__AText_text[this]=text
			set s__AText_size[this]=size
			call SetTextTagTextBJ(s__AText_textTag[this] , text , size)
  endfunction

  function s__AText_setColour takes integer this,integer red,integer green,integer blue,integer alpha returns nothing
			set s__AText_red[this]=red
			set s__AText_green[this]=green
			set s__AText_blue[this]=blue
			set s__AText_alpha[this]=alpha
			call SetTextTagColor(s__AText_textTag[this] , red , green , blue , alpha)
  endfunction

  function s__AText_setSpeedAndAngle takes integer this,real speed,real angle returns nothing
			set s__AText_speed[this]=speed
			set s__AText_angle[this]=angle
			call SetTextTagVelocityBJ(s__AText_textTag[this] , speed , angle)
  endfunction

  function s__AText_setFadepoint takes integer this,real fadepoint returns nothing
			set s__AText_fadepoint[this]=fadepoint
			call SetTextTagFadepoint(s__AText_textTag[this] , fadepoint)
  endfunction

		//Unterbricht die Bewegung.
  function s__AText_setSuspended takes integer this,boolean suspended returns nothing
			set s__AText_suspended[this]=suspended
			call SetTextTagSuspended(s__AText_textTag[this] , suspended)
  endfunction

		//I wanted to implement slow methods which just change one element.
		//But using these methods isn't very useful.

  function s__AText_getHeightOffset takes integer this returns real
			return s__AText_heightOffset[this]
  endfunction

  function s__AText_getText takes integer this returns string
			return s__AText_text[this]
  endfunction

  function s__AText_getSize takes integer this returns real
			return s__AText_size[this]
  endfunction

  function s__AText_getRed takes integer this returns integer
			return s__AText_red[this]
  endfunction

  function s__AText_getGreen takes integer this returns integer
			return s__AText_green[this]
  endfunction

  function s__AText_getBlue takes integer this returns integer
			return s__AText_blue[this]
  endfunction

  function s__AText_getAlpha takes integer this returns integer
			return s__AText_alpha[this]
  endfunction

  function s__AText_getSpeed takes integer this returns real
			return s__AText_speed[this]
  endfunction

  function s__AText_getAngle takes integer this returns real
			return s__AText_angle[this]
  endfunction

  function s__AText_getFadepoint takes integer this returns real
			return s__AText_fadepoint[this]
  endfunction

  function s__AText_getSuspended takes integer this returns boolean
			return s__AText_suspended[this]
  endfunction

		//methods

  function s__AText_show takes integer this returns nothing
			call s__AWidget_show(this)
			call ShowTextTagForPlayer(s__AGui_getUser(s__AMainWindow_getGui(s__AWidget_getMainWindow(this))) , s__AText_textTag[this] , true) //ALibraryInterfaceTextTag
  endfunction

  function s__AText_hide takes integer this returns nothing
			call s__AWidget_hide(this)
			call ShowTextTagForPlayer(s__AGui_getUser(s__AMainWindow_getGui(s__AWidget_getMainWindow(this))) , s__AText_textTag[this] , false) //ALibraryInterfaceTextTag
  endfunction

  function s__AText_create takes integer mainWindow,real x,real y,real sizeX,real sizeY,integer onHitAction,integer onTrackAction returns integer
   local integer this= s__AText__allocate(mainWindow , x , y , sizeX , sizeY , onHitAction , onTrackAction)
			//members
			set s__AText_textTag[this]=CreateTextTag()
			call SetTextTagPos(s__AText_textTag[this] , x , y , s__AText_heightOffset[this]) //Elements x and y were set in the allocate method.

			return this
  endfunction

  function s__AText_onDestroy takes integer this returns nothing
			//members
			call DestroyTextTag(s__AText_textTag[this])
			set s__AText_textTag[this]=null
  endfunction


//library AStructSystemsGuiText ends
//library ACoreDebug:

//library ACoreDebug ends
//library ALibrarySystemsDebugUtilities:

	/// @todo Should have a debug preprocessor, vJass bug

 function ALibrarySystemsDebugUtilities___clear takes nothing returns nothing
   local player triggerPlayer= GetTriggerPlayer()
   call ClearScreenMessagesForPlayer(triggerPlayer)
   set triggerPlayer = null
	endfunction

	/// @todo Add some information.
 function ALibrarySystemsDebugUtilities___info takes nothing returns nothing
   local player triggerPlayer= GetTriggerPlayer()
   local unit selectedUnit= GetFirstSelectedUnitOfPlayer(triggerPlayer) //ALibraryInterfaceSelection
   if ( selectedUnit != null ) then
    call Print("Name: " + GetUnitName(selectedUnit))
    call Print("Position: (" + R2S(GetUnitX(selectedUnit)) + " | " + R2S(GetUnitY(selectedUnit)))
    call Print("Level: " + I2S(GetUnitLevel(selectedUnit)))
    if ( IsUnitType(selectedUnit , UNIT_TYPE_HERO) ) then
     call Print("Hero Level: " + I2S(GetHeroLevel(selectedUnit)))
    endif
    call Print("Acquire Range: " + R2S(GetUnitAcquireRange(selectedUnit)))
    call Print("Current Order: " + I2S(GetUnitCurrentOrder(selectedUnit)))
    set selectedUnit = null
   endif
   set triggerPlayer = null
	endfunction

 function ALibrarySystemsDebugUtilities___level takes string message returns nothing
   local player triggerPlayer= GetTriggerPlayer()
   local unit hero= GetFirstSelectedUnitOfPlayer(triggerPlayer) //ALibraryInterfaceSelection
   if ( hero != null ) then
    if ( IsUnitType(hero , UNIT_TYPE_HERO) ) then
     call SetHeroLevelBJ(hero , S2I(SubString(message , StringLength(ALibrarySystemsDebugUtilities___levelCheat) + 1 , StringLength(message))) , true)
    else
     call Print("Unit is not a hero.")
    endif
    set hero = null
   endif
   set triggerPlayer = null
	endfunction

	/// @todo If no unit is selected, kill an item or a destructable
 function ALibrarySystemsDebugUtilities___kill takes nothing returns nothing
   local player triggerPlayer= GetTriggerPlayer()
   local unit selectedUnit= GetFirstSelectedUnitOfPlayer(triggerPlayer) //ALibraryInterfaceSelection
   if ( selectedUnit != null ) then
    call KillUnit(selectedUnit)
    set selectedUnit = null
   endif
   set triggerPlayer = null
	endfunction

 function ALibrarySystemsDebugUtilities___triggerActionCheat takes nothing returns nothing
   local string message= GetEventPlayerChatString()
   if ( message == ALibrarySystemsDebugUtilities___clearCheat ) then
    call ALibrarySystemsDebugUtilities___clear()
   elseif ( message == ALibrarySystemsDebugUtilities___infoCheat ) then
    call ALibrarySystemsDebugUtilities___info()
   elseif ( SubString(message , 0 , StringLength(ALibrarySystemsDebugUtilities___levelCheat)) == ALibrarySystemsDebugUtilities___levelCheat ) then
    call ALibrarySystemsDebugUtilities___level(message)
   elseif ( message == ALibrarySystemsDebugUtilities___killCheat ) then
    call ALibrarySystemsDebugUtilities___kill()
   elseif ( message == ALibrarySystemsDebugUtilities___containerCheat ) then
    call GetContainerDebug() //ALibraryDebugContainer
   elseif ( message == ALibrarySystemsDebugUtilities___stringCheat ) then
    call GetStringDebug() //ALibraryDebugString
   elseif ( message == ALibrarySystemsDebugUtilities___interfaceCheat ) then
    call GetInterfaceDebug() //ALibraryDebugInterface
   endif
	endfunction

 function ALibrarySystemsDebugUtilities___init takes nothing returns nothing
   local integer i
   local player user
   local event triggerEvent
   local triggeraction triggerAction

   set ALibrarySystemsDebugUtilities___cheatTrigger = CreateTrigger()
   set i = 0
   loop
    exitwhen ( i == bj_MAX_PLAYERS )
    set user = Player(i)
    if ( IsPlayerPlayingUser(user) ) then
     set triggerEvent = TriggerRegisterPlayerChatEvent(ALibrarySystemsDebugUtilities___cheatTrigger , user , "" , false)
    endif
    set user = null
    set i = i + 1
   endloop
   set triggerAction = TriggerAddAction(ALibrarySystemsDebugUtilities___cheatTrigger , function ALibrarySystemsDebugUtilities___triggerActionCheat)
   set triggerEvent = null
   set triggerAction = null
	endfunction


//library ALibrarySystemsDebugUtilities ends
//library AStructSystemsCharacterQuestItem:

		//start members
		//members

//textmacro instance: A_STRUCT_DEBUG("\"AQuestItem\"")
   function s__AQuestItem_print takes integer this,string message returns nothing
    call Print("AQuestItem" + " - " + I2S(this) + ": " + message)
   endfunction

   function s__AQuestItem_staticPrint takes string message returns nothing
    call Print("AQuestItem" + ": " + message)
   endfunction
//end of: A_STRUCT_DEBUG("\"AQuestItem\"")

  function s__AQuestItem_setState takes integer this,integer state returns nothing
   local boolean result
			call s__AAbstractQuest_setState(this,state) //AClassCharacterAbstractQuest
			set result = not s__AQuest_checkQuestItemsForState(s__AQuestItem_usedQuest[this],state) //AClassCharacterQuest
			if ( s__AQuest_isQuestLogUsed() ) then //AClassCharacterQuest
				//call QuestItemSetDescription(this.questLogQuestItem, this.getTitle()) //AClassCharacterAbstractQuest
				call QuestItemSetCompleted(s__AQuestItem_questLogQuestItem[this] , state == s__AAbstractQuest_stateCompleted) //AClassCharacterAbstractQuest
				if ( result ) then
					call FlashQuestDialogButton()
					call ForceQuestDialogUpdate() //required?
				endif
			endif
  endfunction

  function s__AQuestItem_createQuestLogQuestItem takes integer this returns nothing
			if ( s__AQuest_isQuestLogUsed() ) then //AClassCharacterQuest
				set s__AQuestItem_questLogQuestItem[this]=QuestCreateItem(s__AQuest_getQuestLogQuest(s__AQuestItem_usedQuest[this]))
				call QuestItemSetDescription(s__AQuestItem_questLogQuestItem[this] , s__AAbstractQuest_getTitle(this))
			endif
  endfunction

  function s__AQuestItem_create takes integer usedQuest,string description,real pingRate returns integer
   local integer this= s__AQuestItem__allocate(s__AAbstractQuest_getCharacter(usedQuest) , description , pingRate)
    if ( usedQuest == 0 ) then
     call s__AQuestItem_print(this,"usedQuest is 0.")
    endif
			//start members
			set s__AQuestItem_usedQuest[this]=usedQuest

			call s__AQuestItem_createQuestLogQuestItem(this)
			call s__AQuest_addQuestItem(usedQuest,this)
			return this
  endfunction

  function s__AQuestItem_destroyQuestLogQuestItem takes integer this returns nothing
			if ( s__AQuest_isQuestLogUsed() ) then
				set s__AQuestItem_questLogQuestItem[this]=null
				//Could not destroy quest items!
			endif
  endfunction

  function s__AQuestItem_onDestroy takes integer this returns nothing
			call s__AQuestItem_destroyQuestLogQuestItem(this)
  endfunction


//library AStructSystemsCharacterQuestItem ends
//library AStructSystemsGuiCheckBox:

 function AStructSystemsGuiCheckBox__onHitAction takes integer usedWidget returns nothing
		call sc__ACheckBox_setChecked((usedWidget),not sc__ACheckBox_isChecked((usedWidget)))
	endfunction

		//static start members
		//dynamic members
		//members

		//dynamic members

  function s__ACheckBox_setChecked takes integer this,boolean checked returns nothing
			set s__ACheckBox_m_checked[this]=checked
			call s__AWidget_setShown(s__ACheckBox_checkedImage[this],checked)
			call s__AWidget_setShown(s__ACheckBox_uncheckedImage[this],not checked)
  endfunction

  function s__ACheckBox_isChecked takes integer this returns boolean
			return s__ACheckBox_m_checked[this]
  endfunction

		//methods

  function s__ACheckBox_show takes integer this returns nothing
			call s__AWidget_show(this)
			call s__AWidget_setShown(s__ACheckBox_checkedImage[this],s__ACheckBox_m_checked[this])
			call s__AWidget_setShown(s__ACheckBox_checkedImage[this],not s__ACheckBox_m_checked[this])
  endfunction

  function s__ACheckBox_hide takes integer this returns nothing
			call s__AWidget_hide(this)
			call s__AWidget_setShown(s__ACheckBox_checkedImage[this],not s__ACheckBox_m_checked[this])
			call s__AWidget_setShown(s__ACheckBox_checkedImage[this],s__ACheckBox_m_checked[this])
  endfunction

  function s__ACheckBox_create takes integer mainWindow,real x,real y,real sizeX,real sizeY,integer onTrackAction,boolean checked returns integer
   local integer this= s__ACheckBox__allocate(mainWindow , x , y , sizeX , sizeY , (4) , onTrackAction)
			//dynamic members
			set s__ACheckBox_m_checked[this]=false
			//members
			set s__ACheckBox_checkedImage[this]=s__AImage_create(s__ACheckBox_checkedImageFilePath , mainWindow , x , y , sizeX , sizeY , 0 , 0)
			set s__ACheckBox_uncheckedImage[this]=s__AImage_create(s__ACheckBox_uncheckedImageFilePath , mainWindow , x , y , sizeX , sizeY , 0 , 0)
			return this
  endfunction

		//static methods

  function s__ACheckBox_init0 takes string checkedImageFilePath,string uncheckedImageFilePath returns nothing
			set s__ACheckBox_checkedImageFilePath=checkedImageFilePath
			set s__ACheckBox_uncheckedImageFilePath=uncheckedImageFilePath
  endfunction


//library AStructSystemsGuiCheckBox ends
//library ACore:

//library ACore ends
//library ASystemCharacter:
//AStructSystemsCharacterNeratiaFight,

//library ASystemCharacter ends
//library ASystemGui:
//AStructSystemsGuiLayout, 

//library ASystemGui ends
//library ALibrarySystemsDebugCharacter:


 function setTalkUnit takes unit usedUnit returns nothing
		set ALibrarySystemsDebugCharacter__talkUnit = usedUnit
	endfunction

 function setShrineDestructable takes destructable usedDestructable returns nothing
		set ALibrarySystemsDebugCharacter__shrineDestructable = usedDestructable
	endfunction

 function ALibrarySystemsDebugCharacter__questItemStateEventChat takes integer abstractQuest,trigger usedTrigger returns nothing
  local event triggerEvent= TriggerRegisterPlayerChatEvent(usedTrigger , Player(0) , "complete" , true)
		set triggerEvent = null
	endfunction

 function ALibrarySystemsDebugCharacter__questItemStateActionChat takes integer abstractQuest returns nothing
		call Print("QUEST COMPLETED")
	endfunction

 function ALibrarySystemsDebugCharacter__createQuest takes player user returns nothing
  local integer usedQuest
  local integer questItem1
  local integer questItem2
		set usedQuest = s__AQuest_create(s__ACharacter_getPlayerCharacter(user) , "Der Fluch der Wölfe" , 30.0)
		call Print("Q1")
		call s__AAbstractQuest_setReward(usedQuest,s__AAbstractQuest_rewardGold , 200)
		call s__AAbstractQuest_setPingX(usedQuest,0.0)
		call s__AAbstractQuest_setPingY(usedQuest,0.0)
		call s__AAbstractQuest_setPingDuration(usedQuest,2.0)
		call s__AAbstractQuest_setPingRed(usedQuest,100.0)
		call s__AAbstractQuest_setPingGreen(usedQuest,100.0)
		call s__AAbstractQuest_setPingBlue(usedQuest,100.0)
		call Print("Q2")

		set questItem1 = s__AQuestItem_create(usedQuest , "Bring dich um!" , 0.0)
		call Print("...--")
		call s__AAbstractQuest_setStateEvent(questItem1,s__AAbstractQuest_stateCompleted , (1))
		call Print("...")
		call s__AAbstractQuest_setStateAction(questItem1,s__AAbstractQuest_stateCompleted , (1))
		call s__AAbstractQuest_setReward(questItem1,s__AAbstractQuest_rewardGold , 50)
		call Print("Q3")

		set questItem2 = s__AQuestItem_create(usedQuest , "Noch ein Test." , 0.0)
		call s__AAbstractQuest_setStateEvent(questItem2,s__AAbstractQuest_stateCompleted , (1))
		call s__AAbstractQuest_setStateAction(questItem2,s__AAbstractQuest_stateCompleted , (1))
		call s__AAbstractQuest_setReward(questItem2,s__AAbstractQuest_rewardGold , 50)
		call Print("Q4")

		call sc__AAbstractQuest_setState(usedQuest,s__AAbstractQuest_stateNew)
		call Print("Q5")
	endfunction

 function ALibrarySystemsDebugCharacter__talkStartActionTestTalk takes integer talk returns nothing
   call Print("Start Action for talk " + I2S(talk))
		call s__ATalk_showInfo(talk,0)
   call Print("After The First Show Info")
		call s__ATalk_showInfo(talk,1)
		call s__ATalk_showInfo(talk,2)
		call s__ATalk_showExitButton(talk)
   call Print("After Show Exit Button")
		call s__ATalk_show(talk)
   call Print("After Show with Talk " + I2S(talk))
	endfunction

 function ALibrarySystemsDebugCharacter__talkButtonActionFuckYou takes integer talk returns nothing
		call Print("Fuck You action")
		call s__ATalk_speech(talk,"Danke." , null , false)
		call Print("After Fuck You action")
	endfunction

 function ALibrarySystemsDebugCharacter__talkButtonActionHello takes integer talk returns nothing
		//call talk.speech("Hey, was geht ab Alta?!", null, true)

		call s__ATalk_showFirstPage(talk)
	endfunction

 function ALibrarySystemsDebugCharacter__talkButtonActionHowAreYou takes integer talk returns nothing
		//call talk.speech("Wie wohl?", null, true)

		call s__ATalk_showFirstPage(talk)
	endfunction

 function ALibrarySystemsDebugCharacter__createTalk takes nothing returns nothing
  local integer talk= s__ATalk_create(ALibrarySystemsDebugCharacter__talkUnit , (3))

		call s__ATalk_addInfo(talk,"Fick dich!" , null , false , true , 0 , (4))
		call s__ATalk_addInfo(talk,"Hallo." , null , true , false , 0 , (5))
		call s__ATalk_addInfo(talk,"Wie geht es dir?." , null , true , false , 0 , (6))
	endfunction

 function ALibrarySystemsDebugCharacter__createItemType takes nothing returns nothing
		call s__AItemType_create('amrc' , s__AItemType_equipmentTypeHeaddress , 1 , 10 , 10 , 10 , 0)
	endfunction

 function ALibrarySystemsDebugCharacter__castAction takes integer character returns nothing
		call Print("Cast!")
	endfunction

 function ALibrarySystemsDebugCharacter__createSpell takes integer character returns nothing
		call s__ASpell_create(character , 'AOmi' , (1))
	endfunction

 function ALibrarySystemsDebugCharacter__getCharacterDebug takes player user,unit usedUnit returns nothing
		call s__ACharacter_setPlayerCharacter(user , usedUnit)
		call s__ARevival_setTime(s__ACharacter_getRevival(s__ACharacter_getPlayerCharacter(user)),GetUnitLevel(usedUnit) * 5.0) //HeroLevel
		call s__ACharacter_setMovable(s__ACharacter_getPlayerCharacter(user),true)

		call ALibrarySystemsDebugCharacter__createQuest(user)
		call ALibrarySystemsDebugCharacter__createTalk()
		call ALibrarySystemsDebugCharacter__createItemType()
		call ALibrarySystemsDebugCharacter__createSpell(s__ACharacter_getPlayerCharacter(user))
	endfunction

 function ALibrarySystemsDebugCharacter__init takes nothing returns nothing
  local player user= Player(0)

		call setTalkUnit(CreateUnit(user , 'Nbbc' , GetPlayerStartLocationX(user) , GetPlayerStartLocationY(user) , 0.0))
		call setShrineDestructable(CreateDestructable('Dofv' , GetPlayerStartLocationX(user) , GetPlayerStartLocationY(user) , 0.0 , 1.0 , 0))

		call ALibrarySystemsDebugCharacter__getCharacterDebug(user , CreateUnit(user , 'Nbbc' , GetPlayerStartLocationX(user) , GetPlayerStartLocationY(user) , 0.0))
		set user = null
	endfunction


//library ALibrarySystemsDebugCharacter ends
//library ALibrarySystemsDebugGui:


 function ALibrarySystemsDebugGui__onHitActionShowMessage takes integer usedWidget returns nothing
  local player user= s__AGui_getUser(s__AMainWindow_getGui(s__AWidget_getMainWindow(usedWidget)))
		call Print("TEST LALALALALALALALA")
		call s__AGui_showInfoDialog(s__AGui_getPlayerGui(user),"Diese Informationen sind|n�u�erst interessant.")
		set user = null
	endfunction

 function ALibrarySystemsDebugGui__initHeaderQuestLogWidget takes player user returns nothing
  local integer usedWidget= s__AWidget_create(ALibrarySystemsDebugGui__questLog[GetPlayerId(user)] , 20.0 , 20.0 , 50.0 , 50.0 , (5) , (6))
		call s__AWidget_setShortcut(usedWidget,'a')
		call s__AWidget_setTooltip(usedWidget,"Tooltip!!!!!")
		call s__AWidget_setTooltipSize(usedWidget,12)
	endfunction

 function ALibrarySystemsDebugGui__initQuestLogForPlayer takes player user returns nothing
		set ALibrarySystemsDebugGui__questLog[GetPlayerId(user)]=s__AMainWindow_create(s__AGui_getPlayerGui(user) , 0.0 , 0.0 , 1000.0 , 1000.0 , true , 0)
		call ALibrarySystemsDebugGui__initHeaderQuestLogWidget(user)
	endfunction

 function ALibrarySystemsDebugGui__onPressGuiShortcutActionShowMessage takes integer gui returns nothing
		call Print("PRESS ESCAPE")
	endfunction

 function ALibrarySystemsDebugGui__init takes nothing returns nothing
  local integer i
  local player user
		set ALibrarySystemsDebugGui__hasToInit = false
		set i = 0
		loop
			exitwhen ( i == bj_MAX_PLAYERS )
			set user = Player(i)
			call s__AGui_setOnPressGuiShortcutAction(s__AGui_getPlayerGui(user),s__AGui_shortcutEscape , (1))
			call ALibrarySystemsDebugGui__initQuestLogForPlayer(user)
			set user = null
			set i = ( i + 1 )
		endloop
	endfunction

 function getGuiDebug takes player user returns nothing
		if ( ALibrarySystemsDebugGui__hasToInit ) then
			call ALibrarySystemsDebugGui__init()
		endif

		if ( s__AMainWindow_getIsShown(ALibrarySystemsDebugGui__questLog[GetPlayerId(user)]) ) then
			call s__AMainWindow_hide(ALibrarySystemsDebugGui__questLog[GetPlayerId(user)])
		else
			call s__AMainWindow_show(ALibrarySystemsDebugGui__questLog[GetPlayerId(user)])
		endif
	endfunction


//library ALibrarySystemsDebugGui ends
//library AStructSystemsDebugSystemDebugger:

	/// @todo Should be a method of @struct ASystemDebugger, vJass bug.
 function AStructSystemsDebugSystemDebugger__onHitActionShowInfo takes integer usedWidget returns nothing
		call s__AGui_showInfoDialog(s__AWidget_getGui(usedWidget),"Advanced Script Library")
	endfunction

	/// @todo Should be a method of @struct ASystemDebugger, vJass bug.
 function AStructSystemsDebugSystemDebugger__onHitActionShowGuiSystemMainWindow takes integer usedWidget returns nothing
		call s__AGui_showMainWindowByIndex(s__AWidget_getGui(usedWidget),0)
	endfunction

	/// @todo Should be a method of @struct ASystemDebugger, vJass bug.
 function AStructSystemsDebugSystemDebugger__onHitActionShowCharacterSystemMainWindow takes integer usedWidget returns nothing
		call s__AGui_showMainWindowByIndex(s__AWidget_getGui(usedWidget),1)
	endfunction

	/// @todo Should be a method of @struct ASystemDebugger, vJass bug.
 function AStructSystemsDebugSystemDebugger__onHitActionShowWorldSystemMainWindow takes integer usedWidget returns nothing
		call s__AGui_showMainWindowByIndex(s__AWidget_getGui(usedWidget),2)
	endfunction
	
	/// @todo Should be a method of @struct ASystemDebugger, vJass bug.
 function AStructSystemsDebugSystemDebugger__onHitActionInitCharacterSystem takes integer usedWidget returns nothing
	endfunction

	/// @todo Finish code.
	/// The ASystemDebugger class provides a GUI for testing all systems of the ASL system module.
	/// You can create characters, NPCs, quests etc. easily by using buttons.
	/// Usually this reduces debugging time of the programer.
		//static start members
		//start members
		//members

		
		
		
  function s__ASystemDebugger_show takes integer this returns nothing
			if ( s__AMainWindow_getIsShown(s__ASystemDebugger_mainWindow[this]) ) then
				call s__AMainWindow_hide(s__ASystemDebugger_mainWindow[this])
			else
				call s__AMainWindow_show(s__ASystemDebugger_mainWindow[this])
			endif
  endfunction

  function s__ASystemDebugger_createGuiSystemWindow takes integer this returns nothing
			set s__ASystemDebugger_guiSystemWindow[this]=s__AMainWindow_create(s__AGui_getPlayerGui(s__ASystemDebugger_user[this]) , 0.0 , 0.0 , 1000.0 , 1000.0 , true , 0)
		
			set s__ASystemDebugger_guiSystemHeadLineText[this]=s__AText_create(s__ASystemDebugger_mainWindow[this] , 400.0 , 200.0 , 0.0 , 0.0 , 0 , (6))
			call s__AText_setTextAndSize(s__ASystemDebugger_guiSystemHeadLineText[this],"GUI-System" , 15.0)
			call s__AWidget_setTooltip(s__ASystemDebugger_guiSystemHeadLineText[this],"Die ASL bietet ein GUI-System, welches zum Erstellen grafischer Oberflächen verwendet werden kann.")
			call s__AWidget_setTooltipSize(s__ASystemDebugger_guiSystemHeadLineText[this],12.0)

			//show all kinds of widgets
  endfunction
		
  function s__ASystemDebugger_createCharacterSystemWindow takes integer this returns nothing
			set s__ASystemDebugger_characterSystemWindow[this]=s__AMainWindow_create(s__AGui_getPlayerGui(s__ASystemDebugger_user[this]) , 0.0 , 0.0 , 1000.0 , 1000.0 , true , 0)

			set s__ASystemDebugger_initCharacterSystemButton[this]=s__AButton__allocate(s__ASystemDebugger_characterSystemWindow[this] , 0.0 , 0.0 , 80.0 , 80.0 , (7) , (6))
			call s__AWidget_setTooltip(s__ASystemDebugger_initCharacterSystemButton[this],"Initialisiert das Charaktersystem. Diese Aktion kann nur einmal im Spiel durchgeführt werden.")
			call s__AWidget_setTooltipSize(s__ASystemDebugger_initCharacterSystemButton[this],12.0)

			//private AButton createCharactersButton
			//private ACheckBox removeUnitOnDestructionCheckBox
			//private ACheckBox destroyOnPlayerLeavesCheckBox
			//private ACheckBox destroyOnDeathCheckBox
			//private ACheckBox useViewSystemCheckBox
			//private ACheckBox useFocusSystemCheckBox
			//private ACheckBox useMovementSystemCheckBox
			//private ACheckBox useFightSystemCheckBox
			//private ACheckBox useRevivalSystemCheckBox
			//private ACheckBox useInventorySystemCheckBox
  endfunction

  function s__ASystemDebugger_createWorldSystemWindow takes integer this returns nothing
  endfunction
	
  function s__ASystemDebugger_createGui takes integer this returns nothing
			set s__ASystemDebugger_mainWindow[this]=s__AMainWindow_create(s__AGui_getPlayerGui(s__ASystemDebugger_user[this]) , 0.0 , 0.0 , 1000.0 , 1000.0 , true , KEY_ESCAPE)
		
			set s__ASystemDebugger_headLineText[this]=s__AText_create(s__ASystemDebugger_mainWindow[this] , 400.0 , 200.0 , 0.0 , 0.0 , (8) , (6))
			call s__AText_setTextAndSize(s__ASystemDebugger_headLineText[this],"Advanced Script Library" , 15.0)
			call s__AWidget_setTooltip(s__ASystemDebugger_headLineText[this],"Advanced Script Library.")
			call s__AWidget_setTooltipSize(s__ASystemDebugger_headLineText[this],12.0)
			
			set s__ASystemDebugger_guiSystemsButton[this]=s__AButton__allocate(s__ASystemDebugger_mainWindow[this] , 50.0 , 50.0 , 20.0 , 20.0 , (9) , (6))
			call s__AWidget_setShortcut(s__ASystemDebugger_guiSystemsButton[this],'g')
			call s__AWidget_setTooltip(s__ASystemDebugger_guiSystemsButton[this],"Drücken Sie hier, um das GUI-System der ASL zu testen")
			call s__AWidget_setTooltipSize(s__ASystemDebugger_guiSystemsButton[this],12.0)
			
			set s__ASystemDebugger_characterSystemsButton[this]=s__AButton__allocate(s__ASystemDebugger_mainWindow[this] , 50.0 , 50.0 , 20.0 , 20.0 , (10) , (6))
			call s__AWidget_setShortcut(s__ASystemDebugger_characterSystemsButton[this],'c')
			call s__AWidget_setTooltip(s__ASystemDebugger_characterSystemsButton[this],"Drücken Sie hier, um das Charaktersystem der ASL zu testen.")
			call s__AWidget_setTooltipSize(s__ASystemDebugger_characterSystemsButton[this],12.0)
			
			set s__ASystemDebugger_worldSystemsButton[this]=s__AButton__allocate(s__ASystemDebugger_mainWindow[this] , 100.0 , 50.0 , 20.0 , 20.0 , (11) , (6))
			call s__AWidget_setShortcut(s__ASystemDebugger_worldSystemsButton[this],'w')
			call s__AWidget_setTooltip(s__ASystemDebugger_worldSystemsButton[this],"Drücken Sie hier, um das Weltsystem der ASL zu testen.")
			call s__AWidget_setTooltipSize(s__ASystemDebugger_worldSystemsButton[this],12.0)

			call s__ASystemDebugger_createGuiSystemWindow(this)
			call s__ASystemDebugger_createCharacterSystemWindow(this)
			call s__ASystemDebugger_createWorldSystemWindow(this)
  endfunction
		
  function s__ASystemDebugger_triggerActionShow takes nothing returns nothing
   local trigger triggeringTrigger= GetTriggeringTrigger()
   local integer systemDebugger= s__AHashTable_getHandleInteger(AGetDebugHashTable(),triggeringTrigger , "systemDebugger") //AStructDebugDebugHashTable
			call s__ASystemDebugger_show(systemDebugger)
			set triggeringTrigger = null
  endfunction
		
  function s__ASystemDebugger_createMenuTrigger takes integer this returns nothing
   local event triggerEvent
   local triggeraction triggerAction
			set s__ASystemDebugger_menuTrigger[this]=CreateTrigger()
			set triggerEvent = TriggerRegisterKeyEventForPlayer(s__ASystemDebugger_user[this] , s__ASystemDebugger_menuTrigger[this] , s__ASystemDebugger_menuKey , true) //ALibraryInterfaceMisc
			set triggerAction = TriggerAddAction(s__ASystemDebugger_menuTrigger[this] , function s__ASystemDebugger_triggerActionShow)
			call s__AHashTable_storeHandleInteger(AGetDebugHashTable(),s__ASystemDebugger_menuTrigger[this] , "systemDebugger" , this) //AStructDebugDebugHashTable
			set triggerEvent = null
			set triggerAction = null
  endfunction

		/// @param user The debugging player.
  function s__ASystemDebugger_create takes player user returns integer
   local integer this= s__ASystemDebugger__allocate()
			//start members
			set s__ASystemDebugger_user[this]=user
			
			call s__ASystemDebugger_createGui(this)
			call s__ASystemDebugger_createMenuTrigger(this)
			return this
  endfunction
		
  function s__ASystemDebugger_destroyMenuTrigger takes integer this returns nothing
			call s__AHashTable_destroyTrigger(AGetDebugHashTable(),s__ASystemDebugger_menuTrigger[this])
			set s__ASystemDebugger_menuTrigger[this]=null
  endfunction
		
  function s__ASystemDebugger_onDestroy takes integer this returns nothing
		
			call s__ASystemDebugger_destroyMenuTrigger(this)
  endfunction

//Generated destructor of ASystemDebugger
function s__ASystemDebugger_destroy takes integer this returns nothing
    if this==null then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: ASystemDebugger")
        return
    elseif (si__ASystemDebugger_V[this]!=-1) then
        call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: ASystemDebugger")
        return
    endif
    call s__ASystemDebugger_onDestroy(this)
    set si__ASystemDebugger_V[this]=si__ASystemDebugger_F
    set si__ASystemDebugger_F=this
endfunction
		
		/// @param menuKey The key which should be pressed by the player for showing the debugger's GUI.
  function s__ASystemDebugger_init takes integer menuKey returns nothing
			//static start members
			set s__ASystemDebugger_menuKey=menuKey
  endfunction


//library AStructSystemsDebugSystemDebugger ends
//library ASystemDebug:

//library ASystemDebug ends
//library ASystems:

//library ASystems ends
//library Asl:

//library Asl ends
/// @todo In general you should use no map script (Use the map file).
//===========================================================================
//
//	Test Map
//
//	Warcraft III map script
//	Generated by the Warcraft III World Editor
//	Date: Wed Jun 04 15:28:02 2003
//	Map Author: Blizzard Entertainment
//
//===========================================================================

// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Import Asl.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Import.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/General/Import.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/General/Struct Container.j
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/General/Struct Container.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/General/Struct Hash Table.j
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/General/Struct Hash Table.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/General/Struct Stack.j
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/General/Struct Stack.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/General/Struct Slk Table Entry.j
/// Do not use this library, it is unfinished!
/// @todo Finish and test this library.
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/General/Struct Slk Table Entry.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/General/Library Conversion.j
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/General/Library Conversion.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/General/Library Debug.j

// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/General/Library Debug.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/General/Library Game.j
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/General/Library Game.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/General/Library Player.j
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/General/Library Player.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/General/Library Unit.j
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/General/Library Unit.j

// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/General/Import.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Maths/Import.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Maths/Struct Circle.j
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Maths/Struct Circle.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Maths/Struct Point.j

// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Maths/Struct Point.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Maths/Struct Vector.j
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Maths/Struct Vector.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Maths/Library Conversion.j
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Maths/Library Conversion.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Maths/Library Handle.j
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Maths/Library Handle.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Maths/Library Item.j
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Maths/Library Item.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Maths/Library Index.j
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Maths/Library Index.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Maths/Library Location.j
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Maths/Library Location.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Maths/Library Point.j
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Maths/Library Point.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Maths/Library Real.j
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Maths/Library Real.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Maths/Library Rect.j
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Maths/Library Rect.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Maths/Library Region.j
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Maths/Library Region.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Maths/Library Unit.j
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Maths/Library Unit.j

// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Maths/Import.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/String/Import.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/String/Library Conversion.j
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/String/Library Conversion.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/String/Library Pool.j
/// Provides many functions for working with string pools and checking strings and characters for their content.
/// @todo Not tested yet!
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/String/Library Pool.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/String/Library Misc.j
/// @todo Not tested yet!
/// The SubString functions are concepted that they doesn't need each other.
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/String/Library Misc.j

/// Information about @function SubString
/// start = start char position, starts with 0: 0 = first char, StringLength - 1 = last char
/// end = last char position, starts with 1: 1 = first char, StringLength = last char
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/String/Import.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Interface/Import.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Interface/Struct Interface Hash Table.j
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Interface/Struct Interface Hash Table.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Interface/Struct Indicator.j
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Interface/Struct Indicator.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Interface/Struct Multiboard Bar.j
/// ALibraryGeneralDebug is required because we have some checkings about the length.
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Interface/Struct Multiboard Bar.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Interface/Library Camera.j
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Interface/Library Camera.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Interface/Library Cinematic.j
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Interface/Library Cinematic.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Interface/Library Cinematic Filter.j
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Interface/Library Cinematic Filter.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Interface/Library Image.j
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Interface/Library Image.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Interface/Library Leaderboard.j
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Interface/Library Leaderboard.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Interface/Library Minimap.j
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Interface/Library Minimap.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Interface/Library Misc.j
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Interface/Library Misc.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Interface/Library Multiboard.j
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Interface/Library Multiboard.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Interface/Library Selection.j
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Interface/Library Selection.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Interface/Library Text Tag.j
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Interface/Library Text Tag.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Interface/Library Trackable.j
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Interface/Library Trackable.j

// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Interface/Import.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Environment/Import.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Environment/Struct Missile.j

// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Environment/Struct Missile.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Environment/Library Special Effect.j
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Environment/Library Special Effect.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Environment/Library Lightning.j
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Environment/Library Lightning.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Environment/Library Sound.j
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Environment/Library Sound.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Environment/Library Terrain.j
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Environment/Library Terrain.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Environment/Library Unit.j
/// Provides several functions for unit handling.
/// @author Tamino Dauth
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Environment/Library Unit.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Environment/Library Destructable.j
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Environment/Library Destructable.j


// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Environment/Import.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Ai/Import.j
/// @todo Implement AI module.
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Ai/Import.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Debug/Import.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Debug/Struct Debug Hash Table.j
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Debug/Struct Debug Hash Table.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Debug/Struct Cheat.j
/// @author Tamino Dauth
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Debug/Struct Cheat.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Debug/Library Container.j
/// @todo Make a new test. Container system has changed …
/// Test completed.
/// 2008-02-26
/// 2009-03-08 Tamino Dauth <tamino@cdauth.de>
/// Revised test.
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Debug/Library Container.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Debug/Library String.j
/// Test of all core string functions.
/// This is the last test I made with the core.
/// @todo String functions weren't checked at all.
/// @todo Test is not completed yet.
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Debug/Library String.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Debug/Library Interface.j
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Debug/Library Interface.j

// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Debug/Import.j

// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Core/Import.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Import.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Gui/Import.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Gui/Struct Button.j
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Gui/Struct Button.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Gui/Struct Check Box.j
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Gui/Struct Check Box.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Gui/Struct Gui.j
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Gui/Struct Gui.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Gui/Struct Image.j
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Gui/Struct Image.j
////! import "Systems/Gui/Struct Gui Layout.j"
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Gui/Struct Main Window.j

// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Gui/Struct Main Window.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Gui/Struct Text.j
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Gui/Struct Text.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Gui/Struct Widget.j
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Gui/Struct Widget.j


// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Gui/Import.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Character/Import.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Character/Struct Character Hash Table.j
/// @todo Compare this library with the ALibraryInterfaceInterfaceHashTable library
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Character/Struct Character Hash Table.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Character/Struct Characters Scheme.j
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Character/Struct Characters Scheme.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Character/Struct Abstract Character System.j
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Character/Struct Abstract Character System.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Character/Struct Abstract Quest.j
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Character/Struct Abstract Quest.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Character/Struct Character.j

// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Character/Struct Character.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Character/Struct Class Selection.j
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Character/Struct Class Selection.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Character/Struct Class.j
/// Why should it be contained by ACharacter?
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Character/Struct Class.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Character/Struct Fight.j
/// The fps common.j file is required.
/// Do not use this library, it is unfinished!
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Character/Struct Fight.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Character/Struct Focus.j
/// Do not use this library, it is unfinished!
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Character/Struct Focus.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Character/Struct Inventory.j
/// @todo Wenn der Charakter einen Gegenstand ablegt, muss überprüft werden, ob die anderen noch getragen werden können (Attribute).
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Character/Struct Inventory.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Character/Struct Item Type.j
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Character/Struct Item Type.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Character/Struct Movement.j
/// The fps common.j file is required.
/// Jumping is not implemented yet.
/// Do not use this library, it is unfinished!
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Character/Struct Movement.j
////! import "Systems/Character/Struct Neratia Fight.j"
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Character/Struct Spell.j
/// This library contains the ASpell struct which is used for character spells.
/// @author Tamino Dauth
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Character/Struct Spell.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Character/Struct Quest.j
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Character/Struct Quest.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Character/Struct Quest Item.j

// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Character/Struct Quest Item.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Character/Struct Revival.j
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Character/Struct Revival.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Character/Struct Shrine.j
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Character/Struct Shrine.j
// attempt to import "/media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Character/Struct Spell.j" ignored since "Systems/Character/Struct Spell.j" was already imported
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Character/Struct Talk.j

// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Character/Struct Talk.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Character/Struct View.j
/// Do not use this library, it is unfinished!
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Character/Struct View.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Character/Struct Video.j
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Character/Struct Video.j

// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Character/Import.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/World/Import.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/World/Struct Routine.j
/// @todo Untestet!
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/World/Struct Routine.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/World/Struct Spawn Point.j

// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/World/Struct Spawn Point.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/World/Struct World Hash Table.j
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/World/Struct World Hash Table.j

// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/World/Import.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Debug/Import.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Debug/Struct System Debugger.j
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Debug/Struct System Debugger.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Debug/Library Character.j
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Debug/Library Character.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Debug/Library Gui.j
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Debug/Library Gui.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Debug/Library Utilities.j
/// This library provides some cheats only usable in debug mode to test your map.
/// @param clear Clears the screen messages for the cheating player.
/// @param info Shows some information about the selected unit of the cheating player.
/// @param setlevel Sets the level of the selected unit of the cheating player.
/// @param kill Kills the selected unit of the cheating player.
/// @param container Runs the container debug.
/// @param string Runs the string debug.
/// @param interface Runs the interface debug.
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Debug/Library Utilities.j

// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Debug/Import.j

// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Systems/Import.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Objects/Import.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Objects/Library Doodads.j
/// Do not use this library.
/// @author Tamino Dauth
/// @state untested
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Objects/Library Doodads.j
// begin import from /media/JUDAS-1/Projekte/wc3sdk/src/\Objects/Library Units.j
/// Do not use this library.
/// @author Tamino Dauth
/// @state untested
// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Objects/Library Units.j

/// Do not use this library.
/// @state untested

// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Objects/Import.j


// end import from /media/JUDAS-1/Projekte/wc3sdk/src/\Import Asl.j

//***************************************************************************
//*
//*  Global Variables
//*
//***************************************************************************


function InitGlobals takes nothing returns nothing
endfunction

//***************************************************************************
//*
//*  Unit Item Tables
//*
//***************************************************************************


//***************************************************************************
//*
//*  Sounds
//*
//***************************************************************************

function InitSounds takes nothing returns nothing
endfunction

//***************************************************************************
//*
//*  Unit Creation
//*
//***************************************************************************

//===========================================================================
function CreateNeutralHostile takes nothing returns nothing
endfunction

//===========================================================================
function CreateNeutralPassiveBuildings takes nothing returns nothing
endfunction

//===========================================================================
function CreatePlayerBuildings takes nothing returns nothing
endfunction

//===========================================================================
function CreatePlayerUnits takes nothing returns nothing
endfunction

//===========================================================================
function CreateAllUnits takes nothing returns nothing
    call CreateNeutralPassiveBuildings()
    call CreatePlayerBuildings()
    call CreateNeutralHostile()
    call CreatePlayerUnits()
endfunction

//***************************************************************************
//*
//*  Triggers
//*
//***************************************************************************

//===========================================================================
function InitCustomTriggers takes nothing returns nothing
endfunction

//===========================================================================
function RunInitializationTriggers takes nothing returns nothing
endfunction

//***************************************************************************
//*
//*  Players
//*
//***************************************************************************

function InitCustomPlayerSlots takes nothing returns nothing

    // Player 0
    call SetPlayerStartLocation(Player(0) , 0)
    call SetPlayerColor(Player(0) , ConvertPlayerColor(0))
    call SetPlayerRacePreference(Player(0) , RACE_PREF_HUMAN)
    call SetPlayerRaceSelectable(Player(0) , true)
    call SetPlayerController(Player(0) , MAP_CONTROL_USER)

    // Player 1
    call SetPlayerStartLocation(Player(1) , 1)
    call SetPlayerColor(Player(1) , ConvertPlayerColor(1))
    call SetPlayerRacePreference(Player(1) , RACE_PREF_ORC)
    call SetPlayerRaceSelectable(Player(1) , true)
    call SetPlayerController(Player(1) , MAP_CONTROL_USER)

    // Player 2
    call SetPlayerStartLocation(Player(2) , 2)
    call SetPlayerColor(Player(2) , ConvertPlayerColor(2))
    call SetPlayerRacePreference(Player(2) , RACE_PREF_UNDEAD)
    call SetPlayerRaceSelectable(Player(2) , true)
    call SetPlayerController(Player(2) , MAP_CONTROL_USER)

    // Player 3
    call SetPlayerStartLocation(Player(3) , 3)
    call SetPlayerColor(Player(3) , ConvertPlayerColor(3))
    call SetPlayerRacePreference(Player(3) , RACE_PREF_NIGHTELF)
    call SetPlayerRaceSelectable(Player(3) , true)
    call SetPlayerController(Player(3) , MAP_CONTROL_USER)

    // Player 4
    call SetPlayerStartLocation(Player(4) , 4)
    call SetPlayerColor(Player(4) , ConvertPlayerColor(4))
    call SetPlayerRacePreference(Player(4) , RACE_PREF_HUMAN)
    call SetPlayerRaceSelectable(Player(4) , true)
    call SetPlayerController(Player(4) , MAP_CONTROL_USER)

    // Player 5
    call SetPlayerStartLocation(Player(5) , 5)
    call SetPlayerColor(Player(5) , ConvertPlayerColor(5))
    call SetPlayerRacePreference(Player(5) , RACE_PREF_ORC)
    call SetPlayerRaceSelectable(Player(5) , true)
    call SetPlayerController(Player(5) , MAP_CONTROL_USER)

    // Player 6
    call SetPlayerStartLocation(Player(6) , 6)
    call SetPlayerColor(Player(6) , ConvertPlayerColor(6))
    call SetPlayerRacePreference(Player(6) , RACE_PREF_UNDEAD)
    call SetPlayerRaceSelectable(Player(6) , true)
    call SetPlayerController(Player(6) , MAP_CONTROL_USER)

    // Player 7
    call SetPlayerStartLocation(Player(7) , 7)
    call SetPlayerColor(Player(7) , ConvertPlayerColor(7))
    call SetPlayerRacePreference(Player(7) , RACE_PREF_NIGHTELF)
    call SetPlayerRaceSelectable(Player(7) , true)
    call SetPlayerController(Player(7) , MAP_CONTROL_USER)

    // Player 8
    call SetPlayerStartLocation(Player(8) , 8)
    call SetPlayerColor(Player(8) , ConvertPlayerColor(8))
    call SetPlayerRacePreference(Player(8) , RACE_PREF_HUMAN)
    call SetPlayerRaceSelectable(Player(8) , true)
    call SetPlayerController(Player(8) , MAP_CONTROL_USER)

    // Player 9
    call SetPlayerStartLocation(Player(9) , 9)
    call SetPlayerColor(Player(9) , ConvertPlayerColor(9))
    call SetPlayerRacePreference(Player(9) , RACE_PREF_ORC)
    call SetPlayerRaceSelectable(Player(9) , true)
    call SetPlayerController(Player(9) , MAP_CONTROL_USER)

endfunction

function InitCustomTeams takes nothing returns nothing
    // Force: TRIGSTR_020
    call SetPlayerTeam(Player(0) , 0)
    call SetPlayerTeam(Player(1) , 0)
    call SetPlayerTeam(Player(2) , 0)
    call SetPlayerTeam(Player(3) , 0)
    call SetPlayerTeam(Player(4) , 0)
    call SetPlayerTeam(Player(5) , 0)
    call SetPlayerTeam(Player(6) , 0)
    call SetPlayerTeam(Player(7) , 0)
    call SetPlayerTeam(Player(8) , 0)
    call SetPlayerTeam(Player(9) , 0)

endfunction

function InitAllyPriorities takes nothing returns nothing

    call SetStartLocPrioCount(0 , 3)
    call SetStartLocPrio(0 , 0 , 5 , MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(0 , 1 , 6 , MAP_LOC_PRIO_LOW)
    call SetStartLocPrio(0 , 2 , 8 , MAP_LOC_PRIO_LOW)

    call SetStartLocPrioCount(1 , 3)
    call SetStartLocPrio(1 , 0 , 2 , MAP_LOC_PRIO_LOW)
    call SetStartLocPrio(1 , 1 , 7 , MAP_LOC_PRIO_LOW)
    call SetStartLocPrio(1 , 2 , 9 , MAP_LOC_PRIO_HIGH)

    call SetStartLocPrioCount(2 , 3)
    call SetStartLocPrio(2 , 0 , 1 , MAP_LOC_PRIO_LOW)
    call SetStartLocPrio(2 , 1 , 7 , MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(2 , 2 , 9 , MAP_LOC_PRIO_LOW)

    call SetStartLocPrioCount(3 , 3)
    call SetStartLocPrio(3 , 0 , 4 , MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(3 , 1 , 6 , MAP_LOC_PRIO_LOW)
    call SetStartLocPrio(3 , 2 , 8 , MAP_LOC_PRIO_LOW)

    call SetStartLocPrioCount(4 , 3)
    call SetStartLocPrio(4 , 0 , 3 , MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(4 , 1 , 6 , MAP_LOC_PRIO_LOW)
    call SetStartLocPrio(4 , 2 , 8 , MAP_LOC_PRIO_LOW)

    call SetStartLocPrioCount(5 , 3)
    call SetStartLocPrio(5 , 0 , 0 , MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(5 , 1 , 6 , MAP_LOC_PRIO_LOW)
    call SetStartLocPrio(5 , 2 , 8 , MAP_LOC_PRIO_LOW)

    call SetStartLocPrioCount(6 , 3)
    call SetStartLocPrio(6 , 0 , 0 , MAP_LOC_PRIO_LOW)
    call SetStartLocPrio(6 , 1 , 5 , MAP_LOC_PRIO_LOW)
    call SetStartLocPrio(6 , 2 , 8 , MAP_LOC_PRIO_HIGH)

    call SetStartLocPrioCount(7 , 3)
    call SetStartLocPrio(7 , 0 , 1 , MAP_LOC_PRIO_LOW)
    call SetStartLocPrio(7 , 1 , 2 , MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(7 , 2 , 9 , MAP_LOC_PRIO_LOW)

    call SetStartLocPrioCount(8 , 3)
    call SetStartLocPrio(8 , 0 , 0 , MAP_LOC_PRIO_LOW)
    call SetStartLocPrio(8 , 1 , 5 , MAP_LOC_PRIO_LOW)
    call SetStartLocPrio(8 , 2 , 6 , MAP_LOC_PRIO_HIGH)

    call SetStartLocPrioCount(9 , 3)
    call SetStartLocPrio(9 , 0 , 1 , MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(9 , 1 , 2 , MAP_LOC_PRIO_LOW)
    call SetStartLocPrio(9 , 2 , 7 , MAP_LOC_PRIO_LOW)
endfunction

//***************************************************************************
//*
//*  Main Initialization
//*
//***************************************************************************

//===========================================================================
function main takes nothing returns nothing
    call SetCameraBounds(- 12032.0 + GetCameraMargin(CAMERA_MARGIN_LEFT) , - 11776.0 + GetCameraMargin(CAMERA_MARGIN_BOTTOM) , 11264.0 - GetCameraMargin(CAMERA_MARGIN_RIGHT) , 11520.0 - GetCameraMargin(CAMERA_MARGIN_TOP) , - 12032.0 + GetCameraMargin(CAMERA_MARGIN_LEFT) , 11520.0 - GetCameraMargin(CAMERA_MARGIN_TOP) , 11264.0 - GetCameraMargin(CAMERA_MARGIN_RIGHT) , - 11776.0 + GetCameraMargin(CAMERA_MARGIN_BOTTOM))
    call SetDayNightModels("Environment\\DNC\\DNCLordaeron\\DNCLordaeronTerrain\\DNCLordaeronTerrain.mdl" , "Environment\\DNC\\DNCLordaeron\\DNCLordaeronUnit\\DNCLordaeronUnit.mdl")
    call NewSoundEnvironment("Default")
    call SetAmbientDaySound("BarrensDay")
    call SetAmbientNightSound("BarrensNight")
    call SetMapMusic("Music" , true , 0)
    call InitSounds()
    call CreateAllUnits()
    call InitBlizzard()

call ExecuteFunc("jasshelper__initstructs2923")
call ExecuteFunc("ALibrarySystemsDebugUtilities___init")

    call InitGlobals()
    call InitCustomTriggers()
    call RunInitializationTriggers()

endfunction

//***************************************************************************
//*
//*  Map Configuration
//*
//***************************************************************************

function config takes nothing returns nothing
    call SetMapName("TRIGSTR_000")
    call SetMapDescription("TRIGSTR_002")
    call SetPlayers(10)
    call SetTeams(10)
    call SetGamePlacement(MAP_PLACEMENT_TEAMS_TOGETHER)

    call DefineStartLocation(0 , 8000.0 , - 5760.0)
    call DefineStartLocation(1 , - 8896.0 , 6080.0)
    call DefineStartLocation(2 , 3648.0 , 6848.0)
    call DefineStartLocation(3 , - 8640.0 , - 7424.0)
    call DefineStartLocation(4 , - 9088.0 , - 1664.0)
    call DefineStartLocation(5 , 8000.0 , - 1152.0)
    call DefineStartLocation(6 , - 1472.0 , - 8640.0)
    call DefineStartLocation(7 , 6336.0 , 6656.0)
    call DefineStartLocation(8 , 1600.0 , - 7552.0)
    call DefineStartLocation(9 , - 6272.0 , 7680.0)

    // Player setup
    call InitCustomPlayerSlots()
    call SetPlayerSlotAvailable(Player(0) , MAP_CONTROL_USER)
    call SetPlayerSlotAvailable(Player(1) , MAP_CONTROL_USER)
    call SetPlayerSlotAvailable(Player(2) , MAP_CONTROL_USER)
    call SetPlayerSlotAvailable(Player(3) , MAP_CONTROL_USER)
    call SetPlayerSlotAvailable(Player(4) , MAP_CONTROL_USER)
    call SetPlayerSlotAvailable(Player(5) , MAP_CONTROL_USER)
    call SetPlayerSlotAvailable(Player(6) , MAP_CONTROL_USER)
    call SetPlayerSlotAvailable(Player(7) , MAP_CONTROL_USER)
    call SetPlayerSlotAvailable(Player(8) , MAP_CONTROL_USER)
    call SetPlayerSlotAvailable(Player(9) , MAP_CONTROL_USER)
    call InitGenericPlayerSlots()
    call InitAllyPriorities()
endfunction




//Struct method generated initializers/callers:
function sa___prototype826_ALibraryCoreDebugContainer___Compare takes nothing returns boolean
 local integer element=f__arg_integer1
 local integer comparedElement=f__arg_integer2

    set f__result_boolean= ( element < comparedElement )
    return true
endfunction
function sa___prototype789_ALibraryCoreDebugContainer___Show takes nothing returns boolean
 local integer element=f__arg_integer1

		call Print("Show " + I2S(element))
    return true
endfunction
function sa___prototype825_ALibraryCoreDebugContainer___SearchForTen takes nothing returns boolean
 local integer element=f__arg_integer1

    set f__result_boolean= ( element == 10 )
    return true
endfunction
function sa___prototype824_ALibraryCoreDebugContainer___Operation takes nothing returns boolean
 local integer element0=f__arg_integer1
 local integer element1=f__arg_integer2

    set f__result_integer= element0 + element1
    return true
endfunction
function sa___prototype826_ALibraryCoreDebugContainer___SearchForBiggerElement takes nothing returns boolean
 local integer element0=f__arg_integer1
 local integer element1=f__arg_integer2

    set f__result_boolean= ( element0 == element1 )
    return true
endfunction
function sa___prototype835_AStructSystemsGuiGui__unaryFunctionDestroyMainWindow takes nothing returns boolean
 local integer element=f__arg_integer1

		if ( element != 0 ) then
			call sc__AMainWindow_destroy(element)
		endif
    return true
endfunction
function sa___prototype838_AStructSystemsCharacterTalk___GuiDialogButtonActionTalkAction takes nothing returns boolean
 local integer gui=f__arg_integer1
 local integer index=f__arg_integer2

  local integer talk= s__ACharacter_getTalk(s__ACharacter_getPlayerCharacter(s__AGui_getUser(gui)))
		call sc__ATalk_runButtonAction(talk,index)
    return true
endfunction
function sa___prototype843_AStructSystemsCharacterTalk___talkButtonActionExit takes nothing returns boolean
 local integer talk=f__arg_integer1

		call sc__ATalk_disable(talk)
    return true
endfunction
function sa___prototype843_AStructSystemsCharacterTalk___talkButtonActionBackToFirstPage takes nothing returns boolean
 local integer talk=f__arg_integer1

		call sc__ATalk_showFirstPage(talk)
    return true
endfunction
function sa___prototype846_onTrackActionShowTooltip takes nothing returns boolean
 local integer usedWidget=f__arg_integer1

		call sc__AMainWindow_showTooltip(sc__AWidget_getMainWindow(usedWidget),usedWidget)
    return true
endfunction
function sa___prototype830_ALibraryCoreDebugInterface__MultiboardBarValueFunctionGetValue takes nothing returns boolean
 local integer multiboardBar=f__arg_integer1

    set f__result_real= 100.0
    return true
endfunction
function sa___prototype830_ALibraryCoreDebugInterface__MultiboardBarValueFunctionGetMaxValue takes nothing returns boolean
 local integer multiboardBar=f__arg_integer1

    set f__result_real= 100.0
    return true
endfunction
function sa___prototype846_AStructSystemsGuiMainWindow__unaryFunctionShowWidget takes nothing returns boolean
 local integer element=f__arg_integer1

		call sc__AWidget_show(element)
    return true
endfunction
function sa___prototype846_AStructSystemsGuiMainWindow__unaryFunctionHideWidget takes nothing returns boolean
 local integer element=f__arg_integer1

		call sc__AWidget_hide(element)
    return true
endfunction
function sa___prototype846_AStructSystemsGuiMainWindow__unaryFunctionDestroyWidget takes nothing returns boolean
 local integer element=f__arg_integer1

		if ( element != 0 ) then
			call sc__AWidget_destroy(element)
		endif
    return true
endfunction
function sa___prototype846_AStructSystemsGuiCheckBox__onHitAction takes nothing returns boolean
 local integer usedWidget=f__arg_integer1

		call sc__ACheckBox_setChecked((usedWidget),not sc__ACheckBox_isChecked((usedWidget)))
    return true
endfunction
function sa___prototype840_ALibrarySystemsDebugCharacter__questItemStateEventChat takes nothing returns boolean
    call ALibrarySystemsDebugCharacter__questItemStateEventChat(f__arg_integer1,f__arg_trigger1)
    return true
endfunction
function sa___prototype842_ALibrarySystemsDebugCharacter__questItemStateActionChat takes nothing returns boolean
 local integer abstractQuest=f__arg_integer1

		call Print("QUEST COMPLETED")
    return true
endfunction
function sa___prototype843_ALibrarySystemsDebugCharacter__talkStartActionTestTalk takes nothing returns boolean
 local integer talk=f__arg_integer1

   call Print("Start Action for talk " + I2S(talk))
		call s__ATalk_showInfo(talk,0)
   call Print("After The First Show Info")
		call s__ATalk_showInfo(talk,1)
		call s__ATalk_showInfo(talk,2)
		call s__ATalk_showExitButton(talk)
   call Print("After Show Exit Button")
		call s__ATalk_show(talk)
   call Print("After Show with Talk " + I2S(talk))
    return true
endfunction
function sa___prototype843_ALibrarySystemsDebugCharacter__talkButtonActionFuckYou takes nothing returns boolean
 local integer talk=f__arg_integer1

		call Print("Fuck You action")
		call s__ATalk_speech(talk,"Danke." , null , false)
		call Print("After Fuck You action")
    return true
endfunction
function sa___prototype843_ALibrarySystemsDebugCharacter__talkButtonActionHello takes nothing returns boolean
 local integer talk=f__arg_integer1

		call s__ATalk_showFirstPage(talk)
    return true
endfunction
function sa___prototype843_ALibrarySystemsDebugCharacter__talkButtonActionHowAreYou takes nothing returns boolean
 local integer talk=f__arg_integer1

		call s__ATalk_showFirstPage(talk)
    return true
endfunction
function sa___prototype831_ALibrarySystemsDebugCharacter__castAction takes nothing returns boolean
 local integer character=f__arg_integer1

		call Print("Cast!")
    return true
endfunction
function sa___prototype846_ALibrarySystemsDebugGui__onHitActionShowMessage takes nothing returns boolean
 local integer usedWidget=f__arg_integer1

  local player user= s__AGui_getUser(s__AMainWindow_getGui(s__AWidget_getMainWindow(usedWidget)))
		call Print("TEST LALALALALALALALA")
		call s__AGui_showInfoDialog(s__AGui_getPlayerGui(user),"Diese Informationen sind|n�u�erst interessant.")
		set user = null
    return true
endfunction
function sa___prototype837_ALibrarySystemsDebugGui__onPressGuiShortcutActionShowMessage takes nothing returns boolean
 local integer gui=f__arg_integer1

		call Print("PRESS ESCAPE")
    return true
endfunction
function sa___prototype846_AStructSystemsDebugSystemDebugger__onHitActionShowInfo takes nothing returns boolean
 local integer usedWidget=f__arg_integer1

		call s__AGui_showInfoDialog(s__AWidget_getGui(usedWidget),"Advanced Script Library")
    return true
endfunction
function sa___prototype846_AStructSystemsDebugSystemDebugger__onHitActionShowGuiSystemMainWindow takes nothing returns boolean
 local integer usedWidget=f__arg_integer1

		call s__AGui_showMainWindowByIndex(s__AWidget_getGui(usedWidget),0)
    return true
endfunction
function sa___prototype846_AStructSystemsDebugSystemDebugger__onHitActionShowCharacterSystemMainWindow takes nothing returns boolean
 local integer usedWidget=f__arg_integer1

		call s__AGui_showMainWindowByIndex(s__AWidget_getGui(usedWidget),1)
    return true
endfunction
function sa___prototype846_AStructSystemsDebugSystemDebugger__onHitActionShowWorldSystemMainWindow takes nothing returns boolean
 local integer usedWidget=f__arg_integer1

		call s__AGui_showMainWindowByIndex(s__AWidget_getGui(usedWidget),2)
    return true
endfunction
function sa___prototype846_AStructSystemsDebugSystemDebugger__onHitActionInitCharacterSystem takes nothing returns boolean
 local integer usedWidget=f__arg_integer1

    return true
endfunction

//Functions for BigArrays:
function sa__ASystemDebugger_onDestroy takes nothing returns boolean
local integer this=f__arg_this
			call s__ASystemDebugger_destroyMenuTrigger(this)
   return true
endfunction
function sa__AAbstractCharacterSystem_enable takes nothing returns boolean
local integer this=f__arg_this
   return true
endfunction
function sa__AAbstractCharacterSystem_disable takes nothing returns boolean
local integer this=f__arg_this
   return true
endfunction
function sa__AAbstractCharacterSystem_create takes nothing returns boolean
local integer character=f__arg_integer1
   local integer this= s__AAbstractCharacterSystem__allocate()
			set s__AAbstractCharacterSystem_character[this]=character
set f__result_integer= this
   return true
endfunction
function sa__AMainWindow_getGui takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= s__AMainWindow_gui[this]
   return true
endfunction
function sa__AMainWindow_getX takes nothing returns boolean
local integer this=f__arg_this
local real x=f__arg_real1
set f__result_real= ( s__AMainWindow_x[this] + x )
   return true
endfunction
function sa__AMainWindow_getY takes nothing returns boolean
local integer this=f__arg_this
local real y=f__arg_real1
set f__result_real= ( s__AMainWindow_y[this] + y )
   return true
endfunction
function sa__AMainWindow_getUser takes nothing returns boolean
local integer this=f__arg_this
set f__result_player= s__AGui_getUser(s__AMainWindow_gui[this])
   return true
endfunction
function sa__AMainWindow_showTooltip takes nothing returns boolean
local integer this=f__arg_this
local integer usedWidget=f__arg_integer1
			if ( s__AMainWindow_tooltip[this] == null ) then
				set s__AMainWindow_tooltip[this]=CreateTextTag()
			endif
			call SetTextTagTextBJ(s__AMainWindow_tooltip[this] , s__AWidget_getTooltip(usedWidget) , s__AWidget_getTooltipSize(usedWidget))
			call SetTextTagPos(s__AMainWindow_tooltip[this] , s__AWidget_getX(usedWidget) , s__AWidget_getY(usedWidget) , 0.0)
			call ShowTextTagForPlayer(s__AGui_getUser(s__AMainWindow_gui[this]) , s__AMainWindow_tooltip[this] , true) //ALibraryInterfaceTextTag
			if ( s__AMainWindow_tooltipSoundPath != null ) then
				call PlaySoundPathForPlayer(s__AGui_getUser(s__AMainWindow_gui[this]) , s__AMainWindow_tooltipSoundPath) //ALibraryEnvironmentSound
			endif
   return true
endfunction
function sa__AMainWindow_dockWidget takes nothing returns boolean
local integer this=f__arg_this
local integer usedWidget=f__arg_integer1
   local integer i= 0
			loop
				exitwhen ( i == s__AMainWindow_maxWidgets )
				if ( s__AWidgetContainer__getindex(s__AMainWindow_container[this],i) == 0 ) then
					call s__AWidgetContainer__setindex(s__AMainWindow_container[this],i, usedWidget)
set f__result_integer= i
return true
				endif
				set i = i + 1
			endloop
    call s__AMainWindow_print(this,"Could not dock widget. Maximum reached.")
set f__result_integer= - 1
   return true
endfunction
function sa__AMainWindow_undockWidget takes nothing returns boolean
local integer this=f__arg_this
local integer usedWidget=f__arg_integer1
   local integer i= 0
			loop
				exitwhen ( i == s__AMainWindow_maxWidgets )
				if ( s__AWidgetContainer__getindex(s__AMainWindow_container[this],i) == usedWidget ) then
					call s__AWidgetContainer__setindex(s__AMainWindow_container[this],i, 0)
return true
				endif
				set i = i + 1
			endloop
    call s__AMainWindow_print(this,"Could not undock widget. Widget was not found.")
   return true
endfunction
function sa__AMainWindow_show takes nothing returns boolean
local integer this=f__arg_this
   local real x= s__AMainWindow_x[this] + ( s__AMainWindow_sizeX[this] / 2.0 )
   local real y= s__AMainWindow_y[this] + ( s__AMainWindow_sizeY[this] / 2.0 )
			call s__AGui_savePlayerData(s__AMainWindow_gui[this])
			call ClearScreenMessagesForPlayer(s__AGui_getUser(s__AMainWindow_gui[this])) //ALibraryInterfaceCinematic
			call PanCameraToForPlayer(s__AGui_getUser(s__AMainWindow_gui[this]) , x , y)
			call SetCameraBoundsToPointForPlayer(s__AGui_getUser(s__AMainWindow_gui[this]) , x , y) //ALibraryInterfaceCamera
			call CameraSetupApplyForPlayer(true , s__AMainWindow_cameraSetup , s__AGui_getUser(s__AMainWindow_gui[this]) , 0.0)
			call s__AWidgetContainer_forEach(s__AMainWindow_container[this],0 , s__AMainWindow_maxWidgets , (1))
			if ( s__AMainWindow_useShortcuts[this] ) then
				call s__AGui_enableShortcuts(s__AMainWindow_gui[this])
			endif
			set s__AMainWindow_isShown[this]=true
			call s__AGui_hideShownMainWindowAndSetNew(s__AMainWindow_gui[this],this)
   return true
endfunction
function sa__AMainWindow_hide takes nothing returns boolean
local integer this=f__arg_this
			call ResetCameraBoundsToMapRectForPlayer(s__AGui_getUser(s__AMainWindow_gui[this])) //ALibraryInterfaceCamera
			call ResetToGameCameraForPlayer(s__AGui_getUser(s__AMainWindow_gui[this]) , 0.0)
			call s__AGui_loadPlayerData(s__AMainWindow_gui[this])
			call s__AMainWindow_hideTooltip(this)
			call s__AWidgetContainer_forEach(s__AMainWindow_container[this],0 , s__AMainWindow_maxWidgets , (2))
			if ( s__AMainWindow_useShortcuts[this] ) then
				call s__AGui_disableShortcuts(s__AMainWindow_gui[this])
			endif
			set s__AMainWindow_isShown[this]=false
   return true
endfunction
function sa__AMainWindow_onDestroy takes nothing returns boolean
local integer this=f__arg_this
			call DestroyTextTag(s__AMainWindow_tooltip[this])
			set s__AMainWindow_tooltip[this]=null
			if ( s__AMainWindow_shortcut[this] != 0 ) then
				call s__AHashTable_destroyTrigger(AGetInterfaceHashTable(),s__AMainWindow_shortcutTrigger[this]) //AClassInterfaceInterfaceHashTable
				set s__AMainWindow_shortcutTrigger[this]=null
			endif
			call s__AMainWindow_destroyDockedWidgets(this)
			call s__AWidgetContainer_destroy(s__AMainWindow_container[this])
			if ( s__AMainWindow_gui[this] != 0 ) then
				call s__AGui_undockMainWindow(s__AMainWindow_gui[this],this)
			endif
   return true
endfunction
function sa__AWidgetContainer_debugCheckIndex takes nothing returns boolean
local integer this=f__arg_this
local integer index=f__arg_integer1
     if ( ( index < 0 ) or ( index >= 100 ) ) then
      call Print("Wrong index of container " + I2S(this) + ": " + I2S(index) + ".")
     endif
   return true
endfunction
function sa__AShrine_onDestroy takes nothing returns boolean
local integer this=f__arg_this
			set s__AShrine_usedDestructable[this]=null
			call s__AShrine_destroyDiscoverRegion(this)
			call s__AShrine_destroyShrineTrigger(this)
			call s__AShrine_destroyDiscoverRect(this)
			call s__AShrine_destroyDiscoverEffect(this)
   return true
endfunction
function sa__AInventory__disposeArrays takes nothing returns boolean
 local integer this=f__arg_this
 local integer kthis
    set si__AInventory_arrN=si__AInventory_arrN+1
    set kthis=si__AInventory_arr[this]
    set si__AInventory_arrV[si__AInventory_arrN]=kthis
 return true
endfunction
function sa__AInventory_enable takes nothing returns boolean
local integer this=f__arg_this
			if ( s__AInventory_rucksackIsEnabled[this] ) then
				call sc__AInventory_enableRucksack(this)
			else
				call sc__AInventory_enableEquipment(this)
			endif
			call EnableTrigger(s__AInventory_openTrigger[this])
			call EnableTrigger(s__AInventory_orderTrigger[this])
			call EnableTrigger(s__AInventory_pickupTrigger[this])
			call EnableTrigger(s__AInventory_dropTrigger[this])
   return true
endfunction
function sa__AInventory_disable takes nothing returns boolean
local integer this=f__arg_this
			if ( s__AInventory_rucksackIsEnabled[this] ) then
				call sc__AInventory_disableRucksack(this)
			else
				call sc__AInventory_disableEquipment(this)
			endif
			call DisableTrigger(s__AInventory_openTrigger[this])
			call DisableTrigger(s__AInventory_orderTrigger[this])
			call DisableTrigger(s__AInventory_pickupTrigger[this])
			call DisableTrigger(s__AInventory_dropTrigger[this])
   return true
endfunction
function sa__AInventory_enableEquipment takes nothing returns boolean
local integer this=f__arg_this
   local integer i
			call DisableTrigger(s__AInventory_orderTrigger[this])
			call DisableTrigger(s__AInventory_pickupTrigger[this])
			set i = 0
			loop
				exitwhen ( i == s__AInventory_maxEquipmentTypes )
				if ( s___AInventory_equipmentItemType[s__AInventory_equipmentItemType[this]+i] != 0 ) then
					call sc__AInventory_showEquipmentItem(this,i)
				endif
				set i = i + 1
			endloop
			call EnableTrigger(s__AInventory_orderTrigger[this])
			call EnableTrigger(s__AInventory_pickupTrigger[this])
   return true
endfunction
function sa__AInventory_disableEquipment takes nothing returns boolean
local integer this=f__arg_this
   local integer i
			call DisableTrigger(s__AInventory_orderTrigger[this])
			call DisableTrigger(s__AInventory_dropTrigger[this])
			set i = 0
			loop
				exitwhen ( i == s__AInventory_maxEquipmentTypes )
				if ( s___AInventory_equipmentItemType[s__AInventory_equipmentItemType[this]+i] != 0 ) then
					call sc__AInventory_hideEquipmentItem(this,i)
				endif
				set i = i + 1
			endloop
			call EnableTrigger(s__AInventory_orderTrigger[this])
			call EnableTrigger(s__AInventory_dropTrigger[this])
   return true
endfunction
function sa__AInventory_enableRucksack takes nothing returns boolean
local integer this=f__arg_this
   local item leftArrowItem
   local item rightArrowItem
			set s__AInventory_rucksackIsEnabled[this]=true
			call DisableTrigger(s__AInventory_orderTrigger[this]) //Disable it otherwise it thinks the player wants to drop the items
			call DisableTrigger(s__AInventory_pickupTrigger[this])
			call UnitAddItemToSlotById(s__AAbstractCharacterSystem_getUnit(this) , s__AInventory_leftArrowItemType , s__AInventory_maxRucksackItemsPerPage)
			call UnitAddItemToSlotById(s__AAbstractCharacterSystem_getUnit(this) , s__AInventory_rightArrowItemType , s__AInventory_maxRucksackItemsPerPage + 1)
			set leftArrowItem = UnitItemInSlot(s__AAbstractCharacterSystem_getUnit(this) , s__AInventory_maxRucksackItemsPerPage)
			set rightArrowItem = UnitItemInSlot(s__AAbstractCharacterSystem_getUnit(this) , s__AInventory_maxRucksackItemsPerPage + 1)
			call SetItemDroppable(leftArrowItem , false)
			call SetItemDroppable(rightArrowItem , false)
			call SetItemCharges(rightArrowItem , s__AInventory_rucksackPage[this])
			set leftArrowItem = null
			set rightArrowItem = null
			call sc__AInventory_showRucksackPage(this,s__AInventory_rucksackPage[this] , true)
			call EnableTrigger(s__AInventory_orderTrigger[this])
			call EnableTrigger(s__AInventory_pickupTrigger[this])
			call EnableTrigger(s__AInventory_useTrigger[this]) //just required in rucksack
   return true
endfunction
function sa__AInventory_disableRucksack takes nothing returns boolean
local integer this=f__arg_this
   local item leftArrowItem
   local item rightArrowItem
			set s__AInventory_rucksackIsEnabled[this]=false
			call DisableTrigger(s__AInventory_orderTrigger[this])
			call DisableTrigger(s__AInventory_dropTrigger[this])
			set leftArrowItem = UnitItemInSlot(s__AAbstractCharacterSystem_getUnit(this) , s__AInventory_maxRucksackItemsPerPage)
			set rightArrowItem = UnitItemInSlot(s__AAbstractCharacterSystem_getUnit(this) , s__AInventory_maxRucksackItemsPerPage + 1)
			call RemoveItem(leftArrowItem)
			call RemoveItem(rightArrowItem)
			set leftArrowItem = null
			set rightArrowItem = null
			call sc__AInventory_hideCurrentRucksackPage(this)
			call EnableTrigger(s__AInventory_orderTrigger[this])
			call EnableTrigger(s__AInventory_dropTrigger[this])
			call DisableTrigger(s__AInventory_useTrigger[this]) //just required in rucksack
   return true
endfunction
function sa__AInventory_addItemToRucksack takes nothing returns boolean
    call s__AInventory_addItemToRucksack(f__arg_this,f__arg_item1,f__arg_boolean1)
   return true
endfunction
function sa__AInventory_getItemRucksackPage takes nothing returns boolean
local integer this=f__arg_this
local integer index=f__arg_integer1
   local integer i= 0
			loop
				exitwhen ( i == s__AInventory_maxRucksackPages )
				if ( index < i + s__AInventory_maxRucksackItemsPerPage ) then
set f__result_integer= i
return true
				endif
				set i = i + 1
			endloop
set f__result_integer= - 1
   return true
endfunction
function sa__AInventory_setEquipmentItem takes nothing returns boolean
    call s__AInventory_setEquipmentItem(f__arg_this,f__arg_item1,f__arg_integer1,f__arg_boolean1)
   return true
endfunction
function sa__AInventory_showEquipmentItem takes nothing returns boolean
local integer this=f__arg_this
local integer equipmentType=f__arg_integer1
   local item slotItem
			call UnitAddItemToSlotById(s__AAbstractCharacterSystem_getUnit(this) , s___AInventory_equipmentItemType[s__AInventory_equipmentItemType[this]+equipmentType] , equipmentType)
			set slotItem = UnitItemInSlot(s__AAbstractCharacterSystem_getUnit(this) , equipmentType)
			call s__AHashTable_storeHandleInteger(AGetCharacterHashTable(),slotItem , "AInventory_index" , equipmentType) //AClassCharacterCharacterHashTable
			set slotItem = null
   return true
endfunction
function sa__AInventory_hideEquipmentItem takes nothing returns boolean
local integer this=f__arg_this
local integer equipmentType=f__arg_integer1
   local item slotItem= UnitItemInSlot(s__AAbstractCharacterSystem_getUnit(this) , equipmentType)
			call RemoveItem(slotItem)
			set slotItem = null
   return true
endfunction
function sa__AInventory_checkEquipment takes nothing returns boolean
local integer this=f__arg_this
   local item slotItem
   local integer itemType
   local integer i= 0
			loop
				exitwhen ( i == s__AInventory_maxEquipmentTypes )
				if ( s___AInventory_equipmentItemType[s__AInventory_equipmentItemType[this]+i] != 0 ) then
					set slotItem = UnitItemInSlot(s__AAbstractCharacterSystem_getUnit(this) , i)
					set itemType = s__AItemType_getItemTypeOfItem(slotItem) //AClassCharacterItemType
      if ( itemType == 0 ) then
       call Print("AItemType of item " + GetItemName(slotItem) + " in instance " + I2S(this) + " and slot " + I2S(i) + " is 0.")
      endif
					if ( not s__AItemType_checkRequirement(itemType,s__AAbstractCharacterSystem_getCharacter(this)) ) then
						call s__AInventory_clearEquipmentItem(this,i , true)
					endif
					set slotItem = null
				endif
				set i = i + 1
			endloop
   return true
endfunction
function sa__AInventory_setRucksackItem takes nothing returns boolean
    call s__AInventory_setRucksackItem(f__arg_this,f__arg_item1,f__arg_integer1,f__arg_boolean1)
   return true
endfunction
function sa__AInventory_showRucksackPage takes nothing returns boolean
local integer this=f__arg_this
local integer page=f__arg_integer1
local boolean firstCall=f__arg_boolean1
   local integer i
   local integer exitValue
    if ( page > s__AInventory_maxRucksackPages ) then
     call Print("AInventory: Page value is too high.")
return true
    endif
			set s__AInventory_rucksackPage[this]=page
			if ( not firstCall ) then
				call sc__AInventory_hideCurrentRucksackPage(this)
			endif
			set i = page * s__AInventory_maxRucksackItemsPerPage
			set exitValue = i + s__AInventory_maxRucksackItemsPerPage
			loop
				exitwhen ( i == exitValue )
				if ( s___AInventory_rucksackItemType[s__AInventory_rucksackItemType[this]+i] != 0 ) then
					call s__AInventory_showRucksackItem(this,i)
				endif
				set i = i + 1
			endloop
   return true
endfunction
function sa__AInventory_hideCurrentRucksackPage takes nothing returns boolean
local integer this=f__arg_this
   local integer i= s__AInventory_rucksackPage[this] * s__AInventory_maxRucksackItemsPerPage
   local integer exitValue= i + s__AInventory_maxRucksackItemsPerPage
			loop
				exitwhen ( i == exitValue )
				if ( s___AInventory_rucksackItemType[s__AInventory_rucksackItemType[this]+i] != 0 ) then
					call s__AInventory_hideRucksackItem(this,i)
				endif
				set i = i + 1
			endloop
   return true
endfunction
function sa__AInventory_create takes nothing returns boolean
local integer character=f__arg_integer1
   local integer this= s__AInventory__allocate(character)
			set s__AInventory_rucksackPage[this]=0
			set s__AInventory_rucksackIsEnabled[this]=false
			call UnitAddAbility(s__AAbstractCharacterSystem_getUnit(this) , s__AInventory_openRucksackAbilityId)
			call s__AInventory_createOpenTrigger(this)
			call s__AInventory_createOrderTrigger(this)
			call s__AInventory_createPickupTrigger(this)
			call s__AInventory_createDropTrigger(this)
			call s__AInventory_createUseTrigger(this)
set f__result_integer= this
   return true
endfunction
function sa__AInventory_onDestroy takes nothing returns boolean
local integer this=f__arg_this
			call UnitRemoveAbility(s__AAbstractCharacterSystem_getUnit(this) , s__AInventory_openRucksackAbilityId)
			call s__AInventory_destroyOpenTrigger(this)
			call s__AInventory_destroyOrderTrigger(this)
			call s__AInventory_destroyPickupTrigger(this)
			call s__AInventory_destroyDropTrigger(this)
			call s__AInventory_destroyUseTrigger(this)
    set f__arg_this=this
   return true
endfunction
function sa__AWidget_getMainWindow takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= s__AWidget_mainWindow[this]
   return true
endfunction
function sa__AWidget_show takes nothing returns boolean
local integer this=f__arg_this
			call sc__AWidget_enableOnHitTrigger(this)
			call sc__AWidget_enableOnTrackTrigger(this)
			set s__AWidget_m_shown[this]=true
   return true
endfunction
function sa__AWidget_hide takes nothing returns boolean
local integer this=f__arg_this
			call sc__AWidget_disableOnHitTrigger(this)
			call sc__AWidget_disableOnTrackTrigger(this)
			set s__AWidget_m_shown[this]=false
   return true
endfunction
function sa__AWidget_enableOnHitTrigger takes nothing returns boolean
local integer this=f__arg_this
			if ( s__AWidget_onHitAction[this] != 0 ) then
				call EnableTrigger(s__AWidget_onHitTrigger[this])
			endif
   return true
endfunction
function sa__AWidget_enableOnTrackTrigger takes nothing returns boolean
local integer this=f__arg_this
			if ( s__AWidget_onTrackAction[this] != 0 ) then
				call EnableTrigger(s__AWidget_onTrackTrigger[this])
			endif
   return true
endfunction
function sa__AWidget_disableOnHitTrigger takes nothing returns boolean
local integer this=f__arg_this
			if ( s__AWidget_onHitAction[this] != 0 ) then
				call DisableTrigger(s__AWidget_onHitTrigger[this])
			endif
   return true
endfunction
function sa__AWidget_disableOnTrackTrigger takes nothing returns boolean
local integer this=f__arg_this
			if ( s__AWidget_onTrackAction[this] != 0 ) then
				call DisableTrigger(s__AWidget_onTrackTrigger[this])
			endif
   return true
endfunction
function sa__AWidget_create takes nothing returns boolean
local integer mainWindow=f__arg_integer1
local real x=f__arg_real1
local real y=f__arg_real2
local real sizeX=f__arg_real3
local real sizeY=f__arg_real4
local integer onHitAction=f__arg_integer2
local integer onTrackAction=f__arg_integer3
   local integer this= s__AWidget__allocate()
			set s__AWidget_m_shown[this]=false
			set s__AWidget_mainWindow[this]=mainWindow
			set s__AWidget_x[this]=x
			set s__AWidget_y[this]=y
			set s__AWidget_sizeX[this]=sizeX
			set s__AWidget_sizeY[this]=sizeY
			set s__AWidget_onHitAction[this]=onHitAction
			set s__AWidget_onTrackAction[this]=onTrackAction
			call s__AWidget_createTrackable(this)
			call s__AWidget_createOnHitTrigger(this)
			call s__AWidget_createOnTrackTrigger(this)
			if ( mainWindow != 0 ) then
				call sc__AMainWindow_dockWidget(mainWindow,this)
			endif
set f__result_integer= this
   return true
endfunction
function sa__AWidget_onDestroy takes nothing returns boolean
local integer this=f__arg_this
			call s__AWidget_destroyOnHitTrigger(this)
			call s__AWidget_destroyOnTrackTrigger(this)
			if ( s__AWidget_mainWindow[this] != 0 ) then
				call sc__AMainWindow_undockWidget(s__AWidget_mainWindow[this],this)
			endif
   return true
endfunction
function sa__AWidget_getTrackablePathBySize takes nothing returns boolean
local real sizeX=f__arg_real1
local real sizeY=f__arg_real2
set f__result_string= "units\\nightelf\\Wisp\\Wisp.mdx"
   return true
endfunction
function sa__AVideo_createSkipTrigger takes nothing returns boolean

   local integer i
   local player user
   local event triggerEvent
   local conditionfunc conditionFunction
   local triggercondition triggerCondition
   local triggeraction triggerAction
			set s__AVideo_skipTrigger=CreateTrigger()
			call DisableTrigger(s__AVideo_skipTrigger) //will be enabled by first running video
			set i = 0
			loop
				exitwhen ( i == bj_MAX_PLAYERS )
				set user = Player(i)
				if ( IsPlayerPlayingUser(user) ) then
      call s__AVideo_staticPrint("Create skip trigger for player " + I2S(i) + ".")
					set triggerEvent = TriggerRegisterKeyEventForPlayer(user , s__AVideo_skipTrigger , KEY_RIGHT , true) //ALibraryInterfaceMisc, important: If it is the escape key it is the same key as in the character selection.
					set triggerEvent = null
				endif
				set user = null
				set i = i + 1
			endloop
			set conditionFunction = Condition(function s__AVideo_triggerConditionSkip)
			set triggerCondition = TriggerAddCondition(s__AVideo_skipTrigger , conditionFunction)
			set triggerAction = TriggerAddAction(s__AVideo_skipTrigger , function s__AVideo_triggerActionSkip)
			set triggerEvent = null
			set conditionFunction = null
			set triggerCondition = null
			set triggerAction = null
   return true
endfunction
function sa__ATalk_getCharacter takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= s__ATalk_character[this]
   return true
endfunction
function sa__ATalk_speech takes nothing returns boolean
    call s__ATalk_speech(f__arg_this,f__arg_string1,f__arg_sound1,f__arg_boolean1)
   return true
endfunction
function sa__ATalk_showFirstPage takes nothing returns boolean
local integer this=f__arg_this
			call s__ATalk_clear(this)
			call sc___prototype843_execute(s__ATalk_startAction[this],this) //create buttons
   return true
endfunction
function sa__ATalk_hide takes nothing returns boolean
local integer this=f__arg_this
			call s__AGui_hideDialog(s__AGui_getPlayerGui(s__ACharacter_getUser(s__ATalk_character[this])))
   return true
endfunction
function sa__ATalk_disable takes nothing returns boolean
local integer this=f__arg_this
			call s__AGui_hideDialog(s__AGui_getPlayerGui(s__ACharacter_getUser(s__ATalk_character[this])))
			call sc__ATalk_resetFacings(this)
			call SetUserInterfaceForPlayer(s__ACharacter_getUser(s__ATalk_character[this]) , true , true)
			call ResetToGameCameraForPlayer(s__ACharacter_getUser(s__ATalk_character[this]) , 0.0)
			call s__ACharacter_setTalk(s__ATalk_character[this],0)
			call s__ACharacter_setMovable(s__ATalk_character[this],true)
			set s__ATalk_character[this]=0
			call PauseUnit(s__ATalk_usedUnit[this] , false) //Disables routines or something else
   return true
endfunction
function sa__ATalk_addButton takes nothing returns boolean
local integer this=f__arg_this
local string text=f__arg_string1
local integer buttonAction=f__arg_integer1
local integer info=f__arg_integer2
   local integer id= s__ATalk_buttons[this]
    if ( id == s__ATalk_maxButtons ) then
     call s__ATalk_print(this,"Button maximum reached.")
return true
    endif
			if ( s__AGui_addDialogButton(s__AGui_getPlayerGui(s__ACharacter_getUser(s__ATalk_character[this])),"[" + I2S(s__ATalk_buttons[this] + 1) + "] " + text , id + SHORTCUT_1 , (1)) != - 1 ) then //AClassGuiGui, ALibraryInterfaceMisc
				set s__ATalk_buttons[this]=s__ATalk_buttons[this] + 1
				set s___ATalk_buttonAction[s__ATalk_buttonAction[this]+id]=buttonAction
				set s___ATalk_buttonInfo[s__ATalk_buttonInfo[this]+id]=info
			endif
   return true
endfunction
function sa__ATalk_runButtonAction takes nothing returns boolean
local integer this=f__arg_this
local integer index=f__arg_integer1
			if ( s___ATalk_buttonInfo[s__ATalk_buttonInfo[this]+index] != 0 ) then
				call s__ATalk_hide(this)
				call s__AStructSystemsCharacterTalk___AInfo_run(s___ATalk_buttonInfo[s__ATalk_buttonInfo[this]+index])
			endif
			if ( s___ATalk_buttonAction[s__ATalk_buttonAction[this]+index] != 0 ) then
				call sc___prototype843_execute(s___ATalk_buttonAction[s__ATalk_buttonAction[this]+index],this)
			else
				call s__ATalk_showFirstPage(this)
			endif
   return true
endfunction
function sa__ATalk_wait takes nothing returns boolean
    call s__ATalk_wait(f__arg_this,f__arg_sound1)
   return true
endfunction
function sa__ATalk_refreshView takes nothing returns boolean
local integer this=f__arg_this
local boolean toCharacter=f__arg_boolean1
			call CameraSetupApplyForPlayer(true , s__ATalk_cameraSetup , s__ACharacter_getUser(s__ATalk_character[this]) , 0.0)
			if ( toCharacter ) then
				call SetCameraFieldForPlayer(s__ACharacter_getUser(s__ATalk_character[this]) , CAMERA_FIELD_ROTATION , GetUnitFacing(s__ATalk_usedUnit[this]) - 180.0 , 0.0)
				call SetCameraFieldForPlayer(s__ACharacter_getUser(s__ATalk_character[this]) , CAMERA_FIELD_ZOFFSET , CameraSetupGetField(s__ATalk_cameraSetup , CAMERA_FIELD_ZOFFSET) + GetUnitFlyHeight(s__ATalk_usedUnit[this]) , 0.0)
				call SetCameraTargetControllerNoZForPlayer(s__ACharacter_getUser(s__ATalk_character[this]) , s__ATalk_usedUnit[this] , 0.0 , 0.0 , false)
			else
				call SetCameraFieldForPlayer(s__ACharacter_getUser(s__ATalk_character[this]) , CAMERA_FIELD_ROTATION , GetUnitFacing(s__ACharacter_getUsedUnit(s__ATalk_character[this])) - 180.0 , 0.0)
				call SetCameraFieldForPlayer(s__ACharacter_getUser(s__ATalk_character[this]) , CAMERA_FIELD_ZOFFSET , CameraSetupGetField(s__ATalk_cameraSetup , CAMERA_FIELD_ZOFFSET) + GetUnitFlyHeight(s__ACharacter_getUsedUnit(s__ATalk_character[this])) , 0.0)
				call SetCameraTargetControllerNoZForPlayer(s__ACharacter_getUser(s__ATalk_character[this]) , s__ACharacter_getUsedUnit(s__ATalk_character[this]) , 0.0 , 0.0 , false)
			endif
   return true
endfunction
function sa__ATalk_refreshFacings takes nothing returns boolean
local integer this=f__arg_this
			call SetUnitFacing(s__ACharacter_getUsedUnit(s__ATalk_character[this]) , GetAngleBetweenUnits(s__ACharacter_getUsedUnit(s__ATalk_character[this]) , s__ATalk_usedUnit[this])) //ALibraryMathsHandle
			call SetUnitFacing(s__ATalk_usedUnit[this] , GetAngleBetweenUnits(s__ACharacter_getUsedUnit(s__ATalk_character[this]) , s__ATalk_usedUnit[this]) - 180.0) //ALibraryMathsHandle
			call SetUnitLookAt(s__ACharacter_getUsedUnit(s__ATalk_character[this]) , "bone_head" , s__ATalk_usedUnit[this] , 0.0 , 0.0 , GetUnitFlyHeight(s__ATalk_usedUnit[this]) + 90.0)
			call SetUnitLookAt(s__ATalk_usedUnit[this] , "bone_head" , s__ACharacter_getUsedUnit(s__ATalk_character[this]) , 0.0 , 0.0 , GetUnitFlyHeight(s__ACharacter_getUsedUnit(s__ATalk_character[this])) + 90.0)
   return true
endfunction
function sa__ATalk_resetFacings takes nothing returns boolean
local integer this=f__arg_this
			call ResetUnitLookAt(s__ACharacter_getUsedUnit(s__ATalk_character[this]))
			call ResetUnitLookAt(s__ATalk_usedUnit[this])
   return true
endfunction
function sa__ATalk_resetAnimations takes nothing returns boolean
local integer this=f__arg_this
			call ResetUnitAnimation(s__ACharacter_getUsedUnit(s__ATalk_character[this]))
			call ResetUnitAnimation(s__ATalk_usedUnit[this])
   return true
endfunction
function sa__ATalk_onDestroy takes nothing returns boolean
local integer this=f__arg_this
			call s__ATalk_destroyOrderTrigger(this)
			call s__ATalk_destroyEffect(this)
			call s__ATalk_destroyInfos(this)
   return true
endfunction
function sa__ATalk_createSkipTrigger takes nothing returns boolean

   local integer i
   local player user
   local event triggerEvent
   local triggeraction triggerAction
			set s__ATalk_skipTrigger=CreateTrigger()
			set i = 0
			loop
				exitwhen ( i == bj_MAX_PLAYERS )
				set user = Player(i)
				if ( IsPlayerPlayingUser(user) ) then //ALibraryGeneralPlayer
					set triggerEvent = TriggerRegisterKeyEventForPlayer(user , s__ATalk_skipTrigger , s__ATalk_skipKey , true) //ALibraryInterfaceMisc
					set triggerEvent = null
				endif
				set user = null
				set i = i + 1
			endloop
			set triggerAction = TriggerAddAction(s__ATalk_skipTrigger , function s__ATalk_triggerActionSkip)
			set triggerAction = null
   return true
endfunction
function sa__ATalk_getTime takes nothing returns boolean
    set f__result_real=s__ATalk_getTime(f__arg_sound1)
   return true
endfunction
function sa__AStructSystemsCharacterTalk___AInfo_onDestroy takes nothing returns boolean
local integer this=f__arg_this
			set s__AStructSystemsCharacterTalk___AInfo_usedSound[this]=null
   return true
endfunction
function sa__ARevival_enable takes nothing returns boolean
local integer this=f__arg_this
			call EnableTrigger(s__ARevival_revivalTrigger[this])
			if ( TimerGetRemaining(s__ARevival_usedTimer[this]) > 0.0 ) then
				call PauseTimerBJ(false , s__ARevival_usedTimer[this])
				if ( s__ARevival_showDialog ) then //Der bersicht halber nicht in die Funktion bergeben
					call TimerDialogDisplay(s__ARevival_timerDialog[this] , true)
				endif
			endif
   return true
endfunction
function sa__ARevival_disable takes nothing returns boolean
local integer this=f__arg_this
			call DisableTrigger(s__ARevival_revivalTrigger[this])
			if ( TimerGetRemaining(s__ARevival_usedTimer[this]) > 0.0 ) then
				call PauseTimerBJ(true , s__ARevival_usedTimer[this])
				if ( s__ARevival_showDialog ) then
					call TimerDialogDisplay(s__ARevival_timerDialog[this] , false)
				endif
			endif
   return true
endfunction
function sa__ARevival_end takes nothing returns boolean
local integer this=f__arg_this
			call PauseTimerBJ(true , s__ARevival_usedTimer[this]) //Zur Sicherheit auch stoppen
			if ( s__ARevival_showDialog ) then
				call TimerDialogDisplay(s__ARevival_timerDialog[this] , false)
			endif
   return true
endfunction
function sa__ARevival_create takes nothing returns boolean
local integer character=f__arg_integer1
   local integer this= s__ARevival__allocate(character)
			call s__ARevival_createTimer(this)
			call s__ARevival_createRevivalTrigger(this)
set f__result_integer= this
   return true
endfunction
function sa__ARevival_onDestroy takes nothing returns boolean
local integer this=f__arg_this
			call s__ARevival_destroyTimer(this)
			call s__ARevival_destroyRevivalTrigger(this)
    set f__arg_this=this
   return true
endfunction
function sa__AMovement__disposeArrays takes nothing returns boolean
 local integer this=f__arg_this
 local integer kthis
    set si__AMovement_arrN=si__AMovement_arrN+1
    set kthis=si__AMovement_arr[this]
    set si__AMovement_arrV[si__AMovement_arrN]=kthis
 return true
endfunction
function sa__AMovement_enable takes nothing returns boolean
local integer this=f__arg_this
   local integer i
			call EnableTrigger(s__AMovement_movementTrigger[this])
			set i = 0
			loop
				exitwhen ( i == s__AMovement_maxMovementTriggers )
				call EnableTrigger(s___AMovement_startMovementTrigger[s__AMovement_startMovementTrigger[this]+i])
				set i = i + 1
			endloop
   return true
endfunction
function sa__AMovement_disable takes nothing returns boolean
local integer this=f__arg_this
   local integer i
			call DisableTrigger(s__AMovement_movementTrigger[this])
			set i = 0
			loop
				exitwhen ( i == s__AMovement_maxMovementTriggers )
				call DisableTrigger(s___AMovement_startMovementTrigger[s__AMovement_startMovementTrigger[this]+i])
				set i = i + 1
			endloop
   return true
endfunction
function sa__AMovement_create takes nothing returns boolean
local integer character=f__arg_integer1
   local integer this= s__AMovement__allocate(character)
			call s__AMovement_createMovementTriggers(this)
			call s__AMovement_createFpsTriggerUp(this)
			call s__AMovement_createFpsTriggerDown(this)
set f__result_integer= this
   return true
endfunction
function sa__AMovement_onDestroy takes nothing returns boolean
local integer this=f__arg_this
			call s__AMovement_destroyKeyMovementTriggers(this)
			call s__AMovement_destroyFpsTriggerUp(this)
			call s__AMovement_destroyFpsTriggerDown(this)
    set f__arg_this=this
   return true
endfunction
function sa__AItemType_onDestroy takes nothing returns boolean
local integer this=f__arg_this
			call s__AHashTable_flushStoredInteger(AGetCharacterHashTable(),"AItemTypes" , I2S(s__AItemType_itemType[this])) //AClassCharacterCharacterHashTable
   return true
endfunction
function sa__AFocus_enable takes nothing returns boolean
local integer this=f__arg_this
			call EnableTrigger(s__AFocus_focusTrigger[this])
			call ShowTextTagForPlayer(s__AAbstractCharacterSystem_getUser(this) , s__AFocus_textTag[this] , true) //ALibraryInterfaceTextTag
			call EnableTrigger(s__AFocus_workerTrigger[this])
   return true
endfunction
function sa__AFocus_disable takes nothing returns boolean
local integer this=f__arg_this
			call DisableTrigger(s__AFocus_focusTrigger[this])
			call ShowTextTagForPlayer(s__AAbstractCharacterSystem_getUser(this) , s__AFocus_textTag[this] , false) //ALibraryInterfaceTextTag
			call DisableTrigger(s__AFocus_workerTrigger[this])
   return true
endfunction
function sa__AFocus_create takes nothing returns boolean
local integer character=f__arg_integer1
   local integer this= s__AFocus__allocate(character)
			set s__AFocus_fixedTarget[this]=false
			call s__AFocus_createFocusTrigger(this)
			call s__AFocus_createTextTag(this)
			call s__AFocus_createWorkerTrigger(this)
set f__result_integer= this
   return true
endfunction
function sa__AFocus_onDestroy takes nothing returns boolean
local integer this=f__arg_this
			call s__AFocus_destroyFocusTrigger(this)
			call s__AFocus_destroyTextTag(this)
			call s__AFocus_destroyWorkerTrigger(this)
    set f__arg_this=this
   return true
endfunction
function sa__AClassSelection_createUnit takes nothing returns boolean
local integer this=f__arg_this
			if ( s__AClassSelection_classUnit[this] != null ) then
				call RemoveUnit(s__AClassSelection_classUnit[this])
				set s__AClassSelection_classUnit[this]=null
			endif
			set s__AClassSelection_classUnit[this]=CreateUnit(s__AClassSelection_user[this] , s__AClass_getUnitType(s__AClassSelection_class[this]) , s__AClassSelection_x , s__AClassSelection_y , s__AClassSelection_facing) //AClassCharacterClass
			call SetUnitInvulnerable(s__AClassSelection_classUnit[this] , true)
			call PauseUnit(s__AClassSelection_classUnit[this] , true)
			call SetUnitAnimation(s__AClassSelection_classUnit[this] , s__AClass_getAnimation(s__AClassSelection_class[this])) //AClassCharacterClass
			call PlaySoundPathForPlayer(s__AClassSelection_user[this] , s__AClass_getSoundPath(s__AClassSelection_class[this])) //AClassCharacterClass
			call s__AClassSelection_refreshInfoSheet(this)
   return true
endfunction
function sa__AClassSelection_onDestroy takes nothing returns boolean
local integer this=f__arg_this
			set s__AClassSelection_user[this]=null
			set s__AClassSelection_stack=s__AClassSelection_stack - 1
			call s__AClassSelection_destroyRefreshTrigger(this)
			call s__AClassSelection_destroyChangePreviousTrigger(this)
			call s__AClassSelection_destroyChangeNextTrigger(this)
			call s__AClassSelection_destroySelectTrigger(this)
			call s__AClassSelection_destroyInfoSheet(this)
			call s__AClassSelection_removeClassUnit(this)
   return true
endfunction
function sa__ACharactersScheme_onDestroy takes nothing returns boolean
local integer this=f__arg_this
   return true
endfunction
function sa__ACharactersScheme_createMultiboard takes nothing returns boolean

   local integer i
   local player user
   local multiboarditem multiboardItem
			set s__ACharactersScheme_usedMultiboard=CreateMultiboard()
			call MultiboardSetTitleText(s__ACharactersScheme_usedMultiboard , s__ACharactersScheme_textTitle)
			call MultiboardSetColumnCount(s__ACharactersScheme_usedMultiboard , 3)
			set i = 0
			loop
				exitwhen ( i == bj_MAX_PLAYERS )
				set user = Player(i)
				if ( IsPlayerPlayingUser(user) ) then //ALibraryGeneralPlayer
					set multiboardItem = MultiboardGetItem(s__ACharactersScheme_usedMultiboard , i , 0)
					call MultiboardSetItemWidth(multiboardItem , 20.0) /// @todo check it
					call MultiboardSetItemStyle(multiboardItem , true , false)
					call MultiboardReleaseItem(multiboardItem)
					set multiboardItem = null
					set s__s__ACharactersScheme_hitPointsBar[i]= s__AMultiboardBar_create(s__ACharactersScheme_usedMultiboard , 1 , i , 10 , 0.0 , true , GetUnitState(s__ACharacter_getUsedUnit(s__ACharacter_getPlayerCharacter(user)) , UNIT_STATE_LIFE) , GetUnitState(s__ACharacter_getUsedUnit(s__ACharacter_getPlayerCharacter(user)) , UNIT_STATE_MAX_LIFE) , 0 , 0)
					call s__AMultiboardBar_setAllIcons(s__s__ACharactersScheme_hitPointsBar[i],"Icons\\Interface\\Bars\\White.blp" , false) //empty icons
					call s__AMultiboardBar_setAllIcons(s__s__ACharactersScheme_hitPointsBar[i],"Icons\\Interface\\Bars\\Green.blp" , true)
					set s__s__ACharactersScheme_manaBar[i]= s__AMultiboardBar_create(s__ACharactersScheme_usedMultiboard , s__AMultiboardBar_getFirstFreeField(s__s__ACharactersScheme_hitPointsBar[i]) , i , 10 , 0.0 , true , GetUnitState(s__ACharacter_getUsedUnit(s__ACharacter_getPlayerCharacter(user)) , UNIT_STATE_MANA) , GetUnitState(s__ACharacter_getUsedUnit(s__ACharacter_getPlayerCharacter(user)) , UNIT_STATE_MAX_MANA) , 0 , 0)
					call s__AMultiboardBar_setAllIcons(s__s__ACharactersScheme_manaBar[i],"Icons\\Interface\\Bars\\White.blp" , false) //empty icons
					call s__AMultiboardBar_setAllIcons(s__s__ACharactersScheme_manaBar[i],"Icons\\Interface\\Bars\\Blue.blp" , true)
					set s__ACharactersScheme_maxPlayers=i + 1
				endif
				set i = i + 1
			endloop
   return true
endfunction
function sa__ACharactersScheme_createRefreshTrigger takes nothing returns boolean

   local event triggerEvent
   local triggeraction triggerAction
			set s__ACharactersScheme_refreshTrigger=CreateTrigger()
			set triggerEvent = TriggerRegisterTimerEvent(s__ACharactersScheme_refreshTrigger , s__ACharactersScheme_refreshRate , true)
			set triggerAction = TriggerAddAction(s__ACharactersScheme_refreshTrigger , function s__ACharactersScheme_triggerActionRefresh)
			set triggerEvent = null
			set triggerAction = null
    call Print("After refresh trigger creation with refresh rate " + R2S(s__ACharactersScheme_refreshRate))
   return true
endfunction
function sa__AAbstractQuest_setState takes nothing returns boolean
local integer this=f__arg_this
local integer state=f__arg_integer1
    if ( ( state >= s__AAbstractQuest_stateNew ) and ( state < s__AAbstractQuest_maxStates ) ) then
				if ( s___AAbstractQuest_stateTrigger[s__AAbstractQuest_stateTrigger[this]+state] == null ) then
					if ( s___AAbstractQuest_stateCondition[s__AAbstractQuest_stateCondition[this]+state] != 0 and not sc___prototype841_evaluate(s___AAbstractQuest_stateCondition[s__AAbstractQuest_stateCondition[this]+state],this) ) then
return true
					endif
					if ( s___AAbstractQuest_stateAction[s__AAbstractQuest_stateAction[this]+state] != 0 ) then
						call sc___prototype842_execute(s___AAbstractQuest_stateAction[s__AAbstractQuest_stateAction[this]+state],this) //call custom function
					endif
				endif
				set s__AAbstractQuest_state[this]=state
     call Print("Set state to " + I2S(state))
				call sc__AAbstractQuest_displayMessage(this)
     call Print("After displaying message")
				if ( state == s__AAbstractQuest_stateNew ) then
      call Print("Enable")
					call sc__AAbstractQuest_enable(this)
				elseif ( state == s__AAbstractQuest_stateCompleted ) then
					call sc__AAbstractQuest_distributeRewards(this)
					call sc__AAbstractQuest_disable(this) //disable
				elseif ( state == s__AAbstractQuest_stateCompleted ) then
					call sc__AAbstractQuest_disable(this) //disable
				endif
    else
     call Print("Invalid quest state in quest " + I2S(this) + ".") //ALibraryGeneralDebug
    endif
   return true
endfunction
function sa__AAbstractQuest_enable takes nothing returns boolean
local integer this=f__arg_this
			call sc__AAbstractQuest_enableStateTriggers(this)
			call sc__AAbstractQuest_enablePingTrigger(this)
   return true
endfunction
function sa__AAbstractQuest_disable takes nothing returns boolean
local integer this=f__arg_this
			call sc__AAbstractQuest_disableStateTriggers(this)
			call sc__AAbstractQuest_disablePingTrigger(this)
   return true
endfunction
function sa__AAbstractQuest_enableStateTriggers takes nothing returns boolean
local integer this=f__arg_this
   local integer i= 0
			loop
				exitwhen ( i == s__AAbstractQuest_maxStates )
				if ( s___AAbstractQuest_stateTrigger[s__AAbstractQuest_stateTrigger[this]+i] != null ) then
					call EnableTrigger(s___AAbstractQuest_stateTrigger[s__AAbstractQuest_stateTrigger[this]+i])
      call Print("Enable state trigger " + I2S(i))
				endif
				set i = i + 1
			endloop
   return true
endfunction
function sa__AAbstractQuest_enablePingTrigger takes nothing returns boolean
local integer this=f__arg_this
			if ( s__AAbstractQuest_pingRate[this] != 0.0 ) then
				call EnableTrigger(s__AAbstractQuest_pingTrigger[this])
			endif
   return true
endfunction
function sa__AAbstractQuest_disableStateTriggers takes nothing returns boolean
local integer this=f__arg_this
   local integer i= 0
			loop
				exitwhen ( i == s__AAbstractQuest_maxStates )
				if ( s___AAbstractQuest_stateTrigger[s__AAbstractQuest_stateTrigger[this]+i] != null ) then
					call DisableTrigger(s___AAbstractQuest_stateTrigger[s__AAbstractQuest_stateTrigger[this]+i])
				endif
				set i = i + 1
			endloop
   return true
endfunction
function sa__AAbstractQuest_disablePingTrigger takes nothing returns boolean
local integer this=f__arg_this
			if ( s__AAbstractQuest_pingRate[this] != 0.0 ) then
				call DisableTrigger(s__AAbstractQuest_pingTrigger[this])
			endif
   return true
endfunction
function sa__AAbstractQuest_displayMessage takes nothing returns boolean
local integer this=f__arg_this
			if ( s__AAbstractQuest_character[this] != 0 ) then
				call s__ACharacter_displayMessage(s__AAbstractQuest_character[this],s__ACharacter_messageTypeInfo , s__AAbstractQuest_getModifiedTitle(this)) //AClassCharacterCharacter
				call PlaySoundPathForPlayer(s__ACharacter_getUser(s__AAbstractQuest_character[this]) , s__AAbstractQuest_getSoundPath(this)) //ALibraryEnvironmentSound
			else
				call s__ACharacter_displayMessageToAll(s__ACharacter_messageTypeInfo , s__AAbstractQuest_getModifiedTitle(this)) //AClassCharacterCharacter
				call PlaySound(s__AAbstractQuest_getSoundPath(this))
			endif
   return true
endfunction
function sa__AAbstractQuest_distributeRewards takes nothing returns boolean
local integer this=f__arg_this
   local integer i
			if ( s__AAbstractQuest_character[this] != 0 ) then
				if ( s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardLevel] != 0 ) then
					call s__ACharacter_addLevels(s__AAbstractQuest_character[this],s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardLevel] , true)
				endif
				if ( s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardSkillPoints] != 0 ) then
					call s__ACharacter_addSkillPoints(s__AAbstractQuest_character[this],s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardSkillPoints])
				endif
				if ( s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardExperience] != 0 ) then
					call s__ACharacter_addExperience(s__AAbstractQuest_character[this],s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardExperience] , true)
				endif
				if ( s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardStrength] != 0 ) then
					call s__ACharacter_addStrength(s__AAbstractQuest_character[this],s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardStrength])
				endif
				if ( s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardAgility] != 0 ) then
					call s__ACharacter_addAgility(s__AAbstractQuest_character[this],s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardAgility])
				endif
				if ( s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardIntelligence] != 0 ) then
					call s__ACharacter_addIntelligence(s__AAbstractQuest_character[this],s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardIntelligence])
				endif
				if ( s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardGold] != 0 ) then
					call s__ACharacter_addGold(s__AAbstractQuest_character[this],s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardGold])
				endif
				if ( s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardLumber] != 0 ) then
					call s__ACharacter_addLumber(s__AAbstractQuest_character[this],s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardLumber])
				endif
			else
				if ( s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardLevel] != 0 ) then
					call s__ACharacter_addLevelsToAll(s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardLevel] , true)
				endif
				if ( s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardSkillPoints] != 0 ) then
					call s__ACharacter_addSkillPointsToAll(s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardSkillPoints])
				endif
				if ( s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardExperience] != 0 ) then
					call s__ACharacter_addExperienceToAll(s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardExperience] , true)
				endif
				if ( s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardStrength] != 0 ) then
					call s__ACharacter_addStrengthToAll(s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardStrength])
				endif
				if ( s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardAgility] != 0 ) then
					call s__ACharacter_addAgilityToAll(s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardAgility])
				endif
				if ( s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardIntelligence] != 0 ) then
					call s__ACharacter_addIntelligenceToAll(s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardIntelligence])
				endif
				if ( s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardGold] != 0 ) then
					call s__ACharacter_addGoldToAll(s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardGold])
				endif
				if ( s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardLumber] != 0 ) then
					call s__ACharacter_addLumberToAll(s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+s__AAbstractQuest_rewardLumber])
				endif
			endif
			set i = s__AAbstractQuest_rewardLevel
			loop
				exitwhen ( i == s__AAbstractQuest_maxRewards )
				if ( s___AAbstractQuest_reward[s__AAbstractQuest_reward[this]+i] != 0 ) then
					call s__AAbstractQuest_displayRewardMessage(this,i)
				endif
				set i = i + 1
			endloop
   return true
endfunction
function sa__AAbstractQuest_triggerConditionRunQuestState takes nothing returns boolean

   local trigger triggeringTrigger= GetTriggeringTrigger()
   local integer abstractQuest= s__AHashTable_getHandleInteger(AGetCharacterHashTable(),triggeringTrigger , "abstractQuest") //AClassCharacterCharacterHashTable
   local integer state= s__AHashTable_getHandleInteger(AGetCharacterHashTable(),triggeringTrigger , "state") //AClassCharacterCharacterHashTable
    call Print("Handle id: " + I2S(H2I(triggeringTrigger)))
			set triggeringTrigger = null
    call Print("QUEST CONDITION for abstract quest " + I2S(abstractQuest) + " with state " + I2S(state))
set f__result_boolean= sc___prototype841_evaluate(s___AAbstractQuest_stateCondition[s__AAbstractQuest_stateCondition[abstractQuest]+state],abstractQuest)
   return true
endfunction
function sa__AAbstractQuest_triggerActionRunQuestState takes nothing returns boolean

   local trigger triggeringTrigger= GetTriggeringTrigger()
   local integer abstractQuest= s__AHashTable_getHandleInteger(AGetCharacterHashTable(),triggeringTrigger , "abstractQuest")
   local integer state= s__AHashTable_getHandleInteger(AGetCharacterHashTable(),triggeringTrigger , "state")
    call Print("ACTION for abstract quest " + I2S(abstractQuest) + " with state " + I2S(state))
			call sc__AAbstractQuest_setState(abstractQuest,state) //custom function will be called in this method
			set triggeringTrigger = null
   return true
endfunction
function sa__AAbstractQuest_create takes nothing returns boolean
local integer character=f__arg_integer1
local string title=f__arg_string1
local real pingRate=f__arg_real1
   local integer this= s__AAbstractQuest__allocate()
			set s__AAbstractQuest_character[this]=character
			set s__AAbstractQuest_title[this]=title
			set s__AAbstractQuest_pingRate[this]=pingRate
			set s__AAbstractQuest_state[this]=s__AAbstractQuest_stateNotUsed
			call s__AAbstractQuest_setupStateTriggers(this)
			call s__AAbstractQuest_createPingTrigger(this)
set f__result_integer= this
   return true
endfunction
function sa__AAbstractQuest_onDestroy takes nothing returns boolean
local integer this=f__arg_this
			call s__AAbstractQuest_destroyStateTriggers(this)
			call s__AAbstractQuest_destroyPingTrigger(this)
   return true
endfunction
function sa__ASpawnPoint_onDestroy takes nothing returns boolean
local integer this=f__arg_this
			call RemoveUnit(s__ASpawnPoint_spawnedUnit[this])
			set s__ASpawnPoint_spawnedUnit[this]=null
			set s__ASpawnPoint_unitPool[this]=null
			set s__ASpawnPoint_itemPool[this]=null
			call s__ASpawnPoint_destroyDeathTrigger(this)
			call s__ASpawnPoint_destroySpawnTimer(this)
   return true
endfunction
function sa__ARoutine_onDestroy takes nothing returns boolean
local integer this=f__arg_this
			set s__ARoutine_usedUnit[this]=null
			call s__ARoutine_destroyRunTrigger(this)
			call s__ARoutine_destroyEnableTrigger(this)
			call s__ARoutine_destroyDisableTrigger(this)
   return true
endfunction
function sa__AGui_enableSpecialShortcutTriggers takes nothing returns boolean
local integer this=f__arg_this
   local integer i= 0
			loop
				exitwhen ( i == s__AGui_maxSpecialShortcuts )
					if ( s___AGui_specialShortcutHandleTrigger[s__AGui_specialShortcutHandleTrigger[this]+i] != null ) then
						call EnableTrigger(s___AGui_specialShortcutHandleTrigger[s__AGui_specialShortcutHandleTrigger[this]+i])
					endif
				set i = i + 1
			endloop
   return true
endfunction
function sa__AGui_disableSpecialShortcutTriggers takes nothing returns boolean
local integer this=f__arg_this
   local integer i= 0
			loop
				exitwhen ( i == s__AGui_maxSpecialShortcuts )
					if ( s___AGui_specialShortcutHandleTrigger[s__AGui_specialShortcutHandleTrigger[this]+i] != null ) then
						call DisableTrigger(s___AGui_specialShortcutHandleTrigger[s__AGui_specialShortcutHandleTrigger[this]+i])
					endif
				set i = i + 1
			endloop
   return true
endfunction
function sa__AGui_createSpecialShortcutTrigger takes nothing returns boolean
local integer this=f__arg_this
local integer shortcut=f__arg_integer1
   local event triggerEvent
   local triggeraction triggerAction
			if ( s___AGui_specialShortcutHandleTrigger[s__AGui_specialShortcutHandleTrigger[this]+shortcut] == null ) then
				set s___AGui_specialShortcutHandleTrigger[s__AGui_specialShortcutHandleTrigger[this]+shortcut]=CreateTrigger()
				if ( shortcut == s__AGui_shortcutArrowUpDown ) then
					set triggerEvent = TriggerRegisterPlayerEvent(s___AGui_specialShortcutHandleTrigger[s__AGui_specialShortcutHandleTrigger[this]+shortcut] , s__AGui_user[this] , EVENT_PLAYER_ARROW_UP_DOWN)
				elseif ( shortcut == s__AGui_shortcutArrowDownDown ) then
					set triggerEvent = TriggerRegisterPlayerEvent(s___AGui_specialShortcutHandleTrigger[s__AGui_specialShortcutHandleTrigger[this]+shortcut] , s__AGui_user[this] , EVENT_PLAYER_ARROW_DOWN_DOWN)
				elseif ( shortcut == s__AGui_shortcutArrowLeftDown ) then
					set triggerEvent = TriggerRegisterPlayerEvent(s___AGui_specialShortcutHandleTrigger[s__AGui_specialShortcutHandleTrigger[this]+shortcut] , s__AGui_user[this] , EVENT_PLAYER_ARROW_LEFT_DOWN)
				elseif ( shortcut == s__AGui_shortcutArrowRightDown ) then
					set triggerEvent = TriggerRegisterPlayerEvent(s___AGui_specialShortcutHandleTrigger[s__AGui_specialShortcutHandleTrigger[this]+shortcut] , s__AGui_user[this] , EVENT_PLAYER_ARROW_RIGHT_DOWN)
				elseif ( shortcut == s__AGui_shortcutArrowUpUp ) then
					set triggerEvent = TriggerRegisterPlayerEvent(s___AGui_specialShortcutHandleTrigger[s__AGui_specialShortcutHandleTrigger[this]+shortcut] , s__AGui_user[this] , EVENT_PLAYER_ARROW_UP_UP)
				elseif ( shortcut == s__AGui_shortcutArrowDownUp ) then
					set triggerEvent = TriggerRegisterPlayerEvent(s___AGui_specialShortcutHandleTrigger[s__AGui_specialShortcutHandleTrigger[this]+shortcut] , s__AGui_user[this] , EVENT_PLAYER_ARROW_DOWN_UP)
				elseif ( shortcut == s__AGui_shortcutArrowLeftUp ) then
					set triggerEvent = TriggerRegisterPlayerEvent(s___AGui_specialShortcutHandleTrigger[s__AGui_specialShortcutHandleTrigger[this]+shortcut] , s__AGui_user[this] , EVENT_PLAYER_ARROW_LEFT_UP)
				elseif ( shortcut == s__AGui_shortcutArrowRightUp ) then
					set triggerEvent = TriggerRegisterPlayerEvent(s___AGui_specialShortcutHandleTrigger[s__AGui_specialShortcutHandleTrigger[this]+shortcut] , s__AGui_user[this] , EVENT_PLAYER_ARROW_RIGHT_UP)
				elseif ( shortcut == s__AGui_shortcutEscape ) then
					set triggerEvent = TriggerRegisterPlayerEvent(s___AGui_specialShortcutHandleTrigger[s__AGui_specialShortcutHandleTrigger[this]+shortcut] , s__AGui_user[this] , EVENT_PLAYER_END_CINEMATIC)
				endif
				set triggerAction = TriggerAddAction(s___AGui_specialShortcutHandleTrigger[s__AGui_specialShortcutHandleTrigger[this]+shortcut] , function s__AGui_triggerActionOnPressSpecialShortcut)
				call s__AHashTable_storeHandleInteger(AGetInterfaceHashTable(),s___AGui_specialShortcutHandleTrigger[s__AGui_specialShortcutHandleTrigger[this]+shortcut] , "gui" , this) //AClassInterfaceInterfaceHashTable
				call s__AHashTable_storeHandleInteger(AGetInterfaceHashTable(),s___AGui_specialShortcutHandleTrigger[s__AGui_specialShortcutHandleTrigger[this]+shortcut] , "shortcut" , shortcut) //AClassInterfaceInterfaceHashTable
				set triggerEvent = null
				set triggerAction = null
			endif
   return true
endfunction
function sa__AGui_createDialogButtonTrigger takes nothing returns boolean
local integer this=f__arg_this
local integer index=f__arg_integer1
   local event triggerEvent
   local triggeraction triggerAction
			if ( ( s__AGui_dialogButtonTrigger[this] == null ) and ( s___AGui_dialogButtonAction[s__AGui_dialogButtonAction[this]+index] != 0 ) ) then
				set s___AGui_dialogButtonTrigger[s__AGui_dialogButtonTrigger[this]+index]=CreateTrigger()
				set triggerEvent = TriggerRegisterDialogButtonEvent(s___AGui_dialogButtonTrigger[s__AGui_dialogButtonTrigger[this]+index] , s___AGui_dialogButton[s__AGui_dialogButton[this]+index])
				set triggerAction = TriggerAddAction(s___AGui_dialogButtonTrigger[s__AGui_dialogButtonTrigger[this]+index] , function s__AGui_triggerActionRunDialogButtonAction)
				call s__AHashTable_storeHandleInteger(AGetInterfaceHashTable(),s___AGui_dialogButtonTrigger[s__AGui_dialogButtonTrigger[this]+index] , "gui" , this) //AClassInterfaceInterfaceHashTable
				call s__AHashTable_storeHandleInteger(AGetInterfaceHashTable(),s___AGui_dialogButtonTrigger[s__AGui_dialogButtonTrigger[this]+index] , "index" , index) //AClassInterfaceInterfaceHashTable
				set triggerEvent = null
				set triggerAction = null
			endif
   return true
endfunction
function sa__AGui_onDestroy takes nothing returns boolean
local integer this=f__arg_this
			call s__AGui_destroyDockedMainWindows(this)
			call s__AMainWindowContainer_destroy(s__AGui_container[this])
			call s__AGui_clearDialog(this)
			call DialogDestroy(s__AGui_usedDialog[this])
			set s__AGui_usedDialog[this]=null
			call s__AGui_destroyDialogButtons(this)
			call s__AGui_destroyLeaveTrigger(this)
			call s__AGui_removeShortcutHandler(this)
			call s__AGui_destroyShortcutHandleTrigger(this)
			call s__AGui_destroySpecialShortcutTriggers(this)
			call s__AGui_destroyDialogButtonTriggers(this)
   return true
endfunction
function sa__AMainWindowContainer_debugCheckIndex takes nothing returns boolean
local integer this=f__arg_this
local integer index=f__arg_integer1
     if ( ( index < 0 ) or ( index >= 4 ) ) then
      call Print("Wrong index of container " + I2S(this) + ": " + I2S(index) + ".")
     endif
   return true
endfunction
function sa__AView_enable takes nothing returns boolean
local integer this=f__arg_this
			call EnableTrigger(s__AView_viewTrigger[this])
			call SetCameraTargetControllerNoZForPlayer(s__AAbstractCharacterSystem_getUser(this) , s__AAbstractCharacterSystem_getUnit(this) , 0.0 , 0.0 , false)
   return true
endfunction
function sa__AView_disable takes nothing returns boolean
local integer this=f__arg_this
			call DisableTrigger(s__AView_viewTrigger[this])
			call ResetToGameCameraForPlayer(s__AAbstractCharacterSystem_getUser(this) , 0.0)
   return true
endfunction
function sa__AView_create takes nothing returns boolean
local integer character=f__arg_integer1
   local integer this= s__AView__allocate(character)
			call s__AView_createViewTrigger(this)
set f__result_integer= this
   return true
endfunction
function sa__AView_onDestroy takes nothing returns boolean
local integer this=f__arg_this
			call s__AView_destroyViewTrigger(this)
    set f__arg_this=this
   return true
endfunction
function sa__ASpell_enable takes nothing returns boolean
local integer this=f__arg_this
   return true
endfunction
function sa__ASpell_disable takes nothing returns boolean
local integer this=f__arg_this
   return true
endfunction
function sa__ASpell_onDestroy takes nothing returns boolean
local integer this=f__arg_this
			call s__ASpell_destroyCastTrigger(this)
    set f__arg_this=this
   return true
endfunction
function sa__AFight_enable takes nothing returns boolean
local integer this=f__arg_this
			call EnableTrigger(s__AFight_fightTrigger[this])
			if ( TimerGetRemaining(s__AFight_usedTimer[this]) > 0.0 ) then
				call PauseTimerBJ(false , s__AFight_usedTimer[this])
			endif
   return true
endfunction
function sa__AFight_disable takes nothing returns boolean
local integer this=f__arg_this
			call DisableTrigger(s__AFight_fightTrigger[this])
			if ( TimerGetRemaining(s__AFight_usedTimer[this]) > 0.0 ) then
				call PauseTimerBJ(true , s__AFight_usedTimer[this])
			endif
   return true
endfunction
function sa__AFight_create takes nothing returns boolean
local integer character=f__arg_integer1
   local integer this= s__AFight__allocate(character)
			set s__AFight_usedTimer[this]=CreateTimer()
			call s__AFight_createFightTrigger(this)
set f__result_integer= this
   return true
endfunction
function sa__AFight_onDestroy takes nothing returns boolean
local integer this=f__arg_this
			call s__AFight_destroyUsedTimer(this)
			call s__AFight_destroyFightTrigger(this)
    set f__arg_this=this
   return true
endfunction
function sa__ACharacter_getUser takes nothing returns boolean
local integer this=f__arg_this
set f__result_player= s__ACharacter_user[this]
   return true
endfunction
function sa__ACharacter_getUsedUnit takes nothing returns boolean
local integer this=f__arg_this
set f__result_unit= s__ACharacter_usedUnit[this]
   return true
endfunction
function sa__ACharacter_onDestroy takes nothing returns boolean
local integer this=f__arg_this
			set s__ACharacter_user[this]=null
			call s__ACharacter_removeUsedUnit(this)
			call s__ACharacter_destroyLeaveTrigger(this)
			call s__ACharacter_destroyDeathTrigger(this)
			call s__ACharacter_destroySystems(this)
   return true
endfunction
function sa__ACharacter_getPlayerCharacter takes nothing returns boolean
local player user=f__arg_player1
set f__result_integer= s__ACharacter_playerCharacter[GetPlayerId(user)]
   return true
endfunction
function sa__AMultiboardBar_onDestroy takes nothing returns boolean
local integer this=f__arg_this
			set s__AMultiboardBar_usedMultiboard[this]=null
			call s__AMultiboardBar_destroyRefreshTrigger(this)
   return true
endfunction
function sa__AIndicator_reset takes nothing returns boolean
local integer this=f__arg_this
			if ( s__AIndicator_objectType[this] == s__AIndicator_objectTypeImage ) then
				call SetImageColorBJ(I2Image(H2I(s__AIndicator_object[this])) , 100.0 , 100.0 , 100.0 , 0.0) //ALibraryGeneralConversion
			elseif ( s__AIndicator_objectType[this] == s__AIndicator_objectTypeTextTag ) then
				call SetTextTagColorBJ(I2TextTag(H2I(s__AIndicator_object[this])) , 100.0 , 100.0 , 100.0 , 0.0) //ALibraryGeneralConversion
			elseif ( s__AIndicator_objectType[this] == s__AIndicator_objectTypeUnit ) then
				call SetUnitVertexColorBJ(I2Unit(H2I(s__AIndicator_object[this])) , 100.0 , 100.0 , 100.0 , 0.0) //ALibraryGeneralConversion
			endif
   return true
endfunction
function sa__AIndicator_onDestroy takes nothing returns boolean
local integer this=f__arg_this
			set s__AIndicator_object[this]=null
			call s__AIndicator_destroyRefreshTrigger(this)
   return true
endfunction
function sa__ACheat_onDestroy takes nothing returns boolean
local integer this=f__arg_this
			call s__AHashTable_destroyTrigger(AGetDebugHashTable(),s__ACheat_cheatTrigger[this]) //AStructCoreDebugDebugHashTable
			set s__ACheat_cheatTrigger[this]=null
   return true
endfunction
function sa__AIntegerContainer_debugCheckIndex takes nothing returns boolean
local integer this=f__arg_this
local integer index=f__arg_integer1
     if ( ( index < 0 ) or ( index >= 1000 ) ) then
      call Print("Wrong index of container " + I2S(this) + ": " + I2S(index) + ".")
     endif
   return true
endfunction
function sa__AStructSystemsWorldWorldHashTable__AWorldHashTable_onDestroy takes nothing returns boolean
local integer this=f__arg_this
   return true
endfunction
function sa__AStructSystemsCharacterCharacterHashTable___ACharacterHashTable_onDestroy takes nothing returns boolean
local integer this=f__arg_this
   return true
endfunction
function sa__AStructCoreInterfaceInterfaceHashTable___AInterfaceHashTable_onDestroy takes nothing returns boolean
local integer this=f__arg_this
   return true
endfunction
function sa__AMissile_start takes nothing returns boolean
local integer this=f__arg_this
local real x=f__arg_real1
local real y=f__arg_real2
local real z=f__arg_real3
local real angle=f__arg_real4
    if ( s__AMissile_usedUnit[this] != null ) then
     call s__AMissile_print(this,"Missile has already been started.")
return true
    endif
			set s__AMissile_usedUnit[this]=CreateUnit(s__AMissile_m_owner[this] , s__AMissile_m_unitType[this] , x , y , angle)
			call SetUnitInvulnerable(s__AMissile_usedUnit[this] , true)
			call MakeUnitSelectable(s__AMissile_usedUnit[this] , false) //ALibraryInterfaceSelection
			call SetUnitZ(s__AMissile_usedUnit[this] , z) //ALibraryMathsHandle
			set s__AMissile_paused[this]=false
   return true
endfunction
function sa__AMissile_causeDamage takes nothing returns boolean
local integer this=f__arg_this
			if ( s__AMissile_m_damage[this] <= 0.0 ) then
return true
			endif
			if ( s__AMissile_m_damageRange[this] > 0.0 ) then
			elseif ( s__AMissile_m_targetWidget[this] != null ) then
			endif
   return true
endfunction
function sa__AMissile_showDeathEffect takes nothing returns boolean
local integer this=f__arg_this
   local effect createdEffect
			if ( s__AMissile_m_deathEffectPath[this] != null ) then
				set createdEffect = AddSpecialEffect(s__AMissile_m_deathEffectPath[this] , GetUnitX(s__AMissile_usedUnit[this]) , GetUnitY(s__AMissile_usedUnit[this]))
				call DestroyEffect(createdEffect)
				set createdEffect = null
			endif
   return true
endfunction
function sa__AMissile_playDeathSound takes nothing returns boolean
local integer this=f__arg_this
			if ( s__AMissile_m_deathSoundPath[this] != null ) then
				call PlaySound(s__AMissile_m_deathSoundPath[this]) /// @todo use coordinates!
			endif
   return true
endfunction
function sa__AMissile_onDestroy takes nothing returns boolean
local integer this=f__arg_this
			if ( s__AMissile_usedUnit[this] != null ) then
				call RemoveUnit(s__AMissile_usedUnit[this])
			endif
			set s__AMissile_usedUnit[this]=null
   return true
endfunction
function sa__AMissileContainer_debugCheckIndex takes nothing returns boolean
local integer this=f__arg_this
local integer index=f__arg_integer1
     if ( ( index < 0 ) or ( index >= 100 ) ) then
      call Print("Wrong index of container " + I2S(this) + ": " + I2S(index) + ".")
     endif
   return true
endfunction
function sa__AStructCoreDebugDebugHashTable__ADebugHashTable_onDestroy takes nothing returns boolean
local integer this=f__arg_this
   return true
endfunction
function sa__AVector_getLength takes nothing returns boolean
local integer this=f__arg_this
set f__result_real= SquareRoot(( s__AVector_x[this] * s__AVector_x[this] ) + ( s__AVector_y[this] * s__AVector_y[this] ) + ( s__AVector_z[this] * s__AVector_z[this] ))
   return true
endfunction
function sa__AVector_scale takes nothing returns boolean
local integer this=f__arg_this
local real factor=f__arg_real1
			set s__AVector_x[this]=s__AVector_x[this] * factor
			set s__AVector_y[this]=s__AVector_y[this] * factor
			set s__AVector_z[this]=s__AVector_z[this] * factor
   return true
endfunction
function sa__AVector_create takes nothing returns boolean
local real x=f__arg_real1
local real y=f__arg_real2
local real z=f__arg_real3
   local integer this= s__AVector__allocate()
			set s__AVector_x[this]=x
			set s__AVector_y[this]=y
			set s__AVector_z[this]=z
set f__result_integer= this
   return true
endfunction
function sa__APoint_create takes nothing returns boolean
local real x=f__arg_real1
local real y=f__arg_real2
   local integer this= s__APoint__allocate()
			set s__APoint_x[this]=x
			set s__APoint_y[this]=y
set f__result_integer= this
   return true
endfunction
function sa__AHashTable_onDestroy takes nothing returns boolean
local integer this=f__arg_this
			call FlushGameCache(s__AHashTable_gameCache[this])
			set s__AHashTable_gameCache[this]=null
   return true
endfunction
function sa__ACheckBox_setChecked takes nothing returns boolean
local integer this=f__arg_this
local boolean checked=f__arg_boolean1
			set s__ACheckBox_m_checked[this]=checked
			call s__AWidget_setShown(s__ACheckBox_checkedImage[this],checked)
			call s__AWidget_setShown(s__ACheckBox_uncheckedImage[this],not checked)
   return true
endfunction
function sa__ACheckBox_isChecked takes nothing returns boolean
local integer this=f__arg_this
set f__result_boolean= s__ACheckBox_m_checked[this]
   return true
endfunction
function sa__ACheckBox_show takes nothing returns boolean
local integer this=f__arg_this
			call s__AWidget_show(this)
			call s__AWidget_setShown(s__ACheckBox_checkedImage[this],s__ACheckBox_m_checked[this])
			call s__AWidget_setShown(s__ACheckBox_checkedImage[this],not s__ACheckBox_m_checked[this])
   return true
endfunction
function sa__ACheckBox_hide takes nothing returns boolean
local integer this=f__arg_this
			call s__AWidget_hide(this)
			call s__AWidget_setShown(s__ACheckBox_checkedImage[this],not s__ACheckBox_m_checked[this])
			call s__AWidget_setShown(s__ACheckBox_checkedImage[this],s__ACheckBox_m_checked[this])
   return true
endfunction
function sa__AQuest__disposeArrays takes nothing returns boolean
 local integer this=f__arg_this
 local integer kthis
    set si__AQuest_arrN=si__AQuest_arrN+1
    set kthis=si__AQuest_arr[this]
    set si__AQuest_arrV[si__AQuest_arrN]=kthis
 return true
endfunction
function sa__AQuest_setState takes nothing returns boolean
local integer this=f__arg_this
local integer state=f__arg_integer1
			call s__AAbstractQuest_setState(this,state)
			if ( s__AQuest_useQuestLog ) then
				call QuestSetTitle(s__AQuest_questLogQuest[this] , s__AAbstractQuest_getTitle(this))
				if ( state == s__AAbstractQuest_stateNew ) then
					call QuestSetDiscovered(s__AQuest_questLogQuest[this] , true)
				elseif ( state == s__AAbstractQuest_stateCompleted ) then
					call QuestSetCompleted(s__AQuest_questLogQuest[this] , true)
				elseif ( state == s__AAbstractQuest_stateFailed ) then
					call QuestSetFailed(s__AQuest_questLogQuest[this] , true)
				endif
				call FlashQuestDialogButton()
				call ForceQuestDialogUpdate() //required?
			endif
   return true
endfunction
function sa__AQuest_onDestroy takes nothing returns boolean
local integer this=f__arg_this
			call s__AQuest_destroyQuestLogQuest(this)
			call s__AQuest_destroyQuestItems(this)
    set f__arg_this=this
   return true
endfunction
function sa__AImage_show takes nothing returns boolean
local integer this=f__arg_this
			call s__AWidget_show(this)
			call ShowImage(s__AImage_usedImage[this] , true)
   return true
endfunction
function sa__AImage_hide takes nothing returns boolean
local integer this=f__arg_this
			call s__AWidget_hide(this)
			call ShowImage(s__AImage_usedImage[this] , false)
   return true
endfunction
function sa__AImage_onDestroy takes nothing returns boolean
local integer this=f__arg_this
			call DestroyImage(s__AImage_usedImage[this])
			set s__AImage_usedImage[this]=null
    set f__arg_this=this
   return true
endfunction
function sa__AText_show takes nothing returns boolean
local integer this=f__arg_this
			call s__AWidget_show(this)
			call ShowTextTagForPlayer(s__AGui_getUser(s__AMainWindow_getGui(s__AWidget_getMainWindow(this))) , s__AText_textTag[this] , true) //ALibraryInterfaceTextTag
   return true
endfunction
function sa__AText_hide takes nothing returns boolean
local integer this=f__arg_this
			call s__AWidget_hide(this)
			call ShowTextTagForPlayer(s__AGui_getUser(s__AMainWindow_getGui(s__AWidget_getMainWindow(this))) , s__AText_textTag[this] , false) //ALibraryInterfaceTextTag
   return true
endfunction
function sa__AText_onDestroy takes nothing returns boolean
local integer this=f__arg_this
			call DestroyTextTag(s__AText_textTag[this])
			set s__AText_textTag[this]=null
    set f__arg_this=this
   return true
endfunction
function sa__AQuestItem_setState takes nothing returns boolean
local integer this=f__arg_this
local integer state=f__arg_integer1
   local boolean result
			call s__AAbstractQuest_setState(this,state) //AClassCharacterAbstractQuest
			set result = not s__AQuest_checkQuestItemsForState(s__AQuestItem_usedQuest[this],state) //AClassCharacterQuest
			if ( s__AQuest_isQuestLogUsed() ) then //AClassCharacterQuest
				call QuestItemSetCompleted(s__AQuestItem_questLogQuestItem[this] , state == s__AAbstractQuest_stateCompleted) //AClassCharacterAbstractQuest
				if ( result ) then
					call FlashQuestDialogButton()
					call ForceQuestDialogUpdate() //required?
				endif
			endif
   return true
endfunction
function sa__AQuestItem_onDestroy takes nothing returns boolean
local integer this=f__arg_this
			call s__AQuestItem_destroyQuestLogQuestItem(this)
    set f__arg_this=this
   return true
endfunction

function jasshelper__initstructs2923 takes nothing returns nothing
    set st___prototype826[1]=CreateTrigger()
    call TriggerAddAction(st___prototype826[1],function sa___prototype826_ALibraryCoreDebugContainer___Compare)
    call TriggerAddCondition(st___prototype826[1],Condition(function sa___prototype826_ALibraryCoreDebugContainer___Compare))
    set st___prototype789[1]=CreateTrigger()
    call TriggerAddAction(st___prototype789[1],function sa___prototype789_ALibraryCoreDebugContainer___Show)
    call TriggerAddCondition(st___prototype789[1],Condition(function sa___prototype789_ALibraryCoreDebugContainer___Show))
    set st___prototype825[1]=CreateTrigger()
    call TriggerAddAction(st___prototype825[1],function sa___prototype825_ALibraryCoreDebugContainer___SearchForTen)
    call TriggerAddCondition(st___prototype825[1],Condition(function sa___prototype825_ALibraryCoreDebugContainer___SearchForTen))
    set st___prototype824[1]=CreateTrigger()
    call TriggerAddAction(st___prototype824[1],function sa___prototype824_ALibraryCoreDebugContainer___Operation)
    call TriggerAddCondition(st___prototype824[1],Condition(function sa___prototype824_ALibraryCoreDebugContainer___Operation))
    set st___prototype826[2]=CreateTrigger()
    call TriggerAddAction(st___prototype826[2],function sa___prototype826_ALibraryCoreDebugContainer___SearchForBiggerElement)
    call TriggerAddCondition(st___prototype826[2],Condition(function sa___prototype826_ALibraryCoreDebugContainer___SearchForBiggerElement))
    set st___prototype835[1]=CreateTrigger()
    call TriggerAddAction(st___prototype835[1],function sa___prototype835_AStructSystemsGuiGui__unaryFunctionDestroyMainWindow)
    call TriggerAddCondition(st___prototype835[1],Condition(function sa___prototype835_AStructSystemsGuiGui__unaryFunctionDestroyMainWindow))
    set st___prototype838[1]=CreateTrigger()
    call TriggerAddAction(st___prototype838[1],function sa___prototype838_AStructSystemsCharacterTalk___GuiDialogButtonActionTalkAction)
    call TriggerAddCondition(st___prototype838[1],Condition(function sa___prototype838_AStructSystemsCharacterTalk___GuiDialogButtonActionTalkAction))
    set st___prototype843[1]=CreateTrigger()
    call TriggerAddAction(st___prototype843[1],function sa___prototype843_AStructSystemsCharacterTalk___talkButtonActionExit)
    call TriggerAddCondition(st___prototype843[1],Condition(function sa___prototype843_AStructSystemsCharacterTalk___talkButtonActionExit))
    set st___prototype843[2]=CreateTrigger()
    call TriggerAddAction(st___prototype843[2],function sa___prototype843_AStructSystemsCharacterTalk___talkButtonActionBackToFirstPage)
    call TriggerAddCondition(st___prototype843[2],Condition(function sa___prototype843_AStructSystemsCharacterTalk___talkButtonActionBackToFirstPage))
    set st___prototype846[6]=CreateTrigger()
    call TriggerAddAction(st___prototype846[6],function sa___prototype846_onTrackActionShowTooltip)
    call TriggerAddCondition(st___prototype846[6],Condition(function sa___prototype846_onTrackActionShowTooltip))
    set st___prototype830[1]=CreateTrigger()
    call TriggerAddAction(st___prototype830[1],function sa___prototype830_ALibraryCoreDebugInterface__MultiboardBarValueFunctionGetValue)
    call TriggerAddCondition(st___prototype830[1],Condition(function sa___prototype830_ALibraryCoreDebugInterface__MultiboardBarValueFunctionGetValue))
    set st___prototype830[2]=CreateTrigger()
    call TriggerAddAction(st___prototype830[2],function sa___prototype830_ALibraryCoreDebugInterface__MultiboardBarValueFunctionGetMaxValue)
    call TriggerAddCondition(st___prototype830[2],Condition(function sa___prototype830_ALibraryCoreDebugInterface__MultiboardBarValueFunctionGetMaxValue))
    set st___prototype846[1]=CreateTrigger()
    call TriggerAddAction(st___prototype846[1],function sa___prototype846_AStructSystemsGuiMainWindow__unaryFunctionShowWidget)
    call TriggerAddCondition(st___prototype846[1],Condition(function sa___prototype846_AStructSystemsGuiMainWindow__unaryFunctionShowWidget))
    set st___prototype846[2]=CreateTrigger()
    call TriggerAddAction(st___prototype846[2],function sa___prototype846_AStructSystemsGuiMainWindow__unaryFunctionHideWidget)
    call TriggerAddCondition(st___prototype846[2],Condition(function sa___prototype846_AStructSystemsGuiMainWindow__unaryFunctionHideWidget))
    set st___prototype846[3]=CreateTrigger()
    call TriggerAddAction(st___prototype846[3],function sa___prototype846_AStructSystemsGuiMainWindow__unaryFunctionDestroyWidget)
    call TriggerAddCondition(st___prototype846[3],Condition(function sa___prototype846_AStructSystemsGuiMainWindow__unaryFunctionDestroyWidget))
    set st___prototype846[4]=CreateTrigger()
    call TriggerAddAction(st___prototype846[4],function sa___prototype846_AStructSystemsGuiCheckBox__onHitAction)
    call TriggerAddCondition(st___prototype846[4],Condition(function sa___prototype846_AStructSystemsGuiCheckBox__onHitAction))
    set st___prototype840[1]=CreateTrigger()
    call TriggerAddAction(st___prototype840[1],function sa___prototype840_ALibrarySystemsDebugCharacter__questItemStateEventChat)
    call TriggerAddCondition(st___prototype840[1],Condition(function sa___prototype840_ALibrarySystemsDebugCharacter__questItemStateEventChat))
    set st___prototype842[1]=CreateTrigger()
    call TriggerAddAction(st___prototype842[1],function sa___prototype842_ALibrarySystemsDebugCharacter__questItemStateActionChat)
    call TriggerAddCondition(st___prototype842[1],Condition(function sa___prototype842_ALibrarySystemsDebugCharacter__questItemStateActionChat))
    set st___prototype843[3]=CreateTrigger()
    call TriggerAddAction(st___prototype843[3],function sa___prototype843_ALibrarySystemsDebugCharacter__talkStartActionTestTalk)
    call TriggerAddCondition(st___prototype843[3],Condition(function sa___prototype843_ALibrarySystemsDebugCharacter__talkStartActionTestTalk))
    set st___prototype843[4]=CreateTrigger()
    call TriggerAddAction(st___prototype843[4],function sa___prototype843_ALibrarySystemsDebugCharacter__talkButtonActionFuckYou)
    call TriggerAddCondition(st___prototype843[4],Condition(function sa___prototype843_ALibrarySystemsDebugCharacter__talkButtonActionFuckYou))
    set st___prototype843[5]=CreateTrigger()
    call TriggerAddAction(st___prototype843[5],function sa___prototype843_ALibrarySystemsDebugCharacter__talkButtonActionHello)
    call TriggerAddCondition(st___prototype843[5],Condition(function sa___prototype843_ALibrarySystemsDebugCharacter__talkButtonActionHello))
    set st___prototype843[6]=CreateTrigger()
    call TriggerAddAction(st___prototype843[6],function sa___prototype843_ALibrarySystemsDebugCharacter__talkButtonActionHowAreYou)
    call TriggerAddCondition(st___prototype843[6],Condition(function sa___prototype843_ALibrarySystemsDebugCharacter__talkButtonActionHowAreYou))
    set st___prototype831[1]=CreateTrigger()
    call TriggerAddAction(st___prototype831[1],function sa___prototype831_ALibrarySystemsDebugCharacter__castAction)
    call TriggerAddCondition(st___prototype831[1],Condition(function sa___prototype831_ALibrarySystemsDebugCharacter__castAction))
    set st___prototype846[5]=CreateTrigger()
    call TriggerAddAction(st___prototype846[5],function sa___prototype846_ALibrarySystemsDebugGui__onHitActionShowMessage)
    call TriggerAddCondition(st___prototype846[5],Condition(function sa___prototype846_ALibrarySystemsDebugGui__onHitActionShowMessage))
    set st___prototype837[1]=CreateTrigger()
    call TriggerAddAction(st___prototype837[1],function sa___prototype837_ALibrarySystemsDebugGui__onPressGuiShortcutActionShowMessage)
    call TriggerAddCondition(st___prototype837[1],Condition(function sa___prototype837_ALibrarySystemsDebugGui__onPressGuiShortcutActionShowMessage))
    set st___prototype846[8]=CreateTrigger()
    call TriggerAddAction(st___prototype846[8],function sa___prototype846_AStructSystemsDebugSystemDebugger__onHitActionShowInfo)
    call TriggerAddCondition(st___prototype846[8],Condition(function sa___prototype846_AStructSystemsDebugSystemDebugger__onHitActionShowInfo))
    set st___prototype846[9]=CreateTrigger()
    call TriggerAddAction(st___prototype846[9],function sa___prototype846_AStructSystemsDebugSystemDebugger__onHitActionShowGuiSystemMainWindow)
    call TriggerAddCondition(st___prototype846[9],Condition(function sa___prototype846_AStructSystemsDebugSystemDebugger__onHitActionShowGuiSystemMainWindow))
    set st___prototype846[10]=CreateTrigger()
    call TriggerAddAction(st___prototype846[10],function sa___prototype846_AStructSystemsDebugSystemDebugger__onHitActionShowCharacterSystemMainWindow)
    call TriggerAddCondition(st___prototype846[10],Condition(function sa___prototype846_AStructSystemsDebugSystemDebugger__onHitActionShowCharacterSystemMainWindow))
    set st___prototype846[11]=CreateTrigger()
    call TriggerAddAction(st___prototype846[11],function sa___prototype846_AStructSystemsDebugSystemDebugger__onHitActionShowWorldSystemMainWindow)
    call TriggerAddCondition(st___prototype846[11],Condition(function sa___prototype846_AStructSystemsDebugSystemDebugger__onHitActionShowWorldSystemMainWindow))
    set st___prototype846[7]=CreateTrigger()
    call TriggerAddAction(st___prototype846[7],function sa___prototype846_AStructSystemsDebugSystemDebugger__onHitActionInitCharacterSystem)
    call TriggerAddCondition(st___prototype846[7],Condition(function sa___prototype846_AStructSystemsDebugSystemDebugger__onHitActionInitCharacterSystem))
    set st__ASystemDebugger_onDestroy=CreateTrigger()
    call TriggerAddCondition(st__ASystemDebugger_onDestroy,Condition( function sa__ASystemDebugger_onDestroy))
    set st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_enable[3]=CreateTrigger()
    call TriggerAddCondition(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_enable[3],Condition( function sa__AAbstractCharacterSystem_enable))
    call TriggerAddAction(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_enable[3], function sa__AAbstractCharacterSystem_enable)
    set st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_disable[3]=CreateTrigger()
    call TriggerAddCondition(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_disable[3],Condition( function sa__AAbstractCharacterSystem_disable))
    call TriggerAddAction(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_disable[3], function sa__AAbstractCharacterSystem_disable)
    set st__AAbstractCharacterSystem_create=CreateTrigger()
    call TriggerAddCondition(st__AAbstractCharacterSystem_create,Condition( function sa__AAbstractCharacterSystem_create))
    set st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_onDestroy[3]=null
    set st__AMainWindow_getGui=CreateTrigger()
    call TriggerAddCondition(st__AMainWindow_getGui,Condition( function sa__AMainWindow_getGui))
    set st__AMainWindow_getX=CreateTrigger()
    call TriggerAddCondition(st__AMainWindow_getX,Condition( function sa__AMainWindow_getX))
    set st__AMainWindow_getY=CreateTrigger()
    call TriggerAddCondition(st__AMainWindow_getY,Condition( function sa__AMainWindow_getY))
    set st__AMainWindow_getUser=CreateTrigger()
    call TriggerAddCondition(st__AMainWindow_getUser,Condition( function sa__AMainWindow_getUser))
    set st__AMainWindow_showTooltip=CreateTrigger()
    call TriggerAddCondition(st__AMainWindow_showTooltip,Condition( function sa__AMainWindow_showTooltip))
    set st__AMainWindow_dockWidget=CreateTrigger()
    call TriggerAddCondition(st__AMainWindow_dockWidget,Condition( function sa__AMainWindow_dockWidget))
    set st__AMainWindow_undockWidget=CreateTrigger()
    call TriggerAddCondition(st__AMainWindow_undockWidget,Condition( function sa__AMainWindow_undockWidget))
    set st__AMainWindow_show=CreateTrigger()
    call TriggerAddCondition(st__AMainWindow_show,Condition( function sa__AMainWindow_show))
    set st__AMainWindow_hide=CreateTrigger()
    call TriggerAddCondition(st__AMainWindow_hide,Condition( function sa__AMainWindow_hide))
    set st__AMainWindow_onDestroy=CreateTrigger()
    call TriggerAddCondition(st__AMainWindow_onDestroy,Condition( function sa__AMainWindow_onDestroy))
    set st__AWidgetContainer_debugCheckIndex=CreateTrigger()
    call TriggerAddCondition(st__AWidgetContainer_debugCheckIndex,Condition( function sa__AWidgetContainer_debugCheckIndex))
    set st__AShrine_onDestroy=CreateTrigger()
    call TriggerAddCondition(st__AShrine_onDestroy,Condition( function sa__AShrine_onDestroy))
    set st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_enable[99]=CreateTrigger()
    call TriggerAddCondition(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_enable[99],Condition( function sa__AInventory_enable))
    call TriggerAddAction(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_enable[99], function sa__AInventory_enable)
    set st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_disable[99]=CreateTrigger()
    call TriggerAddCondition(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_disable[99],Condition( function sa__AInventory_disable))
    call TriggerAddAction(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_disable[99], function sa__AInventory_disable)
    set st__AInventory_enableEquipment=CreateTrigger()
    call TriggerAddCondition(st__AInventory_enableEquipment,Condition( function sa__AInventory_enableEquipment))
    set st__AInventory_disableEquipment=CreateTrigger()
    call TriggerAddCondition(st__AInventory_disableEquipment,Condition( function sa__AInventory_disableEquipment))
    set st__AInventory_enableRucksack=CreateTrigger()
    call TriggerAddCondition(st__AInventory_enableRucksack,Condition( function sa__AInventory_enableRucksack))
    set st__AInventory_disableRucksack=CreateTrigger()
    call TriggerAddCondition(st__AInventory_disableRucksack,Condition( function sa__AInventory_disableRucksack))
    set st__AInventory_addItemToRucksack=CreateTrigger()
    call TriggerAddCondition(st__AInventory_addItemToRucksack,Condition( function sa__AInventory_addItemToRucksack))
    set st__AInventory_getItemRucksackPage=CreateTrigger()
    call TriggerAddCondition(st__AInventory_getItemRucksackPage,Condition( function sa__AInventory_getItemRucksackPage))
    set st__AInventory_setEquipmentItem=CreateTrigger()
    call TriggerAddCondition(st__AInventory_setEquipmentItem,Condition( function sa__AInventory_setEquipmentItem))
    set st__AInventory_showEquipmentItem=CreateTrigger()
    call TriggerAddCondition(st__AInventory_showEquipmentItem,Condition( function sa__AInventory_showEquipmentItem))
    set st__AInventory_hideEquipmentItem=CreateTrigger()
    call TriggerAddCondition(st__AInventory_hideEquipmentItem,Condition( function sa__AInventory_hideEquipmentItem))
    set st__AInventory_checkEquipment=CreateTrigger()
    call TriggerAddCondition(st__AInventory_checkEquipment,Condition( function sa__AInventory_checkEquipment))
    set st__AInventory_setRucksackItem=CreateTrigger()
    call TriggerAddCondition(st__AInventory_setRucksackItem,Condition( function sa__AInventory_setRucksackItem))
    set st__AInventory_showRucksackPage=CreateTrigger()
    call TriggerAddCondition(st__AInventory_showRucksackPage,Condition( function sa__AInventory_showRucksackPage))
    set st__AInventory_hideCurrentRucksackPage=CreateTrigger()
    call TriggerAddCondition(st__AInventory_hideCurrentRucksackPage,Condition( function sa__AInventory_hideCurrentRucksackPage))
    set st__AInventory_create=CreateTrigger()
    call TriggerAddCondition(st__AInventory_create,Condition( function sa__AInventory_create))
    set st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_onDestroy[99]=CreateTrigger()
    call TriggerAddCondition(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_onDestroy[99],Condition( function sa__AInventory_onDestroy))
    call TriggerAddCondition(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_onDestroy[99],Condition( function sa__AInventory__disposeArrays))
    set st__AWidget_getMainWindow=CreateTrigger()
    call TriggerAddCondition(st__AWidget_getMainWindow,Condition( function sa__AWidget_getMainWindow))
    set st__AWidget_show[98]=CreateTrigger()
    set st__AWidget_show[106]=st__AWidget_show[98]
    call TriggerAddCondition(st__AWidget_show[98],Condition( function sa__AWidget_show))
    call TriggerAddAction(st__AWidget_show[98], function sa__AWidget_show)
    set st__AWidget_hide[98]=CreateTrigger()
    set st__AWidget_hide[106]=st__AWidget_hide[98]
    call TriggerAddCondition(st__AWidget_hide[98],Condition( function sa__AWidget_hide))
    call TriggerAddAction(st__AWidget_hide[98], function sa__AWidget_hide)
    set st__AWidget_enableOnHitTrigger=CreateTrigger()
    call TriggerAddCondition(st__AWidget_enableOnHitTrigger,Condition( function sa__AWidget_enableOnHitTrigger))
    set st__AWidget_enableOnTrackTrigger=CreateTrigger()
    call TriggerAddCondition(st__AWidget_enableOnTrackTrigger,Condition( function sa__AWidget_enableOnTrackTrigger))
    set st__AWidget_disableOnHitTrigger=CreateTrigger()
    call TriggerAddCondition(st__AWidget_disableOnHitTrigger,Condition( function sa__AWidget_disableOnHitTrigger))
    set st__AWidget_disableOnTrackTrigger=CreateTrigger()
    call TriggerAddCondition(st__AWidget_disableOnTrackTrigger,Condition( function sa__AWidget_disableOnTrackTrigger))
    set st__AWidget_create=CreateTrigger()
    call TriggerAddCondition(st__AWidget_create,Condition( function sa__AWidget_create))
    set st__AWidget_onDestroy[98]=CreateTrigger()
    set st__AWidget_onDestroy[106]=st__AWidget_onDestroy[98]
    set st__AWidget_onDestroy[118]=st__AWidget_onDestroy[98]
    call TriggerAddCondition(st__AWidget_onDestroy[98],Condition( function sa__AWidget_onDestroy))
    set st__AWidget_getTrackablePathBySize=CreateTrigger()
    call TriggerAddCondition(st__AWidget_getTrackablePathBySize,Condition( function sa__AWidget_getTrackablePathBySize))
    set st__AVideo_createSkipTrigger=CreateTrigger()
    call TriggerAddCondition(st__AVideo_createSkipTrigger,Condition( function sa__AVideo_createSkipTrigger))
    set st__ATalk_getCharacter=CreateTrigger()
    call TriggerAddCondition(st__ATalk_getCharacter,Condition( function sa__ATalk_getCharacter))
    set st__ATalk_speech=CreateTrigger()
    call TriggerAddCondition(st__ATalk_speech,Condition( function sa__ATalk_speech))
    set st__ATalk_showFirstPage=CreateTrigger()
    call TriggerAddCondition(st__ATalk_showFirstPage,Condition( function sa__ATalk_showFirstPage))
    set st__ATalk_hide=CreateTrigger()
    call TriggerAddCondition(st__ATalk_hide,Condition( function sa__ATalk_hide))
    set st__ATalk_disable=CreateTrigger()
    call TriggerAddCondition(st__ATalk_disable,Condition( function sa__ATalk_disable))
    set st__ATalk_addButton=CreateTrigger()
    call TriggerAddCondition(st__ATalk_addButton,Condition( function sa__ATalk_addButton))
    set st__ATalk_runButtonAction=CreateTrigger()
    call TriggerAddCondition(st__ATalk_runButtonAction,Condition( function sa__ATalk_runButtonAction))
    set st__ATalk_wait=CreateTrigger()
    call TriggerAddCondition(st__ATalk_wait,Condition( function sa__ATalk_wait))
    set st__ATalk_refreshView=CreateTrigger()
    call TriggerAddCondition(st__ATalk_refreshView,Condition( function sa__ATalk_refreshView))
    set st__ATalk_refreshFacings=CreateTrigger()
    call TriggerAddCondition(st__ATalk_refreshFacings,Condition( function sa__ATalk_refreshFacings))
    set st__ATalk_resetFacings=CreateTrigger()
    call TriggerAddCondition(st__ATalk_resetFacings,Condition( function sa__ATalk_resetFacings))
    set st__ATalk_resetAnimations=CreateTrigger()
    call TriggerAddCondition(st__ATalk_resetAnimations,Condition( function sa__ATalk_resetAnimations))
    set st__ATalk_onDestroy=CreateTrigger()
    call TriggerAddCondition(st__ATalk_onDestroy,Condition( function sa__ATalk_onDestroy))
    set st__ATalk_createSkipTrigger=CreateTrigger()
    call TriggerAddCondition(st__ATalk_createSkipTrigger,Condition( function sa__ATalk_createSkipTrigger))
    set st__ATalk_getTime=CreateTrigger()
    call TriggerAddCondition(st__ATalk_getTime,Condition( function sa__ATalk_getTime))
    set st__AStructSystemsCharacterTalk___AInfo_onDestroy=CreateTrigger()
    call TriggerAddCondition(st__AStructSystemsCharacterTalk___AInfo_onDestroy,Condition( function sa__AStructSystemsCharacterTalk___AInfo_onDestroy))
    set st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_enable[84]=CreateTrigger()
    call TriggerAddCondition(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_enable[84],Condition( function sa__ARevival_enable))
    call TriggerAddAction(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_enable[84], function sa__ARevival_enable)
    set st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_disable[84]=CreateTrigger()
    call TriggerAddCondition(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_disable[84],Condition( function sa__ARevival_disable))
    call TriggerAddAction(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_disable[84], function sa__ARevival_disable)
    set st__ARevival_end=CreateTrigger()
    call TriggerAddCondition(st__ARevival_end,Condition( function sa__ARevival_end))
    set st__ARevival_create=CreateTrigger()
    call TriggerAddCondition(st__ARevival_create,Condition( function sa__ARevival_create))
    set st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_onDestroy[84]=CreateTrigger()
    call TriggerAddCondition(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_onDestroy[84],Condition( function sa__ARevival_onDestroy))
    set st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_enable[81]=CreateTrigger()
    call TriggerAddCondition(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_enable[81],Condition( function sa__AMovement_enable))
    call TriggerAddAction(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_enable[81], function sa__AMovement_enable)
    set st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_disable[81]=CreateTrigger()
    call TriggerAddCondition(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_disable[81],Condition( function sa__AMovement_disable))
    call TriggerAddAction(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_disable[81], function sa__AMovement_disable)
    set st__AMovement_create=CreateTrigger()
    call TriggerAddCondition(st__AMovement_create,Condition( function sa__AMovement_create))
    set st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_onDestroy[81]=CreateTrigger()
    call TriggerAddCondition(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_onDestroy[81],Condition( function sa__AMovement_onDestroy))
    call TriggerAddCondition(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_onDestroy[81],Condition( function sa__AMovement__disposeArrays))
    set st__AItemType_onDestroy=CreateTrigger()
    call TriggerAddCondition(st__AItemType_onDestroy,Condition( function sa__AItemType_onDestroy))
    set st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_enable[79]=CreateTrigger()
    call TriggerAddCondition(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_enable[79],Condition( function sa__AFocus_enable))
    call TriggerAddAction(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_enable[79], function sa__AFocus_enable)
    set st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_disable[79]=CreateTrigger()
    call TriggerAddCondition(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_disable[79],Condition( function sa__AFocus_disable))
    call TriggerAddAction(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_disable[79], function sa__AFocus_disable)
    set st__AFocus_create=CreateTrigger()
    call TriggerAddCondition(st__AFocus_create,Condition( function sa__AFocus_create))
    set st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_onDestroy[79]=CreateTrigger()
    call TriggerAddCondition(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_onDestroy[79],Condition( function sa__AFocus_onDestroy))
    set st__AClassSelection_createUnit=CreateTrigger()
    call TriggerAddCondition(st__AClassSelection_createUnit,Condition( function sa__AClassSelection_createUnit))
    set st__AClassSelection_onDestroy=CreateTrigger()
    call TriggerAddCondition(st__AClassSelection_onDestroy,Condition( function sa__AClassSelection_onDestroy))
    set st__ACharactersScheme_onDestroy=CreateTrigger()
    call TriggerAddCondition(st__ACharactersScheme_onDestroy,Condition( function sa__ACharactersScheme_onDestroy))
    set st__ACharactersScheme_createMultiboard=CreateTrigger()
    call TriggerAddCondition(st__ACharactersScheme_createMultiboard,Condition( function sa__ACharactersScheme_createMultiboard))
    set st__ACharactersScheme_createRefreshTrigger=CreateTrigger()
    call TriggerAddCondition(st__ACharactersScheme_createRefreshTrigger,Condition( function sa__ACharactersScheme_createRefreshTrigger))
    set st__AAbstractQuest_setState[70]=CreateTrigger()
    call TriggerAddCondition(st__AAbstractQuest_setState[70],Condition( function sa__AAbstractQuest_setState))
    call TriggerAddAction(st__AAbstractQuest_setState[70], function sa__AAbstractQuest_setState)
    set st__AAbstractQuest_enable=CreateTrigger()
    call TriggerAddCondition(st__AAbstractQuest_enable,Condition( function sa__AAbstractQuest_enable))
    set st__AAbstractQuest_disable=CreateTrigger()
    call TriggerAddCondition(st__AAbstractQuest_disable,Condition( function sa__AAbstractQuest_disable))
    set st__AAbstractQuest_enableStateTriggers=CreateTrigger()
    call TriggerAddCondition(st__AAbstractQuest_enableStateTriggers,Condition( function sa__AAbstractQuest_enableStateTriggers))
    set st__AAbstractQuest_enablePingTrigger=CreateTrigger()
    call TriggerAddCondition(st__AAbstractQuest_enablePingTrigger,Condition( function sa__AAbstractQuest_enablePingTrigger))
    set st__AAbstractQuest_disableStateTriggers=CreateTrigger()
    call TriggerAddCondition(st__AAbstractQuest_disableStateTriggers,Condition( function sa__AAbstractQuest_disableStateTriggers))
    set st__AAbstractQuest_disablePingTrigger=CreateTrigger()
    call TriggerAddCondition(st__AAbstractQuest_disablePingTrigger,Condition( function sa__AAbstractQuest_disablePingTrigger))
    set st__AAbstractQuest_displayMessage=CreateTrigger()
    call TriggerAddCondition(st__AAbstractQuest_displayMessage,Condition( function sa__AAbstractQuest_displayMessage))
    set st__AAbstractQuest_distributeRewards=CreateTrigger()
    call TriggerAddCondition(st__AAbstractQuest_distributeRewards,Condition( function sa__AAbstractQuest_distributeRewards))
    set st__AAbstractQuest_triggerConditionRunQuestState=CreateTrigger()
    call TriggerAddCondition(st__AAbstractQuest_triggerConditionRunQuestState,Condition( function sa__AAbstractQuest_triggerConditionRunQuestState))
    set st__AAbstractQuest_triggerActionRunQuestState=CreateTrigger()
    call TriggerAddCondition(st__AAbstractQuest_triggerActionRunQuestState,Condition( function sa__AAbstractQuest_triggerActionRunQuestState))
    set st__AAbstractQuest_create=CreateTrigger()
    call TriggerAddCondition(st__AAbstractQuest_create,Condition( function sa__AAbstractQuest_create))
    set st__AAbstractQuest_onDestroy[70]=CreateTrigger()
    call TriggerAddCondition(st__AAbstractQuest_onDestroy[70],Condition( function sa__AAbstractQuest_onDestroy))
    set st__ASpawnPoint_onDestroy=CreateTrigger()
    call TriggerAddCondition(st__ASpawnPoint_onDestroy,Condition( function sa__ASpawnPoint_onDestroy))
    set st__ARoutine_onDestroy=CreateTrigger()
    call TriggerAddCondition(st__ARoutine_onDestroy,Condition( function sa__ARoutine_onDestroy))
    set st__AGui_enableSpecialShortcutTriggers=CreateTrigger()
    call TriggerAddCondition(st__AGui_enableSpecialShortcutTriggers,Condition( function sa__AGui_enableSpecialShortcutTriggers))
    set st__AGui_disableSpecialShortcutTriggers=CreateTrigger()
    call TriggerAddCondition(st__AGui_disableSpecialShortcutTriggers,Condition( function sa__AGui_disableSpecialShortcutTriggers))
    set st__AGui_createSpecialShortcutTrigger=CreateTrigger()
    call TriggerAddCondition(st__AGui_createSpecialShortcutTrigger,Condition( function sa__AGui_createSpecialShortcutTrigger))
    set st__AGui_createDialogButtonTrigger=CreateTrigger()
    call TriggerAddCondition(st__AGui_createDialogButtonTrigger,Condition( function sa__AGui_createDialogButtonTrigger))
    set st__AGui_onDestroy=CreateTrigger()
    call TriggerAddCondition(st__AGui_onDestroy,Condition( function sa__AGui_onDestroy))
    set st__AMainWindowContainer_debugCheckIndex=CreateTrigger()
    call TriggerAddCondition(st__AMainWindowContainer_debugCheckIndex,Condition( function sa__AMainWindowContainer_debugCheckIndex))
    set st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_enable[46]=CreateTrigger()
    call TriggerAddCondition(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_enable[46],Condition( function sa__AView_enable))
    call TriggerAddAction(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_enable[46], function sa__AView_enable)
    set st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_disable[46]=CreateTrigger()
    call TriggerAddCondition(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_disable[46],Condition( function sa__AView_disable))
    call TriggerAddAction(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_disable[46], function sa__AView_disable)
    set st__AView_create=CreateTrigger()
    call TriggerAddCondition(st__AView_create,Condition( function sa__AView_create))
    set st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_onDestroy[46]=CreateTrigger()
    call TriggerAddCondition(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_onDestroy[46],Condition( function sa__AView_onDestroy))
    set st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_enable[45]=CreateTrigger()
    call TriggerAddCondition(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_enable[45],Condition( function sa__ASpell_enable))
    call TriggerAddAction(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_enable[45], function sa__ASpell_enable)
    set st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_disable[45]=CreateTrigger()
    call TriggerAddCondition(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_disable[45],Condition( function sa__ASpell_disable))
    call TriggerAddAction(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_disable[45], function sa__ASpell_disable)
    set st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_onDestroy[45]=CreateTrigger()
    call TriggerAddCondition(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_onDestroy[45],Condition( function sa__ASpell_onDestroy))
    set st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_enable[43]=CreateTrigger()
    call TriggerAddCondition(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_enable[43],Condition( function sa__AFight_enable))
    call TriggerAddAction(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_enable[43], function sa__AFight_enable)
    set st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_disable[43]=CreateTrigger()
    call TriggerAddCondition(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_disable[43],Condition( function sa__AFight_disable))
    call TriggerAddAction(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_disable[43], function sa__AFight_disable)
    set st__AFight_create=CreateTrigger()
    call TriggerAddCondition(st__AFight_create,Condition( function sa__AFight_create))
    set st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_onDestroy[43]=CreateTrigger()
    call TriggerAddCondition(st__AStructSystemsCharacterAbstractCharacterSystem__AAbstractCharacterSystemInterface_onDestroy[43],Condition( function sa__AFight_onDestroy))
    set st__ACharacter_getUser=CreateTrigger()
    call TriggerAddCondition(st__ACharacter_getUser,Condition( function sa__ACharacter_getUser))
    set st__ACharacter_getUsedUnit=CreateTrigger()
    call TriggerAddCondition(st__ACharacter_getUsedUnit,Condition( function sa__ACharacter_getUsedUnit))
    set st__ACharacter_onDestroy=CreateTrigger()
    call TriggerAddCondition(st__ACharacter_onDestroy,Condition( function sa__ACharacter_onDestroy))
    set st__ACharacter_getPlayerCharacter=CreateTrigger()
    call TriggerAddCondition(st__ACharacter_getPlayerCharacter,Condition( function sa__ACharacter_getPlayerCharacter))
    set st__AMultiboardBar_onDestroy=CreateTrigger()
    call TriggerAddCondition(st__AMultiboardBar_onDestroy,Condition( function sa__AMultiboardBar_onDestroy))
    set st__AIndicator_reset=CreateTrigger()
    call TriggerAddCondition(st__AIndicator_reset,Condition( function sa__AIndicator_reset))
    set st__AIndicator_onDestroy=CreateTrigger()
    call TriggerAddCondition(st__AIndicator_onDestroy,Condition( function sa__AIndicator_onDestroy))
    set st__ACheat_onDestroy=CreateTrigger()
    call TriggerAddCondition(st__ACheat_onDestroy,Condition( function sa__ACheat_onDestroy))
    set st__AIntegerContainer_debugCheckIndex=CreateTrigger()
    call TriggerAddCondition(st__AIntegerContainer_debugCheckIndex,Condition( function sa__AIntegerContainer_debugCheckIndex))
    set st__AStructSystemsWorldWorldHashTable__AWorldHashTable_onDestroy=CreateTrigger()
    call TriggerAddCondition(st__AStructSystemsWorldWorldHashTable__AWorldHashTable_onDestroy,Condition( function sa__AStructSystemsWorldWorldHashTable__AWorldHashTable_onDestroy))
    set st__AStructSystemsCharacterCharacterHashTable___ACharacterHashTable_onDestroy=CreateTrigger()
    call TriggerAddCondition(st__AStructSystemsCharacterCharacterHashTable___ACharacterHashTable_onDestroy,Condition( function sa__AStructSystemsCharacterCharacterHashTable___ACharacterHashTable_onDestroy))
    set st__AStructCoreInterfaceInterfaceHashTable___AInterfaceHashTable_onDestroy=CreateTrigger()
    call TriggerAddCondition(st__AStructCoreInterfaceInterfaceHashTable___AInterfaceHashTable_onDestroy,Condition( function sa__AStructCoreInterfaceInterfaceHashTable___AInterfaceHashTable_onDestroy))
    set st__AMissile_start=CreateTrigger()
    call TriggerAddCondition(st__AMissile_start,Condition( function sa__AMissile_start))
    set st__AMissile_causeDamage=CreateTrigger()
    call TriggerAddCondition(st__AMissile_causeDamage,Condition( function sa__AMissile_causeDamage))
    set st__AMissile_showDeathEffect=CreateTrigger()
    call TriggerAddCondition(st__AMissile_showDeathEffect,Condition( function sa__AMissile_showDeathEffect))
    set st__AMissile_playDeathSound=CreateTrigger()
    call TriggerAddCondition(st__AMissile_playDeathSound,Condition( function sa__AMissile_playDeathSound))
    set st__AMissile_onDestroy=CreateTrigger()
    call TriggerAddCondition(st__AMissile_onDestroy,Condition( function sa__AMissile_onDestroy))
    set st__AMissileContainer_debugCheckIndex=CreateTrigger()
    call TriggerAddCondition(st__AMissileContainer_debugCheckIndex,Condition( function sa__AMissileContainer_debugCheckIndex))
    set st__AStructCoreDebugDebugHashTable__ADebugHashTable_onDestroy=CreateTrigger()
    call TriggerAddCondition(st__AStructCoreDebugDebugHashTable__ADebugHashTable_onDestroy,Condition( function sa__AStructCoreDebugDebugHashTable__ADebugHashTable_onDestroy))
    set st__AVector_getLength=CreateTrigger()
    call TriggerAddCondition(st__AVector_getLength,Condition( function sa__AVector_getLength))
    set st__AVector_scale=CreateTrigger()
    call TriggerAddCondition(st__AVector_scale,Condition( function sa__AVector_scale))
    set st__AVector_create=CreateTrigger()
    call TriggerAddCondition(st__AVector_create,Condition( function sa__AVector_create))
    set st__APoint_create=CreateTrigger()
    call TriggerAddCondition(st__APoint_create,Condition( function sa__APoint_create))
    set st__APoint_onDestroy[8]=null
    set st__APoint_onDestroy[12]=null
    set st__AHashTable_onDestroy=CreateTrigger()
    call TriggerAddCondition(st__AHashTable_onDestroy,Condition( function sa__AHashTable_onDestroy))
    set st__ACheckBox_setChecked=CreateTrigger()
    call TriggerAddCondition(st__ACheckBox_setChecked,Condition( function sa__ACheckBox_setChecked))
    set st__ACheckBox_isChecked=CreateTrigger()
    call TriggerAddCondition(st__ACheckBox_isChecked,Condition( function sa__ACheckBox_isChecked))
    set st__AWidget_show[118]=CreateTrigger()
    call TriggerAddCondition(st__AWidget_show[118],Condition( function sa__ACheckBox_show))
    call TriggerAddAction(st__AWidget_show[118], function sa__ACheckBox_show)
    set st__AWidget_hide[118]=CreateTrigger()
    call TriggerAddCondition(st__AWidget_hide[118],Condition( function sa__ACheckBox_hide))
    call TriggerAddAction(st__AWidget_hide[118], function sa__ACheckBox_hide)
    set st__AAbstractQuest_setState[103]=CreateTrigger()
    call TriggerAddCondition(st__AAbstractQuest_setState[103],Condition( function sa__AQuest_setState))
    call TriggerAddAction(st__AAbstractQuest_setState[103], function sa__AQuest_setState)
    set st__AAbstractQuest_onDestroy[103]=CreateTrigger()
    call TriggerAddCondition(st__AAbstractQuest_onDestroy[103],Condition( function sa__AQuest_onDestroy))
    call TriggerAddCondition(st__AAbstractQuest_onDestroy[103],Condition( function sa__AQuest__disposeArrays))
    call TriggerAddCondition(st__AAbstractQuest_onDestroy[103],Condition( function sa__AAbstractQuest_onDestroy))
    set st__AWidget_show[107]=CreateTrigger()
    call TriggerAddCondition(st__AWidget_show[107],Condition( function sa__AImage_show))
    call TriggerAddAction(st__AWidget_show[107], function sa__AImage_show)
    set st__AWidget_hide[107]=CreateTrigger()
    call TriggerAddCondition(st__AWidget_hide[107],Condition( function sa__AImage_hide))
    call TriggerAddAction(st__AWidget_hide[107], function sa__AImage_hide)
    set st__AWidget_onDestroy[107]=CreateTrigger()
    call TriggerAddCondition(st__AWidget_onDestroy[107],Condition( function sa__AImage_onDestroy))
    call TriggerAddCondition(st__AWidget_onDestroy[107],Condition( function sa__AWidget_onDestroy))
    set st__AWidget_show[116]=CreateTrigger()
    call TriggerAddCondition(st__AWidget_show[116],Condition( function sa__AText_show))
    call TriggerAddAction(st__AWidget_show[116], function sa__AText_show)
    set st__AWidget_hide[116]=CreateTrigger()
    call TriggerAddCondition(st__AWidget_hide[116],Condition( function sa__AText_hide))
    call TriggerAddAction(st__AWidget_hide[116], function sa__AText_hide)
    set st__AWidget_onDestroy[116]=CreateTrigger()
    call TriggerAddCondition(st__AWidget_onDestroy[116],Condition( function sa__AText_onDestroy))
    call TriggerAddCondition(st__AWidget_onDestroy[116],Condition( function sa__AWidget_onDestroy))
    set st__AAbstractQuest_setState[117]=CreateTrigger()
    call TriggerAddCondition(st__AAbstractQuest_setState[117],Condition( function sa__AQuestItem_setState))
    call TriggerAddAction(st__AAbstractQuest_setState[117], function sa__AQuestItem_setState)
    set st__AAbstractQuest_onDestroy[117]=CreateTrigger()
    call TriggerAddCondition(st__AAbstractQuest_onDestroy[117],Condition( function sa__AQuestItem_onDestroy))
    call TriggerAddCondition(st__AAbstractQuest_onDestroy[117],Condition( function sa__AAbstractQuest_onDestroy))

    call ExecuteFunc("s__AStructCoreDebugDebugHashTable__ADebugHashTable_onInit")
endfunction

