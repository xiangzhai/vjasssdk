Schlüsselwörter:
if, else, switch, case, break, continue, default, while, do, for
const, native, init, threaded, debug, template, package, private, protected, public, operator, enum, class, this, self, super, new, delete, copy, init, virtual, static, execute, executewait, evaluate, executions, evaluations, waits, wait, reset

Möglicher Zusatz:
executefast ermöglicht den Aufruf mit ExecuteFunc und Parameterspeicherung.

Allgemeine Neuerungen:
* Blockkommentare (/**/)

Präprozessoren:

#include [ jass | zinc | vjass | jasspp ] "Dateipfad"
#inject InitGlobals | InitSounds | CreateNeutralHostile | CreateNeutralPassiveBuildings | CreatePlayerBuildings | CreatePlayerUnits | CreateAllUnits | InitCustomTriggers | RunInitializationTriggers | InitCustomPlayerSlots | InitCustomTeams | InitAllyPriorities | main | config // injectet die entsprechende Funktion und ersetzt ihren Inhalt durch den Inhalt des Inject-Blocks. Existiert die Funktion nicht (z. B. da es keine eigenen Teams gibt, so zeigt der Compiler eine Fehlermeldung an)
#endinject
#initjasspp // Initialisiert die globale Hashtable und erzeugt sämtliche Prototypauslöser. Nützlich für eine Injection der main-Funktion
#if (konstanter Ausdruck) Zum Beispiel (WC3_VERSION == "1.21" && constantValue > 10) 
#endif
#jass
#endjass
#zinc
#endzinc
#vjass
#endvjass
#jasspp
#endjasspp
#external Ausdruck Parameter

Vordefinierte Konstanten:
OS Enthält eine Zeichenkette mit dem Namen des Betriebssystems.
COMPILER Enthält eine Zeichenkette mit dem Namen des verwendeten Compilers.
COMPILER_VERSION Enthält eine Zeichenkette mit der Version des verwendeten Compilers.
WC3_VERSION Enthält eine Zeichenkette mit der Warcraft-3-Version (ist zur Laufzeit aktuell!).
WC3_TFT_VERSION Enthält eine Zeichenkette mit der Warcraft-3-The-Frozen-Throne-Version. Falls The Frozen Throne nicht verwendet wird, ist der Wert gleich 0 gesetzt (ist zur Laufzeit aktuell!).
DEBUG_MODE Enthält entweder true oder false, je nachdem, ob der Debug-Modus aktiviert oder deaktiviert ist.
FILE_NAME Enthält eine Zeichenkette des Dateinamens der aktuellen Datei.
LINE_NUMBER Enthält eine Zeichenkette der Zeilennummer der aktuellen Zeile.

Dateipfade für die Include-Anweisung:
Dateipfade müssen wie bei UNIX Systemen geschrieben werden. . steht für das aktuelle und ..
für das darüber liegende Verzeichnis. Verzeichnisse werden durch das /-Zeichen getrennt.
~ verweist auf das Heimatverzeichnis des Benutzers, / auf das Basisverzeichnis.

Native Typen:

Notation:
native Typname : Elterntyp;

Native Funktionen:

Notation:
native [const] Rückgabetyp Funktionsname(Parametertyp Parametername, ...);

Variablen:

Notation:
[const] Variablentyp Variablenname[Variablengröße] = Variableninhalt;
 
Konstante Variablen müssen bei ihrer Deklaration definiert werden und ihr Inhalt ist
dauerhaft konstant.
Der Variableninhalt wird bei Arrays wie in C++ eingeschlossen:
integer tes[2] = { 10, 2 };

Es können mehrdimensionale Arrays deklariert werden:
integer test[2][2] = { { 10, 5 }, { 2, 4 } };

Da ein Array in Warcraft 3 nur 8192 bzw. 8191 (wird im letzten Feld die Größe gespeichert?) haben kann, werden vom Compiler bei größeren Größenangaben
weitere globale Variablen erstellt.
Eventuell sollte der Compiler einen Hinweis anzeigen.

Variablen können global deklariert werden, wenn sie nicht innerhalb eines Gültigkeitsbereiches stehen.
Funktionen und Methoden können statische Variablen enthalten:
static integer test;
static const integer test = 10;

0 entspricht ebenfalls dem Wert null in Jass.
Eine Zeichenkette ist somit auch 0, wenn sie nicht gesetzt wurde.
(Überdenken: Alle Variablen werden automatisch mit 0 oder false initialisiert.)

Operatoren:

Für die Typen integer und real:
Variable = Ausdruck
+Variable
-Variable
Variable + Ausdruck
Variable - Ausdruck
Variable * Ausdruck
Variable / Ausdruck
Variable % Ausdruck
Variable++
Variable--
Variable += Ausdruck
Variable -= Ausdruck
Variable *= Ausdruck
Variable /= Ausdruck
Variable %= Ausdruck
Variable == Ausdruck
Variable != Ausdruck
Variable >= Ausdruck
Variable <= Ausdruck
Variable > Ausdruck
Variable < Ausdruck

Für den Typ boolean:
Variable = Ausdruck
Variable
!Variable
Variable == Ausdruck
Variable != Ausdruck

Für Aufzählungen:
Variable = Ausdruck
Variable == Ausdruck
Variable != Ausdruck

Für Klassen(instanzen):
new Klassenname()			Entspricht Klassenname.new();
delete Variable				Entspricht Variable.delete();
Variable0 = copy Variable1;		Entspricht Variable1.copy(Variable0);
Variable = Ausdruck
Variable == Ausdruck
Variable != Ausdruck

Für Arrays:
Variable[Indexdimension 1][Indexdimension 2]

Typkonvertierungen:
Sämtliche Typkonvertierungen müssen explizit vorgenommen werden, insofern es sich nicht
um eine Kind-zu-Eltern-Konvertierung handelt. Sämtliche Funktions- und
Klasseninstanzenzeiger können zum Typ integer konvertiert werden (ebenfalls explizit).
Kindinstanzen können zu Elterninstanzen implizit konvertiert werden. Dies gilt auch für
native Kindtypen wie z. B. unit zu widget.
Andersherum muss explizit umgewandelt werden und gilt nur noch für Klasseninstanzen, nicht für
native Typen.
Zu Beachten gilt, dass es bei Eltern-zu-Kind-Konvertierungen zu fehlenden Daten für z. B.
virtuelle Methoden kommen kann. Schlimmer noch wäre ein Zugriff auf ein Instanzelement
einer ursprünglichen Nichtklasseninstanz, da so auf ein falsches Element einer anderen
Instanz zugegriffen werden würde. Dies kann selbst zur Laufzeit nicht im Debug-Modus heraus-
gefunden werden.
Daher sollte der Compiler bei solchen Konvertierungen eine Warnung ausgeben.

Notation:
<Konvertierungstyp>(Ausdruck)

Beispiele:
MyClass myClassValue = new MyClass;
integer myValue = integer(myClassValue);
MyParentClass myParentClassValue = myClassValue;
myClassValue = myParentClassValue; // illegal!
myClassValue = MyClass(myParentClassValue);
unit myUnit = null;
widget myWidget = myUnit;
myUnit = myWidget; // illegal!
myUnit = widget(myWidget); // illegal!

Verschachtelte Anweisungen:

if (Ausdruck)
{
}
else if (Ausdruck)
{
}
else (Ausdruck)
{
}

switch (Variable)
{
    case Ausdruck:
	break;

    case Ausdruck:
	break;

    default:
	break;
}

Schleifen:

while (Ausdruck)
{
}

do
{
}
while (Ausdruck);

for (Ausdruck; Ausdruck; Ausdruck)
{
}

Funktionen:
Mehrere Funktionsdefinitionen können den gleichen Namen haben, insofern sich die Parametertypen unterscheiden.
Wird eine Funktion aufgerufen, so können Werte für einzelne Parameter, in beliebiger Reihenfolge übergeben werden, insofern sämtliche
Parameter, welche kein Standardargument besitzen gesetzt werden:
MyFunction(y = 10, x = 100, 100, 3, 5);
Parameter mit Standardargumenten erhalten automatisch das Standardargument, insofern sie nicht explizit beim Aufruf gesetzt werden.

Notation:
[threaded] [init] [const] [Rückgabetyp] Funktionsname([Parametertyp Parametername [= Standardargument]] ...)
{
}

Ist eine Funktion "threaded", kann sie von überall aus mit .execute, .executewait, oder .evaluate aufgerufen werden.
Sie wird somit in einen eigenen Auslöser gespeichert und ihre Parameter mittels einer Hashtable für diesen gespeichert.

Mittels der Schlüsselwörter executions und evaluations kann herausgefunden werden, wie oft eine "threaded" Funktion per .execute, .executewait oder .evaluate aufgerufen wurde.
Zurückgegeben wird die Anzahl als integer:
Funktionsname.executions()
Funktionsname.evaluations()

Mittels der Schlüsselwörter waits und wait kann eine "threaded" Funktion darauf überprüft werden, ob ihr Thread gerade wartet bzw.
das Warten aktiviert oder deaktiviert werden:
Funktionsname.waits() // Liefert einen Boolean-Wert.
Funktionsname.wait(false) // Funktion wartet nicht mehr bei TriggerSleepAction-Aufrufen.

Mittels des Schlüsselwortes reset kann eine "threaded" Funktion zurückgesetzt werden:
Funktionsname.reset() // Setzt den Thread der Funktion zurück.

Ist eine Funktion "init", so wird diese während der Karteninitialisierung exakt vor der Funktion RunInitializationTriggers aufgerufen.
Eine "init"-Funktion darf keine Parameter entgegennehmen. Außerdem sollte der Compiler warnen, falls sie einen Rückgabetyp besitzt, manuell
aufgerufen wird oder "threaded" ist (einstellbar, "threaded" ist ebenfalls eher unnötig).

Ist eine Funktion "const", so muss sie einen Konstanten Wert zurückgeben. Beim Kompilieren, wird
sie normalerweise als "constant" Jass-Funktion erzeugt.

Funktionsvariablen (Funktionszeiger):
Funktionsvariablen sind Variablen des Typs "<Rückgabetyp> (<Parameter>)". Sie können einen Verweis auf eine beliebige
"threaded"-Funktion mit dem angegebenen Rückgabetyp und den angegebenen Parametern enthalten.
Der Verweis ist normalerweise ein Integer-Wert, welcher auf die Funktion in der globalen Hashtable verweist bzw. zu dieser gehört.
Eine Funktionsvariable kann ebenso auf Methoden einer Klasse verweisen.
Funktionsvariablen können wie normale "threaded" Funktionen aufgerufen werden:
integer (integer, integer) functionVariable = MyClass.method0;
Print(functionVariable.evaluate(0, 10));

Vorlagen (Templates):
Vorlagen werden mittels einer einfachen Kopie ihres enthaltenen Codes mit den verwendeten Datentypen gespeichert.
Die Datentypparameter können genau wie bei Funktionsparameter gesetzt werden.

Notation:

template Templatename<Datentypparameter = [Standardargument] ...>
{
    Templateinhalt
}

Vector<integer> myVector = new Vector<integer>;

Der Template-Inhalt können Funktionen oder Klassen sein.

Testblöcke:
Der von Testblöcken enthaltene Code wird nur kompiliert, insofern der eingebaute Debug-Modus aktiviert ist.
Analog zu #if (DEBUG_MODE) und #endif.

Notation:

debug
{
}

Pakete:
In Jass++ müssen sämtliche Objekte wie Funktionen, Variablen, Klassen, Aufzählungen, Vorlagen usw.
in Paketen enthalten sein. Es gibt keine globalen Objekte außer den Paketen selbst.
Eine Ausnahme bilden native Typen, Funktionen und reine Jass-Funktionen.

Notation einer Paketdefinition:
package Name : benötigte Pakete durch Kommata getrennt
{
    private Funktion/Variable/Klasse/Aufzählung/Paket

    public Funktion/Variable/Klasse/Aufzählung/Paket

    protected Funktion/Variable/Klasse/Aufzählung/Paket
}

Fehlt private, public oder protected, ist das Objekt automatisch private. Protected bewirkt, dass das Objekt für die enthaltenen Pakete zugänglich ist.

Notation einer Paketverwendung:
package Paketname, Paketname.Unterpaketname.Unterunterpaketname, Paketname, Paketname.*;

Wird ein Paket innerhalb eines anderen oder global verwendet, muss bei Verwendung von dessen Inhalt kein Paketname.-Präfix mehr vorangestellt werden.
Die Paketverwendung gilt entweder global oder innerhalb eines Pakets und all dessen Unterpaketen.
Wird ein Unterpaket eines Pakets verwendet, so wird das Paket automatisch mitverwendet.
Wird die Notation Paketname.* verwendet, so werden alle Unterpakete und deren Unterpakete usw. verwendet.

Aufzählungen:
Wird ein Enumelement gesetzt, so werden alle darauffolgenden Enum-Elemente auf die noch nicht verwendeten nachfolgenden Werte gesetzt.

Notation:
enum Name
{
    Enumelement1,
    Enumelement2 = 2,
    Enumelement3
} globale Instanzen durch Kommate getrennt;

Klassen:
Existiert kein Präfix wie public, protected oder private vor der Variablen oder Methodendeklaration, ist das Klassenelement automatisch private.
Statische Methoden erhalten keinen this-Parameter.
Statische Variablen können mit Klassenname.Variablenname angesprochen werden.
Der Konstruktor und der Destruktor werden aufgerufen, sobald das Objekt erzeugt oder gelöscht wird.
Der Kopierkonstruktor wird aufgerufen, sobald das Objekt explizit mittels .copy kopiert wird. Normalerweise wird er automatisch definiert und kopiert den Inhalt
aller Elemente des kopierten Objekts in das aktuelle Objekt.
Die Initialisierungsmethode wird genau vor dem ersten Zugriff auf eine Klasseneigenschaft oder -methode aufgerufen.
Mit dem Schlüsselwort super spricht man die Elternklasse an. Mit dem Schlüsselwort self spricht man die eigene Klasse an. Mit dem Schlüsselwort this spricht man die
verwendete Instanz an.
Mehrfachvererbung wird unterstützt.
Es können nur mehr als 8192 Instanzen erzeugt werden, wenn eine Klasse eine Maximalgrößenangabe hat oder eine globale Hashtable exisitiert. In diesem Fall werden die Instanzdaten
in der globalen Hashtable oder in zusätzlichen globalen Variablen gespeichert.
Große Array-Elemente werden wie normale große Arrays behandelt (siehe Arrays).

Abstrakte Klassen:
Abstrakte Klassen werden mit dem Schlüsselwort "abstract" deklariert. Von ihnen können keine
Instanzen erzeugt werden. Erbt eine Klasse, eine andere abstrakte Klasse, so muss sie sämtliche
abstrakte Methoden implementieren, um nicht mehr selbst als abstrakt zu gelten.

Mehrfachvererbung:
Überschneiden sich Elemente mehrerer geerbter Klassen, so wird vom Compiler ein Syntax-Fehler ausgegeben.
Eventuell könnte man hier noch spezielle Überschreibungsregeln festlegen.

Notation:
[ abstract ] class Klassenname [ [Maximalgröße] ] : public | private | protected Klassenname ...
{
    static self new() { } Konstruktor
    ~delete() { } Destruktor
    copy(Klassenname other) Kopierkonstruktur
    static init() { } Initialisierungsmethode

    [public | protected | private | private protected] [static] Methode | Variable [ = Startwertzuweisung ] | Aufzählung;
} globale Instanzen durch Kommata getrennt;


Private protected:
Ist ein Klassenelement "private protected", so kann darauf von Kindklassen und von Klassen des aktuellen Pakets und Klassen aus dessen Unterpaketen
zugegriffen werden.

Methoden:
Als virtuell deklarierte Methoden, werden pro Klasseninstanz gespeichert. So wird immer die unterste virtuelle Methode aufgerufen.
Virtuelle Methoden müssen zwingend threaded sein.
Achtung: Virtuelle Methoden sollten nicht im Konstruktor aufgerufen werden, da sie durch die Konstruktoren erst überschrieben
und der Klasseninstanz zugewiesen werden. Der Compiler sollte in diesem Fall eine Warnung ausgeben.

Abstrakte Methoden müssen allesamt implementiert werden. Abstrakte-Methoden-Implementationen müssen virtuell sein.

Mit super.Methodenname kann die Elternmethode angesprochen werden.

Abstrakte Methoden besitzen keinen Bezugsrahmen, sondern werden mit einem Semikolon abgeschlossen.

Methoden, die mit dem Postfix "const" deklariert wurden, erhalten das Argument this als konstante Variable.

Notation:
[static | virtual | abstract] Funktionsdeklaration [const]

Operatorenüberladung:
Eine Funktions- oder Methodendeklaration, welche das Schlüsselwort operator und ein zugehöriges Operatorzeichen enthält, überlädt die Bedeutung eines Operators für die angegebenen
Parametertypen.
Dies kann global, innerhalb eines Pakets oder innerhalb einer Klasse usw. geschehen (private, protected, public, private protected).

Kompatibilität zu Jass:
Jass-Funktionen und -Variablen, die innerhalb der #jass und #endjass-Präprozessoranweisungen
deklariert wurden, können von Jass++-Code normal aufgerufen werden. Dabei gilt zu beachten,
dass die Typumwandlungsregeln von Jass++ bei der Parameterübergabe gelten.
Native Funktionen und Typen können ebenfalls durch eine reine Jass-Deklaration verwendet werden
und müssen nicht erst mit den Jass++-Sprachelementen deklariert werden. Diese eignen sich eher
zur Deklaration neuer Typen und nativer Funktionen, insofern es dem Entwickler möglich ist, dies
z. B. mit Hilfe des Werkzeugs Grimoire zu bewerkstelligen.
Aus Jass heraus kann ebenfalls mittels der #jasspp- und #pjass-Präprozessoranweisungen Jass++-Code
verwendet werden, allerdings sollten die zu Jass kompilierten Jass++-Funktionen und -Variablen
aus Jass-Code heraus nicht verwendbar sein.
Es gilt hierbei noch anzumerken, dass die Verwendung von Jass++-Code in globalen Jass-Funktionen
aufgrund der Paketsortierung zu größeren Problemen führen kann, da Jass-Funktionen vor sämtlichen
Paket-Funktionen deklariert werden.

Kompatibilität zu vJass:
Momentan ist noch nicht geplant Jass++- und vJass-Code kombinierbar zu machen.
Code zwischen den Präprozessoranweisungen #vjass und #endjass wird daher bei einer Jass++-
Kompilierung ignoriert.

Kompatibilität zu Zinc:
Momentan ist noch nicht geplant Jass++- und Zinc-Code kombinierbar zu machen.
Code zwischen den Präprozessoranweisungen #zinc und #endzinc wird daher bei einer Jass++-
Kompilierung ignoriert.

Kompatibilität zu CJass:
Momentan ist noch nicht geplant Jass++- und CJass-Code kombinierbar zu machen.
Code zwischen den Präprozessoranweisungen #cjass und #endcjass wird daher bei einer Jass++-
Kompilierung ignoriert.


Standardpaket:
Es existieren Wrapper für jeden Warcraft-3-Datentyp, sowie zusätzliche Methoden und Klassen. Auf das Wichtigste beschränken!

package jasspp
{
    package jass.*;

    /*
    Definition spezieller implementationsspezifischer Funktionen.
    */
    debug
    {
	integer allocateArrayInstance();
	integer allocateClassInstance();
	boolean freeArrayInstance(integer index);
	boolean freeClassInstance(integer index);
	boolean freeFunctionPrototype(integer index);
    }

    /*
    Definitionen globaler Funktionen, welche in der Regel die nativen Typen verwenden.
    */
    void Print(string message);

    /*
    Definitionen der Wrapper-Klassen, welche die Funktionalität der nativen Typen mittels Objektorientierung anbieten.
    */
    class Boolean
    class String
    class Integer
    class Real
    class Code
    class Handle
    class Agent : public Handle
    class Widget : public Agent
    class Unit : Widget
    class Item : Widget
    class Destructable : Widget
    class Event
    class Trigger
    
    /*
    Definition eigener Klassen wie z. B. verschiedener Container-Klassen usw.
    */
    class List
    class Vector
    class Map
    class Bitset

}

Virtuelle-Maschinen-Implementation:
Falls es eines Tages möglich sein sollte, eine eigene virtuelle Maschine für Jass bzw. Jass++ zu schreiben, so sollten folgende native Funktionen hinzugefügt werden:
* native RMin takes real a, real b returns real
* native RMax takes real a, real b returns real
* native RAbs takes real a returns real
* native RSign takes real a returns real
* native RMod takes real dividend, real divisor returns real
* native IMin takes integer a, integer b returns integer
* native IMax takes integer a, integer b returns integer
* native IAbs takes integer a returns integer
* native ISign takes integer a returns integer
* native IMod takes integer dividend, integer divisor returns integer
* native StringIndex takes string source, string target returns integer
* native GroupCount takes group whichGroup returns integer
* native GroupUnit takes group whichGroup, integer index returns unit
* native ForceCount takes force whichForce returns integer
* native ForcePlayer takes force whichForce, integer index returns player
* native EvaluateFunc takes string funcName returns boolean
* native TriggerRemoveEvent takes trigger whichTrigger, event whichEvent returns nothing
* native TriggerClearEvents takes trigger whichTrigger returns nothing
* native TriggerCountEvents takes trigger whichTrigger returns integer
* native TriggerCountConditions takes trigger whichTrigger returns integer
* native TriggerCountActions takes trigger whichTrigger returns integer
* native TriggerSyncStop takes nothing returns nothing
* native UnitAddBuff takes unit whichUnit, integer buffId returns boolean
* native UnitRemoveBuff takes unit whichUnit, integer buffId returns boolean
* native UnitHasBuff takes unit whichUnit, integer buffId returns boolean
* native TriggerRegisterPlayerKeyEvent takes trigger whichTrigger, player whichPlayer, key whichKey, boolean pressed returns event
* native HasPlayerKeyPressed takes player whichPlayer, key whichKey returns boolean
* native GetPlayerMouseX takes player whichPlayer returns real
* native GetPlayerMouseY takes player whichPlayer returns real
* native GetPlayerPing takes player whichPlayer returns real
* native SetPlayerMinimap takes player whichPlayer, string filePath returns nothing
* native EnablePlayerMinimap takes player whichPlayer, boolean enable returns nothing 
* native IsPlayerMinimapEnabled takes player whichPlayer returns boolean
* native RemoveTrackable takes trackable whichTrackable returns nothing
* native TrackableShow takes trackable whichTrackable, boolean show returns nothing
* native TrackableIsShown takes trackable whichTrackable returns boolean
* native TrackableSetModelPath takes trackable whichTrackable, string modelPath returns nothing
* native TrackableModelPath takes trackable whichTrackable returns string
* native TrackableSetX takes trackable whichTrackable, real x returns nothing
* native TrackableX takes trackable whichTrackable returns real
* native TrackableSetY takes trackable whichTrackable, real y returns nothing
* native TrackableY takes trackable whichTrackable returns real
* native TrackableSetFacing takes trackable whichTrackable, real facing returns nothing
* native TrackableFacing takes trackable whichTrackable returns real
* native QuestRemoveItem takes questitem whichQuestItem returns nothing

Zudem sollte die umständliche Lösung zur Umgehung der Array-Größe mittels Hashtables wegfallen
und es dem Benutzer erlaubt werden, dynamisch Speicher zu allozieren. Allerdings mit vernünftigen
Absicherungen und Wertsetzungen bei Fehlschlägen.

Compiler-Implementation:

Schritte:
1. Konstante Ausdrücke sammeln (auch in zu importierenden Dateien)
2. Präprozessoren (auch Injections) auswerten und zu ignorierenden, importierenden Code und als vJass-Code, Zinc- oder Jass-Code zu behandelten Code feststellen (am besten Zeilennummern und Datei merken und abfragen, Testblöcke miteinbeziehen!).
3. Code einlesen
4. Syntax überprüfen
5. Vorlagen-Instanzen generieren (Templates) und zum zu behandelten Code hinzufügen
6. Kartenskript erzeugen oder einlesen und Positionen feststellen
7. Pakete sortieren
8. Globale Hashtable erzeugen/Laufzeitglobale erzeugen
8.1 Globale Hashtable
8.2 Laufzeitglobale
9. Paket- und Klassenvariablen generieren (auch von Enums)
10. Zugriffsfunktionen generieren
10.1 Zugriffsfunktionen für globale Hashtable
10.2 Zugriffsfunktionen für Laufzeitglobale
10.3 Zugriffsfunktionen für Funktionen/Methoden mit gleichem Namen
11. Funktionen generieren (auch mit gleichem Namen und richtigen Bezeichnern usw.)
12. Methoden generieren (auch mit gleichem Namen und richtigen Bezeichnern usw.)
13. InitJassPP generieren
14. Bei aktivierter Option Kartenskript optimieren. Mögliche Optionen:
	--ormws Entfernt white-space-Zeichen, leere Zeilen und Kommentare
	--orn Benennt sämtliche Bezeichner zu kürzeren, generierten um
	--oinline Kopiert den Funktionsinhalt bestimmter Funktionen (z. B. ohne Parameter) in den Code

8. Globale Hashtable erzeugen/Laufzeitglobale erzeugen

8.1 Globale Hashtable
Ist der Hashtable-Modus aktiviert, so wird eine globale Variable namens __hashtable des Typs hashtable in das Kartenskript
eingefügt.
Die globale Hashtable wird für Funktionsparameter von .executewait-, .execute- und .evaluate-Aufrufen, Klasseninstanzen und Arrayinstanzen verwendet.
Sie wird in der main-Funktion der Karte nach dem Aufruf der InitBlizzard-Funktion in der Funktion InitJassPP erzeugt.
Nach ihr werden sämtliche Prototypauslöser erzeugt.

Kategorie "Data":
	* Label "FunctionPrototypes" Typ integer Wert <Anzahl der Funktionsprototypen> // Eventuell nur im Debug-Modus, wird zur Laufzeit normalerweise nicht benötigt.
	* Label "ClassInstances" Typ integer Wert <Anzahl der Klasseninstanzen>
	* Label "ArrayInstances" Typ integer Wert <Anzahl der Array-Instanzen>

// TODO: globale Array-Variable mit Auslösern?
Kategorie "FunctionPrototype<n>":
	* Label "Trigger" Typ trigger Wert <Zugehöriger Auslöser>
	* Label "Argument<n>" Typ <Argument<n>-Typ der Funktion> Wert <Argument<n>-Wert gesetzt durch den letzten Aufruf>

Kategorie "ClassInstance<n>":
	* Label "MethodFunctionPrototype<Name der virtuellen Methoden>" Typ integer Wert <Nummer des Funktionsprototypes der virtuellen Methode>
	* Label "Member<Elementname>" Typ <Elementtyp> Wert <Elementwert>

Kategorie "ArrayInstance<n>":
	* Label "Index<Index>" Typ <Arraytyp> Wert <Arraywert des Indexes>

Wurden bei einer Klasse oder einem Array Maximalgrößen angegeben, so werden diese innerhalb der generierten Zugriffsfunktionen (siehe 10.1 Zugriffsfunktionen für globale Hashtable)
überprüft und entsprechend verfahren, wenn das Maximum erreicht wurde.

8.2 Laufzeitglobale
1. sämtliche Prototypfunktionsauslöser-, Prototypfunktionsargument- und Prototypfunktionsrückgabewert-Globalen ins Kartenskript einfügen
2. sämtliche 

13. InitJassPP generieren
Falls der Hashtable-Modus aktiviert ist, Klassen mit Maximalgrößen über JASS_MAX_ARRAY_SIZE, Arrays mit Maximalgrößen über
JASS_MAX_ARRAY_SIZE oder irgendeine Art von Funktionsprototyp existiert (durch "virtual" bzw. "threaded" Methoden/Funktionen),
wird die Funktion InitJassPP generiert, in welcher entweder die Hashtable erzeugt und gefüllt wird oder alle Prototypfunktionsauslöser in globale Variablen geschrieben werden.
Die Funktion wird nach der Funktion InitBlizzard in der Funktion main des Kartenskripts aufgerufen.

10. Zugriffsfunktionen generieren


10.1 Zugriffsfunktionen für globale Hashtable


10.2 Zugriffsfunktionen für Laufzeitglobale
Threaded Funktionen/Funktionsprototypen:
Pro "threaded" Funktion bzw. Methode wird ein globaler Auslöser erzeugt, der den Funktionsinhalt
enthält, allerdings keine Parameter entgegen nimmt. Die Parameter werden in lokale Variablen aus
globalen Parametervariablengeladen bzw. vor dem
Aufruf gesetzt.
Die Prototypauslöser werden in einem oder mehreren Arrays gespeichert und wie Klassenelemente indiziert,
insofern keine globale Hashtable verwendet wird. Für die Prototypargumente existieren pro Argumenttyp
und der maximal benötigten Anzahl dieser in einer Funktion ebenfalls globale Variablen.
Prototypfunktionen sind statisch und werden normalerweise nicht zur Laufzeit verändert, weshalb
man keine Index-Auswertungsfunktionen braucht, da der Compiler stets die richtigen Variablen
einfügen sollte.
Achtung: Der Compiler muss beim Verwenden einer neuen globalen Variable, immer die Größe
der bereits verwendeten Arrays abziehen (siehe Klassenelementezugriff).

globals
	trigger array __prototypeFunctionTriggers0
	trigger array __prototypeFunctionTriggers1
	<Parametertyp0> array __prototypeFunctionArguments0__<Parametertyp0>
	<Parametertyp0> array __prototypeFunctionArguments1__<Parametertyp0>
	<Parametertyp1> array __prototypeFunctionArguments0__<Parametertyp1>
	<Parametertyp1> array __prototypeFunctionArguments1__<Parametertyp1>
	<Rückgabetyp0> array __prototypeFunctionReturnValues0__<Rückgabetyp0>
endglobals

function __prototypeFunction<Prototypnummer> takes nothing returns nothing
	local <Parametertyp0> <Parametername0> = __prototypeFunctionArguments0__<Parametertyp0>[<Prototypnummer>]
	local <Parametertyp1> <Parametername1> = __prototypeFunctionArguments0__<Parametertyp1>[<Prototypnummer>]
	set __prototypeFunctionReturnValues0__<Rückgabetyp0> = <Parametername0> * <Parametername1>
endfunction

// Kann auch ohne Funktion in den Code kopiert werden.
function __init__PrototypeFunction<Prototypnummer> takes nothing returns nothing
	set __prototypeFunctionTriggers0[<Prototypnummer>] = CreateTrigger()
	call TriggerAddAction(__prototypeFunctionTriggers0[<Prototypnummer>], function __prototypeFunction<Prototypnummer>)
endfunction

// Kann auch ohne Funktion in den Code kopiert werden.
// Für den Debug-Modus.
function __free__PrototypeFunction<Prototypnummer> takes nothing returns nothing
	call TriggerClearActions(__prototypeFunctionTriggers0[<Prototypnummer>])
	call DestroyTrigger(__prototypeFunctionTriggers0[<Prototypnummer>])
	set __prototypeFunctionTriggers0[<Prototypnummer>] = null
endfunction

// Kann auch ohne Funktion in den Code kopiert werden.
// Für .evaluations.
function __evaluations__prototypeFunction<Prototypnummer> takes nothing returns integer
	return GetTriggerEvalCount(__prototypeFunctionTriggers0[<Prototypnummer>])
endfunction

// Kann auch ohne Funktion in den Code kopiert werden.
// Für .executions.
function __executions__prototypeFunction<Prototypnummer> takes nothing returns integer
	return GetTriggerExecCount(__prototypeFunctionTriggers0[<Prototypnummer>])
endfunction

function testEvaluation takes nothing returns nothing
	local <Rückgabetyp0> result
	set __prototypeFunctionArguments0__<Parametertyp0>[<Prototypnummer>] = <Parameter0>
	set __prototypeFunctionArguments0__<Parametertyp1>[<Prototypnummer>] = <Parameter1>
	call TriggerEvaluate(__prototypeFunctionTriggers0[<Prototypnummer>])
	set result = __prototypeFunctionReturnValues0__<Rückgabetyp0>
endfunction

Klasseninstanzen ohne globale Hashtable:
Pro Klassenelement wird eine globale Arrayvariable deklariert deren Indexwerte der jeweiligen Instanz gehören. Außerdem wird
eine Konstante definiert, welche bestimmt, wie viele Instanzen der Klasse erzeugt werden können. Dies hängt unter anderem
davon ab, ob die Klasse Array-Elemente besitzt.
Pro virtuelle Methode wird eine globale Arrayvariable deklariert, welcher der Prototypindex bei der Instanzerzeugung zugewiesen wird.
Bei der Allokation wird in einer globalen Zählervariable nach einer freien Id gesucht und diese verwendet. 0 zählt dabei als leerer Wert.
Kindklassen erhalten KEINE eigene Zählervariable, da ansonsten das Konzept der virtuellen Methoden nicht funktioniert und nicht auf die Elemente
der Elternklasse zugegriffen werden könnte, ohne diese neu zu deklarieren.
Wurde die Klasse als "big" deklariertt und wird keine globale Hashtable verwendet, so wird je nach Größe pro 8192 (8191?)-Block eine globale
Array-Variable für jedes Element und jede virtuelle Methode erzeugt. Außerdem werden Zugriffsfunktionen für die virtuellen Methoden und Elemente
generiert, welche bei Zugriffen anstatt eines normalen Zugriffs verwendet werden (automatische Ersetzung):
globals
	constant integer __<Paketnamen getrennt durch doppelte Unterstriche>__<Klassenname>__size
	boolean array __<Paketnamen getrennt durch doppelte Unterstriche>__<Klassenname>0
	boolean array __<Paketnamen getrennt durch doppelte Unterstriche>__<Klassenname>1
	<Elementtyp> array __<Paketnamen getrennt durch doppelte Unterstriche>__<Klassenname>__<Elementname>0
	<Elementtyp> array __<Paketnamen getrennt durch doppelte Unterstriche>__<Klassenname>__<Elementname>1
	integer array __<Paketnamen getrennt durch doppelte Unterstriche>__<Klassenname>__<Methodenname>0
	integer array __<Paketnamen getrennt durch doppelte Unterstriche>__<Klassenname>__<Methodenname>1
endglobals

Allokation:

function __newparent__<Paketnamen getrennt durch doppelte Unterstriche>__<Klassenname> takes nothing returns integer
	local integer i = 0
	loop
		exitwhen (i == IMax(1, __<Paketnamen getrennt durch doppelte Unterstriche>__<Klassenname>__size / JASS_MAX_ARRAY_SIZE))
		set j = 0
		loop
			exitwhen (id == IMin(__<Paketnamen getrennt durch doppelte Unterstriche>__<Klassenname>__size, JASS_MAX_ARRAY_SIZE))
			if (i == 0) then // Benutze Array-Variable 0
				if (not __<Paketnamen getrennt durch doppelte Unterstriche>__<Klassenname>[j]) then
					set __<Paketnamen getrennt durch doppelte Unterstriche>__<Klassenname>0[j] = true
					return i * j
				endif
			elseif (i == 1) then // Benutze Array-Variable 1
				if (not __<Paketnamen getrennt durch doppelte Unterstriche>__<Klassenname>[j]) then
					set __<Paketnamen getrennt durch doppelte Unterstriche>__<Klassenname>1[j] = true
					return i * j
				endif
			endif
			set j = j + 1
		endloop
		set i = i + 1
	endloop
#if (DEBUG_MODE)
		call DisplayTimedTextToPlayer(GetLocalPlayer(), 0.0, 0.0, 1000.0, "Unable to allocate id for an instance of class \"<Paketnamen getrennt durch Punkte><Klassenname>\". Maximum size is " + I2S(__<Paketnamen getrennt durch doppelte Unterstriche>__<Klassenname>__size) + ".")
#endif
	return 0
endfunction

// Eventuell Variable automatisch auf 0 setzen?
function __deleteparent__<Paketnamen getrennt durch doppelte Unterstriche>__<Klassenname> takes integer id returns nothing
#if (DEBUG_MODE)
	if (id <= 0 or id >= __<Paketnamen getrennt durch doppelte Unterstriche>__<Klassenname>__size) then
		call DisplayTimedTextToPlayer(GetLocalPlayer(), 0.0, 0.0, 1000.0, "Unable to free id " + I2S(id) + " for an instance of class \"<Paketnamen getrennt durch Punkte><Klassenname>\". Maximum size is " + I2S(__<Paketnamen getrennt durch doppelte Unterstriche>__<Klassenname>__size) + ".")
		return
	endif
#endif
	if (id < JASS_MAX_ARRAY_SIZE) then // Benutze Array-Variable 0
		set __<Paketnamen getrennt durch doppelte Unterstriche>__<Klassenname>0[id] = false
	elseif (id < 2 * JASS_MAX_ARRAY_SIZE) then // Benutze Array-Variable 1
		set __<Paketnamen getrennt durch doppelte Unterstriche>__<Klassenname>1[id] = false
	endif
endfunction

// Die Elementzugriffsfunktionen gelten ebenso für virtuelle Methoden

function __setMember__<Elementname>__<Paketnamen getrennt durch doppelte Unterstriche>__<Klassenname> takes integer id, <Elementtyp> value returns nothing
#if (DEBUG_MODE)
	if (id < 0 or __<Paketnamen getrennt durch doppelte Unterstriche>__<Klassenname>__size) then
		call DisplayTimedTextToPlayer(GetLocalPlayer(), 0.0, 0.0, 1000.0, "Unable to set member <Elementname> of type <Elementtyp> for instance " + I2S(id) + " of class \"<Paketnamen getrennt durch Punkte><Klassenname>\". Maximum size is " + I2S(__<Paketnamen getrennt durch doppelte Unterstriche>__<Klassenname>__size) + ".")		
		return
	endif
#endif
	if (id < JASS_MAX_ARRAY_SIZE) then // Benutze Array-Variable 0
		set __<Paketnamen getrennt durch doppelte Unterstriche>__<Klassenname>__<Elementname>0[id] = value
	elseif (id < 2 * JASS_MAX_ARRAY_SIZE) then // Benutze Array-Variable 1
		set __<Paketnamen getrennt durch doppelte Unterstriche>__<Klassenname>__<Elementname>1[id] = value
	endif
endfunction

function __member__<Elementname>__<Paketnamen getrennt durch doppelte Unterstriche>__<Klassenname> takes integer id returns <Elementtyp>
#if (DEBUG_MODE)
	if (id < 0 or __<Paketnamen getrennt durch doppelte Unterstriche>__<Klassenname>__size) then
		call DisplayTimedTextToPlayer(GetLocalPlayer(), 0.0, 0.0, 1000.0, "Unable to get member <Elementname> of type <Elementtyp> for instance " + I2S(id) + " of class \"<Paketnamen getrennt durch Punkte><Klassenname>\". Maximum size is " + I2S(__<Paketnamen getrennt durch doppelte Unterstriche>__<Klassenname>__size) + ".")		
		return <Elementtypnullwert>
	endif
#endif
	if (id < JASS_MAX_ARRAY_SIZE) then // Benutze Array-Variable 0
		return __<Paketnamen getrennt durch doppelte Unterstriche>__<Klassenname>__<Elementname>0[id]
	elseif (id < 2 * JASS_MAX_ARRAY_SIZE) then // Benutze Array-Variable 1
		return __<Paketnamen getrennt durch doppelte Unterstriche>__<Klassenname>__<Elementname>1[id]
	endif
	return <Elementtypnullwert>
endfunction

// Existiert auch für Kindklassen.
function __initMembers__<Paketnamen getrennt durch doppelte Unterstriche>__<Klassenname> takes integer id returns nothing
	call __setMember__<Elementname>__<Paketnamen getrennt durch doppelte Unterstriche>__<Klassenname>(id, <Startwert>)
endfunction

// Existiert auch für Kindklassen.
function __initVirtualMethods__<Paketnamen getrennt durch doppelte Unterstriche>__<Klassenname> takes integer id returns nothing
	call __setMember__<Elementname>__<Paketnamen getrennt durch doppelte Unterstriche>__<Klassenname>(id, <Funktionsprototyp-Id der virtuellen Methode>)
endfunction

// Existiert auch für Kindklassen.
function __resetMembers__<Paketnamen getrennt durch doppelte Unterstriche>__<Klassenname> takes integer id returns nothing
	call __setMember__<Elementname>__<Paketnamen getrennt durch doppelte Unterstriche>__<Klassenname>(id, <Nullwert>)
endfunction

// Existiert auch für Kindklassen.
function __resetVirtualMethods__<Paketnamen getrennt durch doppelte Unterstriche>__<Klassenname> takes integer id returns nothing
	call __setMember__<Elementname>__<Paketnamen getrennt durch doppelte Unterstriche>__<Klassenname>(id, 0)
endfunction

// Existiert auch für Kindklassen.
function __new__<Paketnamen getrennt durch doppelte Unterstriche>__<Klassenname> takes nothing returns integer
	local integer id = __newparent__<Paketnamen getrennt durch doppelte Unterstriche>__<Klassenname>()
#if (DEBUG_MODE)
	if (id == 0) then
		return
	endif
#endif
	call __initMembers__<Paketnamen getrennt durch doppelte Unterstriche>__<Klassenname>(id) // Falls Elemente vorhanden.
	call __initVirtualMethods__<Paketnamen getrennt durch doppelte Unterstriche>__<Klassenname>(id) // Falls virtuelle Methoden vorhanden.
endfunction

// Existiert auch für Kindklassen. Eventuell Variable automatisch auf 0 setzen?
function __delete__<Paketnamen getrennt durch doppelte Unterstriche>__<Klassenname> takes integer id returns nothing
	call __deleteparent__<Paketnamen getrennt durch doppelte Unterstriche>__<Klassenname>(id)
#if (DEBUG_MODE)
	if (id <= 0 or id >= __<Paketnamen getrennt durch doppelte Unterstriche>__<Klassenname>__size) then
		call DisplayTimedTextToPlayer(GetLocalPlayer(), 0.0, 0.0, 1000.0, "Unable to free id " + I2S(id) + " for an instance of class \"<Paketnamen getrennt durch Punkte><Klassenname>\". Maximum size is " + I2S(__<Paketnamen getrennt durch doppelte Unterstriche>__<Klassenname>__size) + ".")
		return
	endif
#endif
	call __resetMembers__<Paketnamen getrennt durch doppelte Unterstriche>__<Klassenname>(id) // Falls Elemente vorhanden.
	call __resetVirtualMethods__<Paketnamen getrennt durch doppelte Unterstriche>__<Klassenname>(id) // Falls virtuelle Methoden vorhanden.
endfunction

Methoden:
Methoden werden wie Funktionen nach ihren unterschiedlichen Parametern in Bezeichner durchnummeriert.

boolean test(integer a, integer b)
{
	return a + b + this.m_x;
}

wird ersetzt durch

function __<Paketnamen getrennt durch doppelte Unterstriche>__<Klassenname>__test0 takes integer this, integer a, integer b returns boolean
	return a + b + __member__m_x__<Paketnamen getrennt durch doppelte Unterstriche>__<Klassenname>(this)
endfunction

/*
Threaded Methoden:

threaded void test(integer a, integer b)
{
}

wird ersetzt durch

function __FunctionPrototype<n> takes nothing returns nothing
	local integer this = LoadInteger(__hashtable, StringHash("FunctionPrototype<n>"), StringHash("this"))
	local integer a = LoadInteger(__hashtable, StringHash("FunctionPrototype<n>"), StringHash("a"))
	local integer b = LoadInteger(__hashtable, StringHash("FunctionPrototype<n>"), StringHash("b"))
endfunction

und in der Initialisierungsfunktion mit folgendem initialisiert

local trigger prototypeTrigger = CreateTrigger()
call TriggerAddAction(prototypeTrigger, function __<Paketnamen getrennt durch doppelte Unterstriche>__<Klassenname>__test)
SaveTriggerHandle(__hashtable, StringHash("FunctionPrototype<n>"), StringHash("Trigger"), prototypeTrigger)
set prototypeTrigger = null

this.myVirtualMethod().execute(a, b)

wird ersetzt durch

call SaveInteger(__hashtable, StringHash("FunctionPrototype" + I2S(__<Paketnamen getrennt durch doppelte Unterstriche>__<Klassenname>__<Methodenname>[this])), StringHash("this"), this)
call SaveInteger(__hashtable, StringHash("FunctionPrototype" + I2S(__<Paketnamen getrennt durch doppelte Unterstriche>__<Klassenname>__<Methodenname>[this])), StringHash("Argument0"), a)
call SaveInteger(__hashtable, StringHash("FunctionPrototype" + I2S(__<Paketnamen getrennt durch doppelte Unterstriche>__<Klassenname>__<Methodenname>[this])), StringHash("Argument1"), b)
call TriggerExecute(LoadTriggerHandle(__hashtable, StringHash("FunctionPrototype" + I2S(__<Paketnamen getrennt durch doppelte Unterstriche>__<Klassenname>__<Methodenname>[this]))), StringHash("Trigger"))
*/

10.3 Zugriffsfunktionen für Funktionen/Methoden mit gleichem Namen

11. Funktionen generieren
Jass-Funktionen, die zwischen den Präprozessoranweisungen #jass und #endjass deklariert wurden,
werden vor sämtlichen in Jass++-Paketen enthaltenen Funktionen in das Kartenskript geschrieben.
Daher sind sie aus Jass++ allesamt verwendbar. Dabei werden sie in der Einlesereihenfolge des Parsers
gelassen.

ALT:
Globale Array-Variablen:
Ist ein Array oder eine Klasse nicht als "big" deklariert, so werden ihre Instanzelemente nicht in der globalen Hashtable, sondern in 

Ersetzung von threaded Funktionsaufrufen:
Jede Funktion und Methode, welche threaded ist, erhält beim Kompilieren eine eigene Funktionsprototyp-Id. Für jede Funktionsprototyp-Id
wird eine Jass-Funktion generiert, welche keine Argumente entgegennimmt, sondern stattdessen die Argumente aus der globalen Hashtable
in lokale Variablen lädt.
Diese Funktion wird einem generierten Auslöser als Aktion hinzugefügt.
Bei jedem Aufruf einer solchen Funktion, werden zunächst alle Parameter in der globalen Hashtable gespeichert und dann der Auslöser entweder
mittels TriggerEvaluate, TriggerExecute oder TriggerExecuteWait aufgerufen.
Handelt es sich um eine virtuelle Methode, so wird der generierte Auslöser in der globalen Hashtable als solcher für den Funktionsprototypen gespeichert
und beim Aufruf mittels der Klasseninstanz ermittelt und verwendet.

Aufruf von init Funktionen:
"init"-Funktionen besitzen keine Argumente. Sie werden automatisch vor dem Aufruf der Funktion RunInitializationTriggers aufgerufen.
Dies geschieht normalerweise in unbestimmter Reihenfolge (je nachdem, welche der Compiler zu erst findet und wie er sie sortiert).
Besitzt eine "init"-Funktion einen Rückgabetyp oder wird manuell von einem anderen Punkt aus aufgerufen, so sollte eine Warnung ausgegeben werden.

Präprozessoren:

Klasseninstanzen:
Klasseninstanzen sind Variablen des Typs integer. Sie verweisen in der globalen Hashtable auf die Kategorie ihrer Zahl "ClassInstance<Zahl>".
Wird die Instanz freigegeben, so wird ihre Kategorie in der Hashtable gelöscht. Bei einer dynamischen Erzeugung mittels new, wird von 1 an hochgezählt
und nach einer noch nicht verwendeten Kategorie gesucht.
In der Kategorie werden unter den Elementnamen in Form von Labels alle Werte der Klasseninstanz gespeichert:
Object myObject = new Object();
speichert folgendermaßen:
Globale Hashtable
    * Kategorie: "ClassInstance1"
	* Label: "m_x" Typ real Wert: 0.0
	* Label: "m_y" Typ real Wert: 0.0

Der Zugriff auf Hashtables ist zwar langsamer als auf Arrays, jedoch kann die Hashtable praktisch mit unendlich vielen Instanzen gefüllt werden und beschränkt sich nicht
auf 8192 bzw. 8191.

Testblöcke:
Der Inhalt von Testblöcken, die mittels debug { } deklariert wurden, wird im Nicht-Debug-Modus nicht kompiliert, sondern einfach ignoriert.

Arrays:
Bei mehrdimensionalen Arrays wird automatisch entweder die Indexberechnung durchgeführt oder eine Funktion des Standardpakets aufgerufen, welche dieses durchführt und überprüft, ob der Index größer als 8191 ist.
Dies wird ebenfalls zur Compile-Zeit, insofern möglich, geprüft.
Wurde das Array als "big" deklariert, so werden sämtliche Lese- und Schreibzugriffe durch Hashtable-modifizierende Funktionsaufrufe ersetzt.
Außerdem wird bei jedem Setzungsaufruf überprüft, ob das Array bereits in der Hashtable gespeichert wurde und falls nicht, so wird dies vorgenommen.
Dabei wird eine Funktion aufgerufen, welche eine freie Id für eine Array-Instanz liefert. Sämtliche Lesezugriffe werden durch Funktionsaufrufe mit der
in der Variable gespeicherten Id vorgenommen, weshalb das Array in Jass kein Array, sondern nur eine integer-Variable mit der jeweiligen Id ist.
Handelt es sich um eine lokale Variable, so wird am Ende der Funktion automatisch eine Flush-Funktion aufgerufen, insofern das Array nicht bereits vorher auf 0 gesetzt wurde. Setzt man das Array auf 0, so wird es aus der Hashtable geflusht (und in Jass auf 0 gesetzt!).
Globale Hashtable
	* Kategorie: "Array<n>"
		* Label "Index<n>" Typ <Variablentyp> Wert <Wert>

Funktionen:
Threaded-Funktionen können mit .execute oder .evaluate (falls der Rückgabetyp boolean ist und sie keine TriggerSleepAction-Aufrufe enthält) aufgerufen werden.
Falls TriggerExecuteWait bewirkt, dass ein Auslöser mit TriggerSleepAction-Aufrufen ausgeführt wird und denn noch gewartet wird, bis dieser ausgeführt wurde, so gibt es zudem noch das Schlüsselwort .executewait.
Der Code Inhalt wird in einem globalen Auslöser gespeichert.
Die Parameter werden beim Aufruf in der globalen Hashtable unter der Id des Auslösers bzw. der "Prototypfunktion" gespeichert und beim Aufruf sofort in lokale Variablen geschrieben.
Der Aufruf erfolgt schließlich mit TriggerExecute, TriggerExecuteWait oder TriggerEvaluate.
Handelt es sich um eine virtuelle Methode, so muss der jeweilige Auslöser zunächst über die Klasseninstanz herausgefunden werden.
Mittels der Schlüsselwörter executions und evaluations kann die Anzahl der jeweiligen Aufrufe einer "threaded" Funktion herausgefunden werden.
Dazu werden diese mit den Funktionen GetTriggerExecCount bzw. GetTriggerEvalCount ersetzt und der Prototypauslöser als Parameter übergeben.
Wird dies bei einer Nicht-"threaded"-Funktion versucht, so wird ein Compiler-Fehler ausgegeben.

Methoden:
Da alle Methoden virtuell sind, muss schon beim Kompilieren (anhand der Typenumwandlungen) festgestellt werden, welchen Typ die Variable momentan hat
und anhand des Typs die richtige Methode aufgerufen werden.
