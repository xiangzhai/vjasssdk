Virtuelle-Maschine-Implementation:
Falls es eines Tages möglich sein sollte, eine eigene virtuelle Maschine für Jass bzw. Jass++ zu schreiben, so sollten folgende native Funktionen hinzugefügt werden:
* native RMin takes real a, real b returns real
* native RMax takes real a, real b returns real
* native RAbs takes real a returns real
* native RSign takes real a returns real
* native RMod takes real dividend, real divisor returns real
* native IMin takes integer a, integer b returns integer
* native IMax takes integer a, integer b returns integer
* native IAbs takes integer a returns integer
* native ISign takes integer a returns integer
* native IMod takes integer dividend, integer divisor returns integer
* native StringIndex takes string source, string target returns integer
* native GroupCount takes group whichGroup returns integer
* native GroupUnit takes group whichGroup, integer index returns unit
* native ForceCount takes force whichForce returns integer
* native ForcePlayer takes force whichForce, integer index returns player
* native EvaluateFunc takes string funcName returns boolean
  
Trigger-API:
* native TriggerRemoveEvent takes trigger whichTrigger, event whichEvent returns nothing
* native TriggerClearEvents takes trigger whichTrigger returns nothing
* native TriggerCountEvents takes trigger whichTrigger returns integer
* native TriggerCountConditions takes trigger whichTrigger returns integer
* native TriggerCountActions takes trigger whichTrigger returns integer
* native TriggerSyncStop takes nothing returns nothing
  
Unit-API:
* native UnitAddBuff takes unit whichUnit, integer buffId returns boolean
* native UnitRemoveBuff takes unit whichUnit, integer buffId returns boolean
* native UnitHasBuff takes unit whichUnit, integer buffId returns boolean
* native GetHeroStrBonus takes unit whichHero returns integer
* native GetHeroAgiBonus takes unit whichHero returns integer
* native GetHeroIntBonus takes unit whichHero returns integer
  
Player-API:
* native TriggerRegisterPlayerKeyEvent takes trigger whichTrigger, player whichPlayer, key whichKey, boolean pressed returns event
* native HasPlayerKeyPressed takes player whichPlayer, key whichKey returns boolean
* native GetPlayerMouseX takes player whichPlayer returns real
* native GetPlayerMouseY takes player whichPlayer returns real
* native GetPlayerPing takes player whichPlayer returns real
* native SetPlayerMinimap takes player whichPlayer, string filePath returns nothing
* native EnablePlayerMinimap takes player whichPlayer, boolean enable returns nothing 
* native IsPlayerMinimapEnabled takes player whichPlayer returns boolean
  
Trackable-API:
* native RemoveTrackable takes trackable whichTrackable returns nothing
* native TrackableShow takes trackable whichTrackable, boolean show returns nothing
* native TrackableIsShown takes trackable whichTrackable returns boolean
* native TrackableSetModelPath takes trackable whichTrackable, string modelPath returns nothing
* native TrackableModelPath takes trackable whichTrackable returns string
* native TrackableSetX takes trackable whichTrackable, real x returns nothing
* native TrackableX takes trackable whichTrackable returns real
* native TrackableSetY takes trackable whichTrackable, real y returns nothing
* native TrackableY takes trackable whichTrackable returns real
* native TrackableSetFacing takes trackable whichTrackable, real facing returns nothing
* native TrackableFacing takes trackable whichTrackable returns real
  
Multiboard-API:
* native MultiboardGetTitleTextColorRed takes multiboard lb returns integer
* native MultiboardGetTitleTextColorGreen takes multiboard lb returns integer
* native MultiboardGetTitleTextColorBlue takes multiboard lb returns integer
* native MultiboardGetTitleTextColorAlpha takes multiboard lb returns integer
* native MultiboardGetItemStyleShowValue takes multiboard lb returns boolean
* native MultiboardGetItemStyleShowIcon takes multiboard lb returns boolean
* native MultiboardGetItemValue takes multiboard lb returns string
* native MultiboardGetItemValueColorRed takes multiboard lb returns integer
* native MultiboardGetItemValueColorGreen takes multiboard lb returns integer
* native MultiboardGetItemValueColorBlue takes multiboard lb returns integer
* native MultiboardGetItemValueColorAlpha takes multiboard lb returns integer
* native MultiboardGetItemWidth takes multiboard lb returns real
* native MultiboardGetItemIcon takes multiboard lb returns string
  
Quest-API:
* native QuestRemoveItem takes questitem whichQuestItem returns nothing
  
Der Typ "mdlx" stellt nur eine nicht veränderbare Referenz auf eine Modeldatei dar.
type mdlx extends agent // ist referenzbasiert, keine Kopierung
type model extends agent // ist referenzbasiert, keine Kopierung

* native CreateMdlx takes string filePath returns mdlx
* native DestroyMdlx takes string filePath returns nothing
* native GetMdlxGeosets takes mdlx whichMdlx returns integer
* native GetMdlxMaterials takes mdlx whichMdlx returns integer
* native GetMdlxAnimations takes mdlx whichMdlx returns integer
* native GetMdlxAnimation taks mdlx whichMdlx, integer index returns string
...
  
* native CreateModel takes mdlx whichMdlx, real x, real y, real z returns model
* native RemoveModel takes mdlx whichMdlx returns nothing
* native SetModelTranslationX takes mdlx whichMdlx, real x returns nothing
* native SetModelTranslationY takes mdlx whichMdlx, real y returns nothing
* native SetModelTranslationZ takes mdlx whichMdlx, real z returns nothing
* native SetModelRotationX takes mdlx whichModel, real angle returns nothing
* native SetModelRotationY takes mdlx whichModel, real angle returns nothing
* native SetModelRotationZ takes mdlx whichModel, real angle returns nothing
* native SetModelScalingX takes mdlx whichModel, real factor returns nothing
* native SetModelScalingY takes mdlx whichModel, real factor returns nothing
* native SetModelScalingZ takes mdlx whichModel, real factor returns nothing
...

Zudem sollte die umständliche Lösung zur Umgehung der Array-Größe mittels Hashtables wegfallen
und es dem Benutzer erlaubt werden, dynamisch Speicher zu allozieren. Allerdings mit vernünftigen
Absicherungen und Wertsetzungen bei Fehlschlägen. 
