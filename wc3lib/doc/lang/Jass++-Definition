Mögliche Kapitelunterteilung der Sprachdefinition:
1. Vorwort
2. Laufzeit und Kompilierung
3. Kompatibilität zu anderen Sprachen
4. Schlüsselwörter
5. Kommentare
6. Präprozessoren
7. Testblöcke
8. Deklaration nativer Typen
9. Deklaration nativer Funktionen
10. Bezeichner (identifiers)
11. Literale
12. Gültigkeitsbereiche (scopes)
13. Gültigkeitsbereichverwendung
14. Qualifizierer-Gültigkeitsbereiche
15. Anweisungsblöcke
16. Variablen
17. Operatoren
18. Typen
19. Typkonvertierungen
20. Verzweigungen
21. Schleifen
22. Deklarationsvoraussetzungen
23. Funktionen
24. Funktionsvariablen (Funktionszeiger)
25. Funktionstypen
26. Lambda-Funktionen
27. Funktionsaufrufe
28. Ausnahmebehandlung
29. Finally
30. Pseudonyme (aliases)
31. Vorlagen (templates)
32. Zugriffsmodifikatoren
33. Freunde
34. Pakete (packages)
35. Aufzählungen (enums)
36. Klassen
37. Elemente
38. Methoden
39. Operatorenüberladung
40. Das Jass-Paket
41. Das Standardpaket

1. Vorwort

Limitierungen von Jass:
Jass ist eine funktionale Skriptsprache und bietet daher keine Möglichkeiten der generischen, objektorientierten
oder modularen Programmierung. Zudem wird nicht, wie z. B. in C, zwischen Deklaration und Definition streng unterschieden,
sondern ist eine Deklaration in jedem Fall auch eine Definition.
Außer dem Aufruf von Auslöser-Aktionen und -Bedingungen und dem Aufruf von Funktionen mittels ExecuteFunc gibt es keine
Möglichkeit, eine Funktion vor ihrer Definition aufzurufen. Zudem beschränken sich beide Varianten auf parameterlose
Funktionen.
Zusätzlich besitzt die Skriptsprache Jass ein Array-Größen-Limit von 8192 (2^13), Arrays können nicht als Parameter
übergeben werden, es gibt keine Funktionszeiger, Variablen des Types "code" können nicht als Array deklariert werden,
es kann nur ein globals-Block existieren, es kann kein direkter Einfluss auf automatisch generierte Funktionen
des Kartenskripts bzw. Blizzards genommen werden, auch wenn diese Fähigkeit nicht unbedingt zur Sprache selbst gehören muss,
die Syntax ist etwas unschön, da keine geschweiften Klammern, for- und while-Schleifen, sowie erweiterte Operatoren verwendet
werden können, es gibt keine Ausnahmebehandlung, es können unvermeidbare Speicherlecks entstehen und zu guter Letzt
gibt es keine Blockkommentare in Jass.

Das Problem:
Möchte man nun die Skriptsprache Jass verbessern bzw. erweitern, so müsste man verständlicherweise ihren Interpreter umschreiben.
In der Theorie lassen sich zwar viele neue Fähigkeiten planen, jedoch scheitert man an der Umsetzung, da der Quell-Code des Interpreters
bzw. derer von ganz Warcraft 3 The Frozen Throne nicht frei verfügbar ist. Nun hat man sicherlich die Option, die gesamte Warcraft-3-The-
Frozen-Throne-Engine neu zu schreiben und könnte im Zuge dessen den Interpreter anders schreiben und somit die Skriptsprache Jass verbessern,
jedoch halte ich dies für keine sinnvolle Idee, falls man nicht ein ganzes Programmiererteam hinter sich stehen hat.
Die zweite Option ist eine Erweiterung der Syntax von Jass, welche jederzeit in reinen Jass-Code konvertiert werden kann.
Dazu muss man "nur" einen Compiler bzw. Precompiler für die eigene Skriptsprache schreiben, welcher die Syntax dieser kennt und zu Jass konvertieren
kann.
Diese Option wurde bisher bei allen mir bekannten Skritpsprachenerweiterungen, welche genau genommen nur drei, ja eigentlich nur zwei sind, gewählt.

Die Lösung:
Zum Einen wäre da Vexorians vJass, welches sich mit großem Erfolg verbreitet hat und grob alle wichtigen Mängel von Jass behebt.
Zum Anderen wären da cJass und Zinc. Ich fasse diese beiden Sprachen zusammen, da sie mehr einen Zusatz zu vJass darstellen.
Sie erweitern lediglich die Syntax um einige Fähigkeiten und sind beidesamt kompatibel zu vJass.
Vexorian hat nicht nur die beiden Sprachen vJass und Zinc entwickelt, sondern auch den dazugehörigen Precompiler, den JassHelper,
welcher meines Wissens nach in Pascal bzw. Delphi geschrieben ist.
Für cJass existiert ebenfalls ein, in Assembler geschriebener, Precompiler.
Wo liegt nun also das Problem, wenn es bereits diese Spracherweiterungen gibt?
Die Antwort ist ganz einfach: Zinc und cJass haben jeweils ihre eigenen Arten einer Syntaxerweiterung über die man sich bereits teil-
weise streiten kann, da sie sehr von der Syntax herkömmlicher Sprachen abweicht.
vJass dagegen ist das eigentliche Ziel meiner Kritik, da diese Spracherweiterung erst die eigentlichen und wirklich notwendigen Fähigkeiten
mit sich bringt. Objektorientierung, Modularisierung, Funktionszeiger, Executions und Evaluations, und inzwischen auch namenlose bzw. Lambda-Funktionen.
Viele davon gefallen mir und ich bin daher inzwischen auch ein langjähriger Benutzer vJass'.
Womit ich jedoch eigentlich unzufrieden bin ist zum einen der Mangel an weiteren notwendigen und praktischen Erweiterungen, sowie des Programms
JassHelper, welches nicht einmal plattformübergreifend ist, die teilweise wirklich unschöne Syntax und die daraus resultierende Erweiterung Zinc bzw.
die Trennung der beiden Sprachen und zu schlechter Letzt die mangelnde Fehlerbehebung bei aufkommenden Fehlern.
Der Code des JassHelpers ist frei verfügbar, das ist mir wohl bewusst, jedoch bin ich 1. nicht so mit Pascal und dessen Syntax vertraut, halte 2.
den Code für mehr als unübersichtlich und bin 3. nicht gerade motiviert, eine Windows-Anwendung weiterzuentwickeln, welche eine Sprache interpretiert
und kompiliert, an deren Syntax ich einiges auszusetzen habe.
Zudem interessiere ich mich inzwischen sehr für Programmiersprachen, weshalb die Entwicklung einer eigenen Sprache, hoffentlich auch einen gewissen
Lerneffekt bei mir auslösen wird.

Jass++:
Ich bin ein Fan der Programmiersprache C++. Daher der Name Jass++. Ob er passend oder unpassend ist, ist mir relativ egal, es ist nur ein Bezeichner.
Jass++ soll alles abdecken, was mir persönlich und eventuell auch anderen in Jass fehlt.
Genau wie vJass, muss es in Jass-Code umgewandelt werden, weshalb ein Precompiler benötigt wird. Ein solcher wird momentan von mir selbst entwickelt.
Neben der Sprachsyntaxdefinition existiert auch eine Compiler-Definition, welche mehr eine Empfehlung an mich selbst und andere, die einen Precompiler
für die Sprache schreiben wollen, ist.
Jass++ soll einerseits speziell auf Warcraft 3 The Frozen Throne und die Merkmale von Jass zugeschnitten sein und andererseits die Mächtigkeit einer
umfangreichen, modernen Programmiersprache mit sich bringen.
Dabei werden zum Teil einzigartige und zum Teil altbekannte Syntaxelemente unterstützt.
Zudem, und dies halte ich persönlich für eine sehr wichtige Eigenschaft der Sprache, soll sie so gut wie möglich zu bestehenden Spracherweiterungen
von Jass kompatibel sein und zumindest deren getrennte Behandlung erlauben.

2. Laufzeit und Kompilierung

Im Gegensatz zu Jass ist Jass++ keine reine Interpreter-Sprache mehr, da sie zunächst zu Jass-Code
umgewandelt werden muss. Daher wird in den nachfolgenden Inhalten oft zwischen der Lauf- und der Kompilier-
zeit unterschied. Mit der Kompilierzeit ist jene Zeit gemeint, in welcher der Jass++-Code zu Jass-Code
umgewandelt wird. Mit der Laufzeit dagegen ist jene Zeit gemeint, in der der bereits zu Jass-Code kompilierte
Jass++-Code ausgeführt wird. Dies wird in der Regel von Warcraft 3 The Frozen Throne bzw. dess Engine
bewerkstelligt, könnte jedoch theoretisch auch von einer anderen, selbst gebauten getan werden.

3. Kompatibilität zu anderen Sprachen

Kompatibilität zu Jass:
Jass-Funktionen und -Variablen, die innerhalb der #jass und #endjass-Präprozessoranweisungen
deklariert wurden, können von Jass++-Code normal aufgerufen werden. Dabei gilt zu beachten,
dass die Typumwandlungsregeln von Jass++ bei der Parameterübergabe gelten.
Native Funktionen und Typen können ebenfalls durch eine reine Jass-Deklaration verwendet werden
und müssen nicht erst mit den Jass++-Sprachelementen deklariert werden. Diese eignen sich eher
zur Deklaration neuer Typen und nativer Funktionen, insofern es dem Entwickler möglich ist, dies
z. B. mit Hilfe des Werkzeugs Grimoire zu bewerkstelligen.
Aus Jass heraus kann ebenfalls mittels der #jasspp- und #endjasspp-Präprozessoranweisungen Jass++-Code
verwendet werden, allerdings sollten die zu Jass kompilierten Jass++-Funktionen und -Variablen
aus Jass-Code heraus nicht verwendbar sein.
Es gilt hierbei noch anzumerken, dass die Verwendung von Jass++-Code in globalen Jass-Funktionen
aufgrund der Paketsortierung zu größeren Problemen führen kann, da Jass-Funktionen vor sämtlichen
Paket-Funktionen deklariert werden.

Kompatibilität zu vJass:
Momentan ist noch nicht geplant Jass++- und vJass-Code kombinierbar zu machen.
Code zwischen den Präprozessoranweisungen #vjass und #endjass wird daher bei einer Jass++-
Kompilierung ignoriert.

Kompatibilität zu Zinc:
Momentan ist noch nicht geplant Jass++- und Zinc-Code kombinierbar zu machen.
Code zwischen den Präprozessoranweisungen #zinc und #endzinc wird daher bei einer Jass++-
Kompilierung ignoriert.

Kompatibilität zu CJass:
Momentan ist noch nicht geplant Jass++- und CJass-Code kombinierbar zu machen.
Code zwischen den Präprozessoranweisungen #cjass und #endcjass wird daher bei einer Jass++-
Kompilierung ignoriert.

4. Schlüsselwörter

Im Folgenden wird zwischen Standard, was auf gängige Programmiersprachen verweist, und Warcraft-spezifisch, was auf Warcraft-spezifische
Eigenschaften verweist, unterschieden.

Prozedual-Schlüsselwörter:
Standard: if, else, switch, case, break, continue, default, while, do, for, foreach, try, catch, finally, throw, enum, size, const, alias
Warcract-spezifisch: native, mapinit, debug

Operator-Schlüsselwörter:
Warcraft-spezifisch: id, hash, length

Funktional-Schlüsselwörter:
Standard: operator, return

Generik-Schlüsselwörter:
Standard: template

Modularisierung-Schlüsselwörter:
Standard: package, private, protected, public

Objektorientierung-Schlüsselwörter:
Standard: class, this, self, parent, new, delete, copy, init, virtual, static, friend, abstract, mutable

Threading-Schlüsselwöter:
Warcract-spezifisch:threaded, execute, executewait, evaluate, executions, evaluations, sleeps, sleepon, sleepoff, reset, sleep

Save- und Load-Schlüsselwörter:
Warcract-spezifisch: store, restore, flush, save, load, remove

Möglicher Zusatz:
executefast ermöglicht den Aufruf mit ExecuteFunc und Parameterspeicherung, jedoch könnte
der Aufruf nicht mittels calls abgerufen werden und es gäbe eventuell weitere Nachteile
(Geschwindigkeit).

Zusammenfassung der Qualifizierer:
Standard: enum, const, template, package, private, protected, public, class, init, virtual, static, friend, abstract, mutable
Warcraft-spezifisch: native, mapinit, debug, threaded

Zusammenfassung der Anweisungsblockschlüsselwörter:
Standard: if, else, switch, case, default, while, do, for, foreach, try, catch, finally

Zusammenfassung der Anweisungsschlüsselwörter:
Standard: break, continue, throw, size, return, new, delete, copy
Warcraft-spezifisch: id, hash, length, execute, executewait, evaluate, executions, evaluations, sleeps, sleepon, sleepoff, reset, sleep, store, restore, flush, save, load, remove

Bezeichnerspezifizierungsschlüsselwörter:
Standard: enum, package, class

5. Kommentare

Zeilenkommentare:
Zeilenkommentare beginnen mit zwei "/"-Zeichen und enden am Ende der Zeile.

Notation:
//<Zeilenkommentarinhalt>

Blockkommentare:
Blockkommentare zwischen einer "/*"- und einer "*/"-Zeichenfolge sind in Jass++ (auch über mehrere Zeilen hinweg) möglich.

Notation:
/*<Blockkommentarinhalt>*/

6. Präprozessoren

#include [ jass | zinc | vjass | jasspp ] "Dateipfad"
#inject InitGlobals | InitSounds | CreateNeutralHostile | CreateNeutralPassiveBuildings | CreatePlayerBuildings | CreatePlayerUnits | CreateAllUnits | InitCustomTriggers | RunInitializationTriggers | InitCustomPlayerSlots | InitCustomTeams | InitAllyPriorities | main | config // injectet die entsprechende Funktion und ersetzt ihren Inhalt durch den Inhalt des Inject-Blocks. Existiert die Funktion nicht (z. B. da es keine eigenen Teams gibt, so zeigt der Compiler eine Fehlermeldung an)
#endinject
#initjasspp			Initialisiert die globale Hashtable und erzeugt sämtliche Prototypauslöser. Nützlich für eine Injection der main-Funktion
#if (<konstanter Ausdruck>)	Zum Beispiel (WC3_VERSION == "1.21" && constantValue > 10)
#else if (<konstanter Ausdruck>)
#else
#endif
#error <konstanter Ausdruck>	Bricht den Kompiliervorgang ab und gibt den konstanten Ausdruck als Fehlermeldung aus.
#jass
#endjass
#zinc
#endzinc
#vjass
#endvjass
#jasspp
#endjasspp
#external <Ausdruck> <Parameter>

Vordefinierte Konstanten:
OS Enthält eine Zeichenkette mit dem Namen des Betriebssystems.
COMPILER Enthält eine Zeichenkette mit dem Namen des verwendeten Compilers.
COMPILER_VERSION Enthält eine Zeichenkette mit der Version des verwendeten Compilers.
WC3_VERSION Enthält eine Zeichenkette mit der Warcraft-3-Version (ist zur Laufzeit aktuell!).
WC3_TFT_VERSION Enthält eine Zeichenkette mit der Warcraft-3-The-Frozen-Throne-Version. Falls The Frozen Throne nicht verwendet wird, ist der Wert gleich 0 gesetzt (ist zur Laufzeit aktuell!).
DEBUG_MODE Enthält entweder true oder false, je nachdem, ob der Debug-Modus aktiviert oder deaktiviert ist.
FILE_NAME Enthält eine Zeichenkette des Dateinamens der aktuellen Datei.
LINE_NUMBER Enthält eine Zeichenkette der Zeilennummer der aktuellen Zeile.
OPTIMIZATION_INLINE_FUNCTIONS Enthält entweder true oder false, je nachdem, ob die Optimierungsoption im Compiler aktiviert ist oder nicht.
OPTIMIZATION_REMOVE_WHITE_SPACES Enthält entweder true oder false, je nachdem, ob die Optimierungsoption im Compiler aktiviert ist oder nicht.
OPTIMIZATION_REMOVE_CONSTANTS Enthält entweder true oder false, je nachdem, ob die Optimierungsoption im Compiler aktiviert ist oder nicht.
TODO: Hier noch weitere Optimierungsoptionen hinzufügen.

Dateipfade für die Include-Anweisung:
Dateipfade müssen wie bei UNIX Systemen geschrieben werden. . steht für das aktuelle und ..
für das darüber liegende Verzeichnis. Verzeichnisse werden durch das /-Zeichen getrennt.
~ verweist auf das Heimatverzeichnis des Benutzers, / auf das Wurzelverzeichnis.
  
7. Testblöcke

Der von Testblöcken enthaltene Code wird nur kompiliert, insofern der eingebaute Debug-Modus aktiviert ist.
Analog zu #if (DEBUG_MODE) und #endif.
Testblöcke sind nach der unten aufgezeigten Form ein Qualifizierer-Gültigkeitsbereich.

Notation:
debug
{
}

8. Deklaration nativer Typen

Es gibt kopierbasierte und referenzbasierte native Typen. Der Typ "agent" wird von sämtlichen referenzbasierten nativen Typen erweitert.
Referenzbasierte Werte werden beim Übergeben an eine andere Variable (auch an Paramter) nicht kopiert, sondern lediglich ihre Referenz,
was bewirkt, dass die andere Variable mit demselben globalen Objekt arbeitet, wie die eine.

Notation:
native <Typname> : <Elterntyp>;

9. Deklaration nativer Funktionen

Native Funktionen werden wie native Typen lediglich deklariert und nicht definiert. Die Definition erfolgt in der verwendeten Engine und kann
undefiniert bleiben, solange der Compiler weiß, wie die Funktion aufzurufen ist.
Native Funktionen aus Jass sollten mittels der Jass++-Syntax erneut bzw. ein einziges Mal deklariert werden, da man sie bei solchen Deklarationen
um konstante Parameter usw. erweitern kann.

Notation:
native [const] <Rückgabetyp> <Funktionsname>(<Parametertyp> <Parametername>, ...);

10. Bezeichner (identifiers)

Ein Bezeichner ist ein vom Entwickler definierter Name, welcher ein bestimmtes Code-Element bezeichnet und darauf verweist.
Für Bezeichner gelten bestimmte Regeln bezüglich ihrer Definition. Bezeichner dürfen in Jass++ anders als in Jass nicht mit
dem Präfix "jasspp" beginnen, da dieses für den Compiler reserviert ist (theoretisch könnte dieser auch sämtliche Bezeichner ersetzen,
um so dagegen vorzugehen, jedoch wird es vorläufig trotzdem reserviert). Ansonsten gelten dieselben Regeln wie in Jass (z. B. keine Unterstriche am Anfang).
Außerdem kann dem Bezeichner in bestimmten Fällen ein Schlüsselwortpräfix vorangestellt werden, welches die Art des Objekts genauer spezifiziert (siehe dazu Abschnitt "Schlüsselwörter").

11. Literale

Ein Literal ist ein sich selbst erklärender Ausdruck. Für folgende native Typen gelten folgende Literalnotationsregeln:

Kopierbasierte Typen:
* string : "<Literal>" | null
* integer : 0<Oktalliteral> | 0%<Binärliteral> | 0x<Hexadezimalliteral> | <Dezimalliteral> | '<Id-Literal>' | null
* real : <Fließkommaliteral> | null
* boolean : true | false | null
* handle (und Nicht-agent-Kindtypen): null

Referenzbasierte Typen:
* code : 0
* agent (und Kindtypen) : 0
* Klassenobjekte : 0
* Funktionszeiger : 0

12. Gültigkeitsbereiche (scopes)

Gültigkeitsbereiche definieren, innerhalb welches Bereiches eine Deklaration ihre Gültigkeit hat. Außerhalb dieses Bereiches
kann die Deklaration nur über den Bezeichner, insofern ein solcher existiert, des Gültigkeitsbereiches bzw. den .-Operator erreicht werden.
In bestimmten Fällen geschieht dies implizit (Methodenaufruf, Pseudonyme, Paketverwendung usw.).
Ein Gültigkeitsbereich besitzt in Jass++ nicht zwingend einen Bezeichner und ist zwischen einer geöffneten und einer geschlossenen eckigen
Klammer definiert.
Je tiefer der Gültigkeitsbereich, desto höher ist die Priorität des Bezeichners. Die Bezeichner können sich gegenseitig überdecken.
Dies ist explizit gewollt. Über die Bezeichner der äußeren Gültigkeitsbereiche bzw. den .-Operator kann auf Bezeichner höherer
Gültigkeitsbereiche zugegriffen werden. Dies ermöglicht eine Verschachtelung beliebig vieler Gültigkeitsbreiche.
Zu beachten gilt, dass lokale Variablen nur im Funktionskopf deklariert werden können, wodurch eine erneute Deklaration und Überlagerung
der äußeren lokalen Variablen, durch innere in neuen Gültigkeitsbereichen nicht möglich ist.
Es existieren folgende sprachenspezifische Arten von Gültigkeitsbereichen:
* Funktionsdeklarationen
* Aufzählungsdeklarationen
* Klassendeklarationen
* Paketdeklarationen

Notation:
[<Bezeichner>] [<optionale Eigenschaften des jeweiligen Sprachelements>]
{
}

Bespiel:
void test()
{
	int x = 0;

	{
		.x = .x; // Expliziter Verweis auf den äußeren Gültigkeitsbereich mit dem .-Operator
		.x = 10; // x im Gültigkeitsbereich über dem aktuellen erhält den Wert 10
		x = 12; // x im Gültigkeitsbereich über dem aktuellen erhält den Wert 12, da im aktuellen Gültigkeitsbereich keine Variable namens x deklariert wurde
	}
}

Gültigkeitsbereichverwendung

Gültigkeitsbereiche können innerhalb eines anderen Gültigkeitsbereiches oder global "verwendet" werden.
Dies bedeutet, dass Elementen des Gültigkeitsbereiches kein Präfix des Gültigkeitsbereiches mehr voran-
gestellt werden muss.
Dabei ist auch die Verwendung von verschachtelten Gültigkeitsbereichen möglich.
Die Verwendung wirkt sich sowohl auf den aktuellen als auch auf alle Untergültigkeitsbereiche dessen aus.
Sie kann durch den --Operator in einem der Subgültigkeitsbereiche aufgehoben werden, wobei sämtliche Ebenen unterhalb der angegebenen
aufgehoben werden.
Der *-Operator dagegen bewirkt, dass sämtliche Untergültigkeitsbereiche implizit ebenfalls verwendet werden.
Eine Kombination der beiden Operatoren ist theoretisch möglich, da der --Operator implizit den *-Operator verwendet, aber nicht notwendig.
Der Compiler sollte in diesem Fall eine Warnung ausgeben.
Zudem ist es unter keinen Umständen möglich bei der Gültigkeitsbereichverwendung den aktuellen Gültigkeitsbereich oder einen Subgültigkeitsbereich
dessen mit dem *-Operator oder dem --Operator anzugeben.
In diesem Fall muss der Compiler eine Fehlermeldung ausgeben.
Eine besondere Ausnahme bei der Gültigkeitsbereichverwendung bilden Funktionen.
Sie können nur innerhalb ihres eigenen Gültigkeitsbereichs verwendet werden.

Notation:
<Gültigkeitsbereichbezeichner>[* | -];

Beispiele:
package gna.gnu.gni*;
class gna.gnu.gni.Test;
enum gna.gnu.gni.Test.Type;

Test var = new Test();
package gna.gnu.gni-;
Test var2 = new Test(); // Fehler, undefinierter Bezeichner!


Qualifizierer-Gültigkeitsbereiche

Unter Qualifizierer-Gültigkeitsbereichen versteht man in Jass++ Gültigkeitsbereiche ohne Namen,
welche nicht als eine weitere Überdeckungsschicht gelten, jedoch sämtliche enthaltenen Code-Elemente (der ersten Ebene)
als etwas Bestimmtes qualifzieren.
Dabei muss die Qualifizierung eines eingeschlossenen definierten Objekts von der Syntax gestattet sein.
Mit folgenden Schlüsselwörtern können solche Qualifizierer-Gültigkeitsbereiche definiert werden:
Siehe dazu "Zusammenfassung der Qualifizierer" im Abschnitt "Schlüsselwörter".

Die Schlüsselwörter können auch in Kombination verwendet werden, falls dies die Syntax der Sprache
erlaubt.
Außerdem können sämtliche (auch selbst definierte) Typen als Qualifizierer verwendet werden.
Des Weiteren gilt es zu beachten, dass manche Qualifizierer eventuell auch eine andere Art der Zusammenfassung erlauben
(z. B. Trennung durch Kommata).
In einem solchen Fall steht es dem Entwickler frei, sich zwischen den beiden Varianten zu entscheiden.
Rückgabetypen, Parameter, angeforderte Pakete, geerbte Klassen oder Array-Größen können nicht auf eine
solche Weise für einge Gruppe von Code-Elementen definiert werden!

Notation:
<Qualifizierer1> <Qualifizierer2> ... <Qualifizierern>
{
	<Code-Element-Definition>
}

Beispiele:
static const integer
{
	ich = 10;
	du = 10;
	er = 12;
}

debug
{
	void bla() {};
	void bla2() {};
	void bla3() {};
}

14. Anweisungsblöcke

Im Gegensatz zu Gültigkeitsbereichen, sind Anweisungsblöcke keine Bezeichnerebenen. Sie schließen lediglich Anweisungen ein, welche nur in bestimmten
Fällen ausgeführt werden.
Für die unterschiedlichen Fallbehandlungen existieren jeweilige Schlüsselwörter.
Anweisungsblöcke können nicht selbst ohne oder mit eigenem Bezeichner definiert werden.
Es existieren folgende Arten von Anweisungsblöcken:
* Verzweigungen
* Schleifen
* Ausnahmebehandlungen
* finally

Variablen

Variablen existieren, falls nicht anders angegeben, vom Programmstart bis zum Programmende. Lokale Variablen in Funktionen, sowie Elementvariablen
von Klassen leben vom Funktionsaufruf bis zum Ende des Funktionsablaufes bzw. von der Erzeugung der Klasseninstanz bis zur Löschung dieser.
Variablen, die als "static" deklariert wurden, existieren ebenfalls vom Programmstart bis zum Programmende.
Anders als in C++ können in Jass++ keine Variablen in beliebig verschachtelten Gültigkeitsbereichen deklariert werden, die am Ende dieser
automatisch gelöscht werden.
Sie können ausschließlich global oder in Paket-, Klassen- und Funktionsdefinitionen deklariert werden und
ausschließlich in Klassen- und Funktionsdefinitionen als "static". Es gilt zu beachten, dass diese statischen Variablen wie andere globale
bei ihrer Deklaration bzw. dem Programmstart ein einziges Mal initialisiert werden und nicht wie bei lokalen z. B. bei jedem Funktionsaufruf.
Außerdem können nur statische Variablen mit dem Schlüsselwort "const"
als konstant deklariert werden (dies bezieht sich aber nicht auf ihren Rückgabetyp).

Notation:
[static] [const] <Variablentyp> <Variablenname>[[<Variablengröße der 1. Dimension>][<Variablengröße der n. Dimension>]] [= <Initialisierungswert>];
 
Konstante Variablen müssen bei ihrer Deklaration initialisiert werden. Ihr Inhalt ist bis zu ihrer Löschung unveränderbar.
Array-Größenangaben müssen konstante Ganzzahlwerte sein.
Der Variableninhalt wird bei Arrays wie in C oder C++ mittels geschweifter Klammern eingeschlossen:
integer tes[2] = { 10, 2 };

Es können mehrdimensionale Arrays deklariert werden:
integer test[2][2] = { { 10, 5 }, { 2, 4 } };

Da ein Array in Warcraft 3 nur 8192 bzw. 8191 (wird im letzten Feld die Größe gespeichert?) haben kann, kümmert sich der Compiler
mit speziellen Verfahren bei höheren Größenangaben um den benötigten Speicherplatz.
Eventuell sollte er einen Hinweis anzeigen, falls die Grenze überschritten wird. Da die Array-Größe ein konstanter Ganzzahlwert sein muss,
ist sie stets zur Kompilierzeit bekannt und kann mit dem size-Operator abgefragt werden.

Variablen können global, in Paketen, Klassen, Funktionen oder Methoden deklariert werden.
Klassen, Funktionen und Methoden können statische Variablen enthalten:
static integer test;
static const integer test = 10;

Bei kopierbasierten Typen wird das Literal "null" für eine Leerung des Variableninhalts benutzt. Bei referenzbasierten Typen
dagegen 0 (siehe Abschnitt Literale).

Operatoren

Für Gültigkeitsbereiche:
[<Bezeichner des Gültigkeitsbereiches>].<Bezeichner eines im Gültigkeitsbereich deklarierten Elements>

Für die Typen integer und real:
Variable = Ausdruck
+Variable
-Variable
Variable + Ausdruck
Variable - Ausdruck
Variable * Ausdruck
Variable / Ausdruck
Variable % Ausdruck
Variable++
Variable--
Variable += Ausdruck
Variable -= Ausdruck
Variable *= Ausdruck
Variable /= Ausdruck
Variable %= Ausdruck
Variable == Ausdruck
Variable != Ausdruck
Variable >= Ausdruck
Variable <= Ausdruck
Variable > Ausdruck
Variable < Ausdruck

Für den Typ integer:
real(Variable)						Entspricht I2R(Variable)
string(Variable)					Entspricht I2S(Variable)

Für den Typ real:
integer(Variable)					Entspricht R2I(Variable)
string(Variable)					Entspricht R2S(Variable)
string(Variable, <Ganzzahlausdruck>, <Ganzzahlausdruck>)Entspricht R2SW(Variable, <Ganzzahlausdruck>, <Ganzzahlausdruck>)

Für den Typ boolean:
Variable = Ausdruck
Variable
!Variable
Variable == Ausdruck
Variable != Ausdruck

Für den Typ string:
Variable = Ausdruck
Variable + Ausdruck
Variable - Ausdruck				Entfernt eine Teilzeichenkette
Variable += Ausdruck
Variable -= Ausdruck				Entfernt eine Teilzeichenkette
Variable == Ausdruck
Variable != Ausdruck
Variable >= Ausdruck				Die Vergleichsoperatoren beziehen sich in diesem Fall auf die Wertigkeit des Unicode-Zeichens (Warcraft 3 TFT verwendet kein ASCII)
Variable <= Ausdruck
Variable > Ausdruck
Variable < Ausdruck
hash Variable					Entspricht Variable.hash und StringHash(Variable)
Variable[Index]					Entspricht SubString(Variable, index, index + 1)
length Variable					Entspricht Variable.length und StringLength(Variable)
integer(Variable)				Entspricht S2I(Variable)
real(Variable)					Entspricht S2R(Variable)

Für den Typ code:
Variable = Ausdruck

Für den Typ handle:
Variable = Ausdruck
Variable == Ausdruck
Variable != Ausdruck
integer(Variable)				Entspricht GetHandleId(Variable)
id Variable					Entspricht Variable.id und GetHandleId(Variable)
Variable.id

Für Paketdeklarationen:
<Paketbezeichner> : <Deklarationsvoraussetzungen>

Für Funktionsdeklarationen:
<Rückgabetyp> <Funktionsname><Parameterliste> : <Deklarationsvoraussetzungen>

Für Aufzählungsdeklarationen:
<Aufzählungsbezeichner> : <Deklarationsvoraussetzungen>

Für Klassendeklarationen:
<Klassenbezeichner> (<Erbung>) : <Deklarationsvoraussetzungen>

Für Arrays:
size Variable
Variable.size

Für Aufzählungen:
Variable = Ausdruck
Variable == Ausdruck
Variable != Ausdruck
size Aufzählungsbezeichner
Aufzählungsbezeichner.size

Für Funktionszeiger:
execute Variable(<Parameter)
Variable.execute(<Parameter>)
executewait Variable(<Parameter)
Variable.executewait(<Parameter>)
evaluate Variable(<Parameter)
Variable.evaluate(<Parameter>)
executions Variable
Variable.executions
evaluations Variable
Variable.evaluations
sleeps Variable
Variable.sleeps
sleepon Variable
Variable.sleepon
sleepoff Variable
Variable.sleepoff
reset Variable
Variable.reset
integer(Variable)				Liefert die interne Ganzzahl des Funktionsprototypen.
id Variable					Entspricht Variable.id. Liefert die interne Ganzzahl des Funktionsprototypen.
Variable.id

Innerhalb von "threaded" Funktionen:
sleep <real-Ausdruck>
id						Liefert die interne Ganzzahl des Funktionsprototypen.

Für Klassen(instanzen):
<Klassenname>.<Enum | statische Methode | statisches Element>
<Variable>.<Elementname | Methodenname>
new <Klassenname>				Entspricht Klassenname.new()
delete <Variable>				Entspricht Variable.delete()
copy Variable					Entspricht Variable.copy()
Variable = Ausdruck
Variable					Ist wahr, falls die Variable auf ein Objekt zeigt.
!Variable					Ist wahr, falls die Variable auf kein Objekt zeigt.
Variable == Ausdruck				Ist wahr, falls die beide Variablen auf dasselbe Objekt zeigen.
Variable != Ausdruck				Ist wahr, falls die beide Variablen nicht auf dasselbe Objekt zeigen.
integer(Variable)				Liefert die interne Ganzzahl der Klasseninstanz.
id Variable					Entspricht Variable.id. Liefert die interne Ganzzahl der Klasseninstanz.

Für Arrays:
Variable[Indexdimension 1][Indexdimension 2]...[Indexdimension n]

Für große Arrays:
integer(Variable)				Liefert die interne Ganzzahl der Array-Instanz.
id Variable					Entspricht Variable.id. Liefert die interne Ganzzahl der Array-Instanz.

Typen

In Jass++ können sämtliche Typen aus Jass ohne besondere Einschränkungen (bis auf const-Deklarationen) verwendet werden.
Eigene Typen können ausschließlich mittels Klassen definiert werden. Alle anderen Typen sind native Typen.
Ein Variablentyp kann als Postfix das Schlüsselwort "const" erhalten, insofern er referenzbasiert ist.
In Jass++ wird wie in Jass zwischen referenz- und kopierbasierten Typen unterschieden. Ist der Typ einer Variable
referenzbasiert und konstant, so darf das Objekt, auf welches referenziert wird nicht verändert werden, die Variable selbst jedoch schon.
Der Inhalt kopierbasierter Variablen wird wie der referenzbasierter beim Übergeben an eine andere (z. B. an Funktionsparameter) kopiert,
jedoch wird bei referenzbasierten lediglich eine Referenz auf ein global existierendes Objekt kopiert, welches, falls möglich,
explizit vom Entwickler wieder freigegeben werden muss.
Da auch Funktionszeiger referenzbasierter Typen sind, können sie ebenfalls als "const" deklariert werden, was zur Folge hat,
dass die Funktionen, auf welche sie zeigen nicht mit den Schlüsselwörtern execute, executewait, evaluate, sleepon, sleepoff und reset aufgerufen
bzw. diese auf sie angewandt werden dürfen.

Notation:
<Typbezeichner> [const]

Typkonvertierungen:
Sämtliche Typkonvertierungen müssen explizit vorgenommen werden, insofern es sich nicht
um eine Kind-zu-Eltern-Konvertierung handelt. Sämtliche Funktions- und
Klasseninstanzenreferenzen können zum Typ integer konvertiert werden (ebenfalls explizit).
Kindinstanzen können zu Elterninstanzen implizit konvertiert werden. Dies gilt auch für
native Kindtypen wie z. B. unit zu widget.
Andersherum muss explizit umgewandelt werden und gilt nur noch für Klasseninstanzen, nicht für
native Typen.
Zu beachten gilt, dass es bei Eltern-zu-Kind-Konvertierungen zu fehlenden Daten für z. B.
virtuelle Methoden kommen kann. Schlimmer noch wäre ein Zugriff auf ein Instanzelement
einer ursprünglichen Nichtklasseninstanz, da so auf ein falsches Element einer anderen
Instanz zugegriffen werden würde. Dies kann selbst zur Laufzeit nicht im Debug-Modus heraus-
gefunden werden.
Daher sollte der Compiler bei solchen Konvertierungen eine Warnung ausgeben.
Außerdem können Variablen mit nicht-konstantem Inhalt implizit zu solchen konvertiert werden.
Andersherum ist eine Konvertierung gar nicht möglich.

Notation:
<Konvertierungstyp>(Ausdruck)

Beispiele:
MyClass myClassValue = new MyClass;
integer myValue = integer(myClassValue);
MyParentClass myParentClassValue = myClassValue;
myClassValue = myParentClassValue; // illegal!
myClassValue = MyClass(myParentClassValue);
unit myUnit = null;
widget myWidget = myUnit;
myUnit = myWidget; // illegal!
myUnit = widget(myWidget); // illegal!
Unit const myUnit = myOtherNonConstantUnit;
Unit myUnit= myOtherConstantUnit; // illegal!

Verzweigungen

if (Ausdruck)
{
}
else if (Ausdruck)
{
}
else (Ausdruck)
{
}

Switch-Verzweigungen können anders als in herkömmlichen Sprachen jede Art von Datentyp behandeln.

switch (<Variable>)
{
	case (<konstanter Ausdruck>)
	{
		break;
	}

	case (<konstanter Ausdruck>) // Ein Ausdruck kann auch aus mehreren durch Kommate getrennten Werten bestehen: 1,10,2
	{
		break;
	}

	default
	{
		break;
	}
}

Schleifen

while (<Ausdruck>)
{
}
case (<konstanter Ganzzahlausdruck>) // Schleife wurde <konstanter Ganzzahlausdruck> mal durchlaufen.
{
}
default // Schleife wurde nicht durch eine break-Anweisung abgebrochen
{
}

do
{
}
while (<Ausdruck>);
case (<konstanter Ganzzahlausdruck>) // Schleife wurde <konstanter Ganzzahlausdruck> mal durchlaufen.
{
}
default // Schleife wurde nicht durch eine break-Anweisung abgebrochen
{
}

for (<Ausdruck>; <Ausdruck>; <Ausdruck>)
{
}
case (<konstanter Ganzzahlausdruck>) // Schleife wurde <Anzahl> mal durchlaufen.
{
}
default // Schleife wurde nicht durch eine break-Anweisung abgebrochen
{
}

foreach (<Variablenname>; <Variablenname einer Array-Variable>)
{
}
case (<konstanter Ganzzahlausdruck>) // Schleife wurde <konstanter Ganzzahlausdruck> mal durchlaufen.
{
}
default // Schleife wurde nicht durch eine break-Anweisung abgebrochen
{
}

20. Deklarationsvoraussetzungen

Funktionen, Pakete, Aufzählungen und Klassen können bei ihrer Deklaration eben solche voraussetzen.
Dazu wird der :-Operator verwendet. Dies stellt sicher, dass die Voraussetzungen vor dem jeweiligen
Code-Objekt deklariert werden. Sollte es dabei zu Kreisabhängigkeiten kommen, indem sich z. B. zwei
Code-Objekte gegenseitig voraussetzen, so muss der Compiler eine Fehlermeldung ausgeben.
Ansonsten muss er sicherstellen, dass die Objekte in der richtigen Reihenfolge deklariert werden.
Deklarationsvoraussetzungen sind notwendig, da Funktionen in Jass erst nach ihrer Deklaration im Skript
verwendet werden können.
Eine Umgehung dieser Beschränkung kann mit den Schlüsselwörtern execute und evaluate erreicht werden
(siehe dazu Abschnitt "Funktionen").
Geerbte Klassen werden implizit als Deklarationsvoraussetzung angegeben.
Aufzählungen brauchen in der Regel höchstens Voraussetzungen, wenn das Paket oder die Klasse Ganzzahl-Konstanten enthält.

Notation:
<Funktionsdeklaration|Paketdeklaration|Aufzählungsdeklaration|Klassendeklaration> : <Bezeichner1>, <Bezeichner2>, ... <Bezeichnern>

21. Funktionen

Mehrere Funktionsdefinitionen können den gleichen Namen haben, insofern sich mindestens die Parametertypen oder die Parameteranzahl unterscheiden.
Unterscheidet sich lediglich der Rückgabetyp, so gelten beide Definition nicht als unterschiedlich, da im Falle eines Aufrufes ohne eine Speicherung
des Rückgabetyps nicht sichergestellt werden könnte, welche Version der Funktion aufgerufen werden sollte.
Parametertypen unterscheiden sich auch, sobald nur einer der beiden als "const" deklariert wurde. In diesem Fall wird je nach konstanter oder nicht
konstanter Parameterübergabe die jeweilge Version der Funktionsdeklaration ausgewählt.
Wird eine Funktion aufgerufen, so können Werte für einzelne Parameter, in beliebiger Reihenfolge übergeben werden, insofern sämtliche
Parameter, welche kein Standardargument besitzen gesetzt werden:
MyFunction(y = 10, x = 100, 100, 3, 5);
Parameter mit Standardargumenten erhalten automatisch das Standardargument, insofern sie nicht explizit beim Aufruf gesetzt werden.

Notation:
[threaded] [mapinit] [const] [Rückgabetyp] Funktionsname([Parametertyp Parametername [= Standardargument]] ...) [<Deklarationsvoraussetzungen>] [throw (Typen getrennt durch Kommata)]
{
	<Anweisungen>
}

Ist eine Funktion "threaded", kann sie von überall aus mit .execute, .executewait, oder .evaluate aufgerufen werden.
Rückgabewerte können nur bei .evaluate zurückgegeben werden.
.evaluate erzeugt keinen neuen Thread, es wird daher gewartet, bis der Funktionsaufruf abgearbeitet wurde. Funktionen, die mit
.evaluate aufgerufen werden, dürfen keine sleep-Anweisungen bzw. TriggerSleepAction-Aufrufe enthalten.
Der Compiler sollte in diesem Fall eine Fehlermeldung ausgeben.
Bei .execute und .executewait dagegen, läuft der Code unmittelbar nach dem Aufruf weiter. Der Funktionsaufruf findet in einem eigenen
Thread statt.
.execute und .executewait bewirken eigentlich das Gleiche, insofern TriggerExecute und TriggerExecuteWait das Gleiche bewirken.
Der Rückgabewert von Funktionen, die mit .execute bzw. .executewait aufgerufen wurden, dürfen nicht verwendet werden (zeitliche Differenz!).

Mittels der Schlüsselwörter "executions" und "evaluations" kann herausgefunden werden, wie oft eine "threaded" Funktion per .execute und .executewait 
bzw. .evaluate aufgerufen wurde.
Zurückgegeben wird die Anzahl als integer.

Notation:
<Funktionsname>.executions
<Funktionsname>.evaluations
executions <Funktionsname>
evaluations <Funktionsname>
 
Mittels des Schlüsselwortes "sleep", kann in einer "threaded"-Funktion gewartet werden.

Notation:
sleep(<real-Ausdruck>)

Mittels der Schlüsselwörter "sleeps", "sleepon" und "sleepoff" kann eine "threaded" Funktion darauf überprüft werden, ob ihr Thread gerade wartet bzw.
das Warten aktiviert oder deaktiviert werden.
Die Aktivierung und Deaktivierung des Wartens bezieht sich NUR auf alle laufenden .execute- und .executewait-Aufrufe der Funktion.
Sämtliche Aufrufe nach der Aktivierung bzw. Deaktivierung sind davon ausgeschlossen.
Dies liegt am Verhalten der nativen Jass-Funktion TriggerWaitOnSleeps.
Test-Anmerkung:
IsTriggerWaitOnSleeps gibt nur true zurück, falls explizit TriggerWaitOnSleeps(<Auslöser>, true) aufgerufen wurde. Am Verhalten des Auslösers
scheint sich aber nichts zu ändern.

Notation:
sleeps <Funktionsname>// Liefert einen Boolean-Wert.
sleepon <Funktionsname> // Funktion wartet bei "sleep"-Anweisungen.
sleepoff <Funktionsname> // Funktion wartet nicht bei "sleep"-Anweisungen.

Mittels des Schlüsselwortes "reset" kann eine "threaded" Funktion zurückgesetzt werden. Dies bewirkt, dass sie bei der nächsten sleep-Anweisung 
abbricht. Dies gilt für sämtliche execute- und executewait-Aufrufe der Funktion.

Notation:
reset <Funktionsname> // Setzt den Thread der Funktion zurück.

Ist eine Funktion als "mapinit" deklariert, so wird diese während der Karteninitialisierung exakt vor der Funktion RunInitializationTriggers 
aufgerufen. Eine "mapinit"-Funktion darf keine Parameter entgegennehmen. Außerdem sollte der Compiler warnen, falls sie einen Rückgabetyp besitzt, 
manuell aufgerufen wird oder "threaded" ist (einstellbar, "threaded" ist ebenfalls eher unnötig).
Exisitieren mehrere Funktionen, die als "mapinit" deklariert wurden, so lässt sich die exakte Aufrufreihenfolge nur durch Deklarationsvoraussetzungen
bestimmen.

Ist eine Funktion als "const" deklariert, so muss sie einen global konstanten Wert zurückgeben. Beim Kompilieren, wird
sie normalerweise als "constant" Jass-Funktion erzeugt. Global konstant bedeutet in diesem Zusammenhang, dass der Wert
zur Laufzeit immer je nach übergebenen Parametern derselbe ist.

Funktionsvariablen (Funktionszeiger)

Funktionsvariablen sind Variablen des Typs "<Rückgabetyp> (<Parameter>)". Sie können einen Verweis auf eine beliebige
"threaded"-Funktion mit dem angegebenen Rückgabetyp und den angegebenen Parametern oder eine "threaded" Lambda-Funktion enthalten.
Der Verweis ist normalerweise ein Integer-Wert, welcher je nach Kompilierung des Codes unterschiedlich auf die Funktion verweisen kann.
Eine Funktionsvariable kann ebenso auf Methoden einer Klasse verweisen, welche ebenfalls als "threaded" deklariert sein müssen.
Funktionsvariablen können wie normale "threaded" Funktionen aufgerufen werden.
Des Weiteren gilt es zu beachten, dass Funktionsvariablen ebenfalls als "const" deklariert werden können (siehe Abschnitt Typen).

Notation:
<Rückgabetyp> (Parametertyp1, Parametertyp2, ... ParametertypN) <Variablenname> [= Funktionsname | "threaded" Lambda-Funktionsdefinition];

Beispiel:
integer (integer, integer) functionVariable = MyClass.method0;
Print(functionVariable.evaluate(0, 10));

Funktionstypen

Funktionstypen sind Typen, die eine einfachere Deklaration von Funktionszeigern ermöglichen.
Variablen, die einen Funktionstyp als Typ haben, können wie reguläre Funktionsvariablen verwendet werden (siehe Funktionsvariablen).

Notation:
abstract <Funktionstypname> <Rückgabetyp> (Parametertyp1, Parametertyp2, ... ParametertypN);

Beispiel:
abstract Predicate boolean ();

Lambda-Funktionen

Lambda-Funktionen sind namenlose Funktionen, sozusagen Funktionen, bei denen nur der Code-Inhalt angegeben werden muss.
In Jass++ ist es möglich Lambda-Funktionen zu deklarieren, welche keinen Rückgabewert haben und keine Parameter entgegennehmen.
Lambda-Funktionen können entweder in Variablen des Typs code oder in Funktionsvariablen gespeichert werden. Bei letzterer Variablenart
müssen sie jedoch als "threaded" deklariert werden, bei ersterer ist dies optional.
Außerdem kann ihr Inhalt an andere Funktionen wie bei gewöhnlichen Funktionsvariablen bzw. Variablen des Typs "code" weitergegeben
werden.
Lambda-Funktionen könne auch direkt an Paramater der beiden Typen übergeben werden.

Notation:
code <Variablenname> = [threaded] { <Funktions-Code> };
void () <Variablenname> = threaded { <Funktions-Code> };

code-Beispiel:
void test()
{
	code testCode = { integer i; for (i = 0; i < 100; i++) { Print("Iteration " + I2S(i)); } };
}

Funktionsvariablen-Beispiel:
void test()
{
	void () testFunctionVariable = { integer i; for (i = 0; i < 100; i++) { Print("Iteration " + I2S(i)); } };
	testFunctionVariable.execute();
	testFunctionVariable.evaluate(); // Illegal!
}

Parameter-Beispiel:
void test()
{
	timer testTimer = CreateTimer();
	TimerStart(testTimer, 2.0, true, { Print("Timer function runs!"); });
}

Funktionsaufrufe

Notation:
<Funktionsname | Funktionsvariable>[<.execute | .executefast | .evaluate>](<Parameterwert> ...);
<Funktionsname>[<.execute | .executefast | .evaluate>](<Parametername> = <Parameterwert>);

Zweitere Notation ist nur bei Funktionen, jedoch nicht bei Funktionsvariablen anwendbar. Sie erlaubt eine explizite Definition der
übergebenen Parameterwerte.
Des Weiteren gilt es zu beachten, dass Standardparameterwerte bei Funktionsvariablen ihre Gültigkeit verlieren. Bei ihnen müssen
sämtliche Parameterwerte explizit angegeben werden.

Ausnahmebehandlung

Ausnahmen können von einer beliebigen Funktion geworfen werden, die als "throw" Funktion deklariert wurde.
Die Ausnahme kann mittels eines try-catch-Blocks aufgefangen werden.

Notation:
try
{
	<Anweisungen>
}
catch (<Typ> <Variablenname>)
{
}
default // Alle anderen Ausnahmen
{
}

Finally

Finally-Blöcke werden in jedem Fall vor der return-, (throw-, macht das Sinn?)  continue- oder break-Anweisung einer Funktion oder Schleife oder
am Ende eines try-Blocks abgearbeitet.

Notation:
<Funktionsdefinition | Schleifendefinition | Try-Block>
finally // Wird exakt vor der return-, (throw-,) continue- oder break-Anweisung oder am Ende des try-Blocks abgearbeitet
{
}

Pseudonyme (aliases)

Das Schlüsselwort "alias" ermöglicht es einem einen anderen Bezeichner für einen bestehenden zu definieren. Dieser gilt innerhalb
des Gültigkeitsbereiches, in welchem sich die Pseudonymdefinition befindet.
Der neue Bezeichner darf bereits existieren und überdeckt innerhalb des Gültigkeitsbereiches den alten. Der Compiler sollte in
diesem Fall jedoch eine Warnung ausgeben.
Der Bezeichner dagegen muss existieren.

Notation:
alias <Bezeichner> <Neuer Bezeichner>;

Vorlagen (templates)

Vorlagen werden (nur bei Verwendung) mittels einer einfachen Kopie ihres enthaltenen Codes mit den verwendeten Datentypen gespeichert.
Die Datentypparameter können genau wie bei Funktionsparameter gesetzt werden.

Notation:
template <Vorlagenbezeichner>< <Datentypparameterbezeichner> [= <Standardargument>] ...>
{
    <Vorlageninhalt>
}

<Vorlagenbezeichner>< <Datentypparameterbezeichner> = <Parameterwert> ... >
<Vorlagenbezeichner>< <Parameterwert> ... >

Beispiel:
Vector<integer> myVector = new Vector<integer>;

Der Vorlageninhalt können Funktionen, Klassen oder Pakete sein.

Zugriffsmodifikatoren

Zugriffsmodifikatoren bestimmten die Zugriffsmöglichkeiten auf bestimmte Deklarationen.
"private", "public" und "protected" bestimmten je nach Verwendung innerhalb einer Klasse oder eines Pakets, von wo aus das Code-Objekt
verwendet werden darf.
Wird die Deklarationen innerhalb einer Klasse deklariert, so kann das Schlüsselwort "package" verwendet werden, um einen Zugriff vom Paket, in welchem
sich die Klasse befindet zu erlauben.
Wird die Deklarationen dagegen innerhalb eines Pakets deklariert, so wird "package" impliziet angehängt (explizit auch möglich), da innerhalb des Pakets
der Zugriff auf die Deklarationen standardmäßig erlaubt ist.

Notation:
[private | public | protected] [package] <Deklarationen>

Freunde

Freunde sind Bezeichner, welchen der Zugriff auf alle enthaltenen Elemente, die den Zugriffsmodifikatoren entsprechen, erlaubt wird.
Pakete und Klassen können Freunde haben.
Die Bezeichner können durch Kommata getrennt werden.

Notation:
[Zugriffsmodifikatoren] friend <Bezeichner>[, <Bezeichner>, ...];

Pakete (packages)

Notation einer Paketdefinition:
package <Name> [<Deklarationsvoraussetzungen>]
{
	static { } // Initialisierer
	[Zugriffsmodifikatoren] <Funktion/Variable/Vorlage/Klasse/Aufzählung/Paket>
	<Freunde>
}

Fehlen die Zugriffsmodifikatoren, ist das Objekt automatisch "private package". Protected bewirkt, dass das Objekt für die enthaltenen Pakete
zugänglich ist.
"package" wird implizit an die Zugriffsmodifikatoren angehängt (siehe "Zugriffsmodifikatoren").
Die Elemente des Pakets werden immer automatisch an erster Stelle deklariert, die Elemente der Unterpakete an zweiter, wodurch die Unterpakete bei
nicht-"private"-Elementen immer auf diese zugreifen können.
Wird ein Freund deklariert, so erhält dieser je nach Präfixschlüsselwort Zugriff auf sämtliche
als solche deklarierten Paketelemente (auch Unterpakete, allerdings nicht deren Elemente - Überprüfen: Freundesfreundezugriff?).
public friend <Paketname> ist daher implizit gültig, da es dem Paket <Paketname> Zugriff auf alle öffentlichen
Eigenschaften gestattet.
private friend <Paketname> würde bewirken, dass die im Paket enthaltenen Pakete, die als "private"
deklariert wurden, vom Paket <Paketname> zugreifbar wären, allerdings nicht deren private Elemente.
Dazu müsste das enthaltene Paket ebenfalls die gleiche Anweisung enthalten.
Neben anderen Paketen können auch anderen Klassen und Funktionen spezielle Zugriffe ermöglicht werden.

Initialisierer:
Die Initialisierungsfunktion wird genau vor dem ersten Zugriff auf ein Paketelement aufgerufen.
Dies wird vom Compiler durch eine Laufzeitüberprüfung ermöglicht und kann relativ viel Zusatzcode erzeugen, da bei jedem Zugriff von außerhalb
überprüft werden muss, ob die Klasse bereits initialisiert wurde.
Die Funktion darf nicht manuell aufgerufen werden und hat deshalb keine Zugriffsmodifikatoren, keinen Rückgabetyp, keinen Bezeichner und keine Parameter.

Aufzählungen (enums)

Wird ein Enumelement gesetzt, so werden alle darauffolgenden Enum-Elemente auf die noch nicht verwendeten nachfolgenden Werte gesetzt.

Notation:
enum Name [Deklarationsvoraussetzungen]
{
    Enumelement1, // ist automatisch 0
    Enumelement2 = 2,
    Enumelement3 // ist automatisch 3
} [globale Instanzen durch Kommate getrennt];

Der size-Operator kann verwendet werden, um den Wert x + 1 zu erhalten, wobei x für das den Wert des Aufzählungselements mit dem höchsten Wert steht.

Klassen

Existiert kein Präfix wie "public", "protected" oder "private" vor der Variablen oder Methodendeklaration, ist das
Klassenelement automatisch "private" (nicht "private package"!). Statische Methoden erhalten keinen this-Parameter.
Statische Variablen können mit Klassenname.Variablenname angesprochen werden.
Der Konstruktor und der Destruktor werden aufgerufen, sobald das Objekt erzeugt oder gelöscht wird.
Der Kopierkonstruktor wird aufgerufen, sobald das Objekt explizit mittels "copy" kopiert wird.
Normalerweise wird er automatisch definiert und kopiert den Inhalt aller Elemente des kopierten Objekts in das Zielobjekt (anders als bei C++).
Mit dem Schlüsselwort "parent" spricht man die Elternklassen an. Diese können aber auch über ihren Namen, wie bei gewöhnlichen
Gültigkeitsbereichen, angesprochen werden. Da sie normalerweise kein äußerer Gültigkeitsbereich sind, funktioniert die Verwendung des .-Operators nicht.
Mit dem Schlüsselwort "self" spricht man die eigene Klasse an. Bei virtuellen statischen Methoden muss darauf geachtet werden, mit welcher Klasse
die erste statische Methode aufgerufen wurde, damit diese die korrekten weiteren statischen Methoden aufruft, insofern sie selbst z. B. zu einer
der Elternklassen und nicht zur Klasse für die der Aufruf galt gehört.
Der Zugriff auf die Klasse kann allerdings auch, wie bei gewöhnlichen Gültigkeitsbereichen, über ihren Namen oder den .-Operator angesprochen werden.
In diesem Fall wird ebenfalls überprüft, ob es sich um eine virtuelle statische Methode handelt und die der korrekten Klasse aufgerufen.
Mit dem Schlüsselwort "this" spricht man die verwendete Instanz an.
Es können nur mehr als 8192 Instanzen erzeugt werden, wenn eine Klasse eine Maximalgrößenangabe hat oder eine globale Hashtable exisitiert.
In diesem Fall werden die Instanzdaten in der globalen Hashtable oder in zusätzlichen globalen Variablen gespeichert.
Falls die angegebene Maximalgröße den Wert 8192 übersteigt, sollte der Compiler eine Warnung bzw. einen Hinweis ausgeben.
Die Maximalgröße einer Klasse kann mit dem size-Operator abgefragt werden: <Klassenbezeichner>.size
Im Debug-Modus muss zur Laufzeit 0 vom new-Operator zurückgegeben und eine Fehlermeldung ausgegeben werden, falls die Instanzgrenze überschritten wurde.
Außerdem muss im Debug-Modus eine Fehlermeldung zurückgegeben bzw. abgebrochen werden, wenn der delete-Operator auf eine 0-Instanz angewandt wird.

Abstrakte Klassen:
Abstrakte Klassen werden mit dem Schlüsselwort "abstract" deklariert. Von ihnen können keine
Instanzen erzeugt werden. Erbt eine Klasse, eine andere abstrakte Klasse, so muss sie sämtliche
abstrakte Methoden implementieren, um nicht mehr selbst als abstrakt zu gelten.

Vererbung:

Mehrfachvererbung:
Überschneiden sich Elemente mehrerer geerbter Klassen, so wird vom Compiler eine Warnung ausgegeben.
Handelt es sich um Elementvariablen, so wird lediglich die erste Elementvariable der geerbten Klassen belegt.
Bei den Methoden wird ebenfalls die Methode der zu erst geerbten Klasse (von unten nach oben, von links nach rechts) aufgerufen.

Protected:
Ist ein Klassenelement "protected", so kann darauf nur von Kindklassen der Klasse zugegriffen werden.

Package:
Ist ein Klassenelement "package", so kann darauf innerhalb des Pakets, in welchem die Klasse deklariert wurde und
aus dessen Unterpaketen zugegriffen werden.

Notation:
[ abstract ] class Klassenname [ [Maximalgröße] ] (public | private | protected Klassenname, ...) [Deklarationsvoraussetzungen]
{
	[Zugriffsmodifikatoren] self new([<Konstruktorparameter>]) { } // Konstruktor
	[Zugriffsmodifikatoren] self copy() { } // Kopierkonstruktur
	[Zugriffsmodifikatoren] void delete() { } // Destruktor
	static { } // Initialisierer

	<Freunde>;
	[Zugriffsmodifikatoren] [static] <Methode> | <Variable> [ = <Startwertzuweisung> ] | <Aufzählung> | <Klasse> | <Paket>;
} [globale Instanzen durch Kommata getrennt];

Elemente

Klassenelemente entsprechen Variablendeklarationen mit Zugriffsmodifikatoren, die zusätzlich statisch oder mutabel (veränderlich/mutable) sein können.
Elemente, die statisch sind, können niemals als "mutable" deklariert werden und umgekehrt.
Statische Elemente werden zur Laufzeit pro Klasse einmal erzeugt und sind wie globale Variablen innerhalb des Gültigkeitsbereiches der Klasse.
Nicht statische Elemente exisitieren zur Laufzeit pro Klasseninstanz einmal.
Sie können per <Klasseninstanzvariable>.<Elementname> angesprochen werden.
Als "mutable" deklarierte Elemente, können auch von konstanten Methoden oder bei einem Direktzugriff bei konstanten Instanzen verändert werden.

Array-Elemente:
Eine Klasse kann ebenfalls Array-Elemente enthalten.
Exisitiert keine vom Compiler generierte globale Hashtable und ist das Element nicht statisch, empfiehlt es sich, eine Maximalgröße angegeben 
werden (siehe "Arrays").
Ansonsten entspricht die Größe der Maximalgröße von Arrays in Jass (8192) / die Maximalgröße der Klasse.
Der Compiler sollte in diesem Fall zumindest eine Warnung ausgeben.
Statische Array-Elemente werden wie gewöhnliche Arrays behandelt (siehe "Arrays").

Methoden

Als virtuell deklarierte Methoden, werden pro Klasseninstanz gespeichert. So wird immer die unterste virtuelle Methode aufgerufen.
Virtuelle Methoden müssen zwingend threaded sein.
Achtung: Virtuelle Methoden sollten nicht im Konstruktor aufgerufen werden, da sie durch die Konstruktoren erst überschrieben
und der Klasseninstanz zugewiesen werden. Der Compiler sollte in diesem Fall eine Warnung ausgeben.
Der Konstruktor selbst kann nicht virtuell sein.
Besitzt eine Klasse virtuelle Methoden, so sollte der Compiler eine Warnung ausgeben, falls sie keinen virtuellen Destruktor besitzt.
Statische Methoden können ebenfalls virtuell sein und werden entsprechend des zugehörigen Objekts aufgerufen.

Abstrakte Methoden müssen allesamt implementiert werden. Abstrakte-Methoden-Implementationen müssen virtuell sein, da sonst
möglicherweise keine Methode aufgerufen werden würde.

"public" und "protected" Methoden können in der Kindklasse "umdeklariert" werden, was ihre zugreifbarkeit verändert,
ohne dass sie neu definiert werden müssen.
Dies geschieht, indem man bei der Methodendeklaration den Gültigkeitsberech weglässt und die Deklaration mit einem Semikolon abschließt.

Mit parent.<Methodenname> oder <Elternklasse>.<Methodenname> kann eine Elternmethode angesprochen werden.
Dabei gilt die Priorität von unten nach oben, von links nach rechts, bei sämtlichen geerbten Klassen.

Abstrakte Methoden besitzen keinen Gültigkeitsbereich, sondern werden mit einem Semikolon abgeschlossen.

Nichtstatische Methoden, die mit dem Postfix "const" deklariert wurden, erhalten das Argument this als konstante Variable
(bezogen auf das Ziel dessen) und gelten somit auch als eine andere Deklaration der gleichen Methode, welche nicht als "const"
deklariert wurde (siehe Funktionen).

Statische Methoden, die mit dem Postfix "const" deklariert wurden, dürfen keinerlei nicht als "const" deklarierte, statische
Methoden der Klasse aufrufen, geschweigedenn irgendwelche statischen Elemente der Klasse verändern, sondern nur zurückgeben.

Sämtliche nicht private Methoden der Elternklassen können überschrieben werden. Dabei ist es optional, ob die ursprünglichen Methoden innerhalb
der Methode aufgerufen werden.

Virtuelle Methoden bewirken, dass diese auch aufgerufen werden, wenn das Objekt zu einem Elterntyp konvertiert wurde, da pro
Objekt Verweise auf die entsprechenden Methoden gespeichert werden. Dies gilt für statische und nicht statische virtuelle Methoden.
Bei virtuellen statischen Methoden kommt noch die Besonderheit hinzu, dass bei einem Aufruf der statischen Methode Kindklasse::statischeMethode(),
welche jedoch in der Kindklasse nicht neu definiert wurde, weshalb automatisch die der Elternklasse aufgerufen wird, von der statischen Methode
überprüft werden muss, von welcher Klasse aus sie aufgerufen wurde, damit sie bei virtuellen statischen Methoden die richtigen der Kindklasse und
nicht die der Elternklasse aufruft.
Virtuelle Methoden müssen in jedem Fall "threaded" sein!

Notation:
[static] [virtual | abstract] Funktionsdeklaration [const]

Konstruktor:
Der Konstruktor einer Klasse darf nicht virtuell und somit auch nicht abstrakt sein.
Konstruktoren einer Klassevererbungshierarchie werden von oben nach unten, von links nach rechts, aufgerufen.
Empfangen alle Elternklassenkonstruktoren bestimmte Argumente und wird nicht mindestens einer davon manuell aufgerufen,
so gibt der Compiler einen Fehler zurück, da die Elternklassen nicht richtig konstruiert wurden.
Jede nächstgelegene Elternklasse muss konstruiert werden, ob implizit, falls möglich, oder explizit.
Wird kein Konstruktor in einer Kindklasse definiert, so können selbstverständlich die der Elternklassen mit dem Bezeichner
der Kindklasse verwendet werden.
Der Konstruktor muss stets den Namen new tragen und besitzt den Rückgabetyp "self". Er sollte für Gewöhnlich das Objekt "this"
zurückgeben, jedoch ist dies dem Entwickler selbst überlassen. Gegebenenfalls sollte der Compiler eine Warnung ausgeben, falls
nicht das Objekt "this" zurückgegeben wird.

Notation:
new <Klassenname>([<Konstruktorparameter>])

Kopierkonstruktor:
Weist man einer Objektvariable den Wert einer anderen zu, so zeigen beide Variablen normalerweise auf dasselbe Objekt.
Dies kann umgangen werden, indem man den Kopierkonstruktor verwendet und das Objekt kopiert bzw. ein neues mit den gleichen
Eigenschaften erzeugt.
Dazu dient das Schlüsselwort "copy". Es kann entweder die definierte copy-Methode aufgerufen oder das Schlüsselwort der Variable
vorangestellt werden. Wurde kein eigener Kopierkonstruktor definiert, so werden sämtliche Elementinhalte ebenfalls kopiert.
Zu beachten gilt dabei, dass der Inhalt von Array-, Funktions- und Objektelementvariablen ebenfalls kopiert wird, sowie auch deren
Arrays, Funktionen und Objekte usw. (unter Verwendung von deren Kopierkonstruktoren). Dadurch zeigen die Elementvariablen beider Objekte nur auf 
dieselben Ziele, falls es sich bei den Elementvariablen um keine Objekte handelt, sondern um referenzbasierte native Typen, wie z. B. "unit".
Der Inhalt von Elementvariablen mit kopierbasierten Typen wird selbstverständlich ebenfalls kopiert (dazu ist natürlich kein Kopierkonstruktor notwendig).
Ist der Kopierkonstruktor als "private" oder "protected" definiert, so kann das Schlüsselwort
nicht von außerhalb angewandt werden (gängiges Verhalten, auch bei anderen Methoden).
Der Kopierkonstruktor darf virtuell und abstrakt sein.
Er darf keinerlei Parameter enthalten.

Notation:
copy <Variable>
<Variable>.copy()

Beispiele:
class X a = new a();
class X b = a.copy();
a = copy b;

Destruktor:
Ein Objekt kann mit Hilfe des "delete"-Schlüsselworts gelöscht bzw. freigegeben werden.
Dabei wird der Variableninhalt automatisch auf 0 gesetzt, was Fehlzugriffe einschränkt bzw. verhindert.
Zunächst wird der Destruktor, falls vorhanden, der Klasse aufgerufen und danach bis zur obersten Elternklasse hin alle Destruktoren
der geerbten Klassen. Dabei werden bei einer Mehrfachvererbung zunächst die Vererbungshierachien der ersten Klassen von unten nach oben,
von rechts nach links abgearbeitet (genau andersherum als beim Konstruktor).

Notation:
delete <Variable>
<Variable>.delete()

Initialisierer:
Die Initialisierungsmethode wird genau vor dem ersten Zugriff auf eine Klasseneigenschaft oder -methode aufgerufen.
Dies wird vom Compiler durch eine Laufzeitüberprüfung ermöglicht und kann relativ viel Zusatzcode erzeugen, da bei jedem Zugriff von außerhalb
überprüft werden muss, ob die Klasse bereits initialisiert wurde.
Die Methode darf nicht manuell aufgerufen werden und hat deshalb keine Zugriffsmodifikatoren, keinen Rückgabetyp, keinen Bezeichner und keine Parameter.
 
Save- und Load-Möglichkeiten:
Mit Hilfe der Schlüsselwörter store, restore und flush, kann eine Klasseninstanz in einem Spiel-Cache verwaltet werden.
Dabei muss dem Schlüsselwort der Spiel-Cache, ein Mission-Key und ein Label-Präfix für sämtliche Werte übergeben werden.
Zu beachten gilt, dass Elemente der Instanz, welche nicht den Typ integer, real, boolean, string oder unit haben,
nicht in einem Spiel-Cache gespeichert werden können, weshalb man für solche Klasseninstanzen die Hashtable-Schlüsselwörter
verwenden muss.
In eine Hashtable kann jeder native Datentyp aus Warcraft 3 gespeichert werden, weshalb sämtliche Klasseninstanzelemente
problemlos gespeichert und geladen werden können.
Die Hashtable-Schlüsselwörter "save" und "load" entsprechen den Spiel-Cache-Schlüsselwörtern "store" und "restore".
Mit dem Schlüsselwort "remove", können die Elemente wieder aus der Hashtable entfernt werden. Für Spiel-Cache-Elemente
muss das Schlüsselwort "flush" verwendet werden.
Bei Hashtable-Aufrufen wird neben der verwendeten Hashtable nur ein Parent-Key übergeben. Als Child-Key wird einfach die
Nummer des jeweiligen Elements genommen. Dabei wird von der Deklarationsreihenfolge in der Klassendeklaration ausgegangen und bei 0 mit dem Zählen angefangen.
Vor allem die Spiel-Cache-Schlüsselwörter können von Nutzen sein, wenn man eine Kampagne erstellen möchte, in welcher
in weiteren Karten die Daten der alten geladen werden sollen.
Array-Elemente werden mit dem jeweiligen Index als Postfix im Spiel-Cache und wie als ein separates Element in der Hashtable 
gespeichert.

Notation:
<Variablenname>.store(<Spiel-Cache>, <Mission-Key>, <Label-Präfix>)
<Variablenname>.restore(<Spiel-Cache>, <Mission-Key>, <Label-Präfix>)
<Variablenname>.flush(<Spiel-Cache>, <Mission-Key>, <Label-Präfix>)
<Variablenname>.save(<Hashtable>, <Parent-Key>)
<Variablenname>.load(<Hashtable>, <Parent-Key>)
<Variablenname>.remove(<Hashtable>, <Parent-Key>)

Operatorenüberladung

Eine Funktions- oder Methodendeklaration, welche das Schlüsselwort operator und ein zugehöriges Operatorzeichen oder einen zugehörigen Typnamen enthält, überlädt die Bedeutung eines
Operators für die angegebenen Parametertypen.
Dies kann global, innerhalb eines Pakets oder innerhalb einer Klasse usw. geschehen (private, protected, public, package).
Wird ein Typ und kein Operatorzeichen als Name genommen, so ermöglicht dies Klassenobjekten explizit die Konvertierung zu diesem Typ.
Folgende Operatoren können nach folgenden Schemata als nicht statische Methoden überladen werden:
Bezeichner			Rückgabetyp			Parametertypen
=				self				self
+ (linksbündig)			self				-
- (linksbündig)			self				-
+ (rechtsbündig)		self				self
- (rechtsbündig)
*				self				self
/				self				self
%				self				self
++				self				self
--				self				self
+=				self				self
-=				self				self
*=				self				self
/=				self				self
%=				self				self
==				boolean				self
!=				boolean				self
>=				boolean				self
<=				boolean				self
>				boolean				self
<				boolean				self
!				boolean				self
true (steht für den boolschen Ausdruck ohne Operatorzeichen)

Zu beachten gilt es hierbei, dass diverse Logikoperatoren bereits standardmäßig implementiert sind.
Die eigenen Definitionen überladen selbstverständlich die standardmäßigen.

Als Typ können sowohl native als auch eigene Typen genommen werden. Zu beachten gilt es hierbei, dass sich Klasseninstanzen standardmäßig
zum Typ "integer" konvertieren lassen.

Das Jass-Paket

Das Jass-Paket deklariert sowohl native Typen und Funktionen als auch nicht native Funktionen und Variablen der Dateien "common.j", common.ai" und "Blizzard.j".
Als Alternative können jene drei Dateien auch mittels #include jass <Dateipfad> eingebunden werden.

package jass
{
	package commonj
	{
	}
	
	package commonai
	{
	}
	
	package Blizzardj
	{
	}
}

Das Standardpaket

Es existieren Wrapper für jeden Warcraft-3-Datentyp, sowie zusätzliche Methoden und Klassen. Auf das Wichtigste beschränken!

package jasspp
{
    package jass.*;

    /*
    Definition spezieller implementationsspezifischer Funktionen.
    */
    debug
    {
	integer allocateArrayInstance();
	integer allocateClassInstance();
	boolean freeArrayInstance(integer index);
	boolean freeClassInstance(integer index);
	boolean freeFunctionPrototype(integer index);
    }

    /*
    Definitionen globaler Funktionen, welche in der Regel die nativen Typen verwenden.
    */
    void Print(string message);

    /*
    Definitionen der Wrapper-Klassen, welche die Funktionalität der nativen Typen mittels Objektorientierung anbieten.
    */
    public class Boolean
    public class String
    public class Integer
    public class Real
    public class Code
    public class Handle
    public class Agent : public Handle
    public class Widget : public Agent
    public class Unit : public Widget
    public class Item : public Widget
    public class Destructable : public Widget
    public class Event
    public class Trigger
    public class HashTable
    
    /*
    Definition eigener Klassen wie z. B. verschiedener Container-Klassen usw.
    */
    class List
    class Vector
    class Map
    class Bitset
}
