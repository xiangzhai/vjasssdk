/***************************************************************************
 *   Copyright (C) 2008 by Tamino Dauth                                    *
 *   tamino@cdauth.de                                                      *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/

#include <boost/foreach.hpp>

#ifdef SQLITE
#include <sqlite3.h>
#endif

#include "compiler.hpp"
#include "parser.hpp"
#include "language.hpp"
#include "../utilities.hpp"

namespace wc3lib
{
	
namespace lang
{
	
Compiler::Compiler()
{
}

Compiler::~Compiler()
{
}
	
void Compiler::compile(std::iostream &iostream, const class Parser &parser) throw (class Exception)
{
	BOOST_FOREACH(class Language *language, parser.m_languages)
		language->prepareObjects();
	
	BOOST_FOREACH(class Language *language, parser.m_languages)
		language->writeObjects(iostream);
}

void Compiler::optimize(std::iostream &iostream) throw (class Exception)
{
}

#ifdef HTML
void Parser::createHtmlFiles(const boost::filesystem::path &dirPath, const std::string &title, bool showGeneratedHint) throw (class Exception)
{
	std::ofstream ofstream((dirPath / "index.html").string().c_str());
	
	if (!fstream)
		throw Exception(boost::str(boost::format(_("Unable to create file \"%1%\".")) % (dirPath / "index.html").str()));
	
	createHtmlHeader(ofstream, title);
	ofstream
	<< "\t<body>\n"
	<< "\t\t<h1>" << title << "</h1>\n"
	;
	
	if (showGeneratedHint)
		ofstream << "\t\t<p>" << boost::format(_("Generated by wc3lib %1%.")) % wc3libVersion << "</p>\n"
	
	ofstream
	<< "\t\t<ul>\n"
	<< std::endl;

	BOOST_FOREACH(class Language *language, parser->m_languages)
		language->htmlWriteObjectsCategories(ofstream, "\t\t\t");
	
	ofstream
	<< "\t\t</ul>\n";
	<< "\t</body>" << std::endl
	<< "</html>";	
	ofstream.close();
	
	BOOST_FOREACH(class Language *language, parser->m_languages)
		language->htmlWriteObjectsPages(dirPath);
}
#endif
#ifdef SQLITE
void Parser::createDatabase(const boost::filesystem::path &path)
{
	if (boost::filesystem::exists(path))
	{
		std::cout << boost::format(_("Database \"%1%\" does already exist. Do you want to replace it by the newer one?")) % path << std::endl;
		std::cout << _("Answer possiblities: y, yes, n, no.") << std::endl;
		
		std::string answer;
		
		do
		{
			std::cin >> answer;
			
			if (answer == _("y") || answer == _("yes"))
			{
				if (!boost::filesystem::remove(path))
				{
					std::cout << _("Was unable to replace old database.") << std::endl;
					
					return;
				}
				
				break;
			}
			else if (answer == _("n") || answer == _("no"))
			{
				std::cout << _("Canceled database creation.") << std::endl;
				
				return;
			}
			else
				std::cout << _("Unknown answer.") << std::endl;
		}
		while (true);
	}
	
	sqlite3 *database;
	int state = sqlite3_open(path.string().c_str(), &database);
	
	if (state == SQLITE_OK)
	{
		char *message = 0;
		state = sqlite3_exec(database, "BEGIN TRANSACTION", 0, 0, &message);
		
		if (state != SQLITE_OK)
		{
			std::cerr << boost::str(boost::format(_("Was unable to begin transaction.\nState: %1%.\nMessage: %2%")) % state % message) << std::endl;
			sqlite3_free(message);
		}
	
		BOOST_FOREACH(class Language *language, parser->m_languages)
		{
			
			/// @todo Continue development
			if (!Vjassdoc::optionParseObjectsOfList(Parser::List(i)) || this->getList(Parser::List(i)).empty())
				continue;

			state = sqlite3_exec(database, this->getTableCreationStatement(Parser::List(i)).c_str(), 0, 0, &message);

			if (state != SQLITE_OK)
			{
				/// @todo test output
				std::cout << "Table list " << i << std::endl;
				std::cout << "Table creation statement: " << this->getTableCreationStatement(Parser::List(i)).c_str() << std::endl;
				
				fprintf(stderr, _("Was unable to create table \"%s\" from list %d.\nState: %d.\nMessage: %s\n"), Parser::getTableName(Parser::List(i)).c_str(), i, state, message);
				sqlite3_free(message);
			}

			std::list<class Object*> list = this->getList(Parser::List(i));

			for (std::list<class Object*>::iterator iterator = list.begin(); iterator != list.end(); ++iterator)
			{
				std::ostringstream sstream;
				sstream << "INSERT INTO " << Parser::getTableName(Parser::List(i)) << " (Id) VALUES (" << (*iterator)->id() << ')';
				
				state = sqlite3_exec(database, sstream.str().c_str(), 0, 0, &message);

				//std::cerr << "Execution " << sstream.str().c_str() << std::endl;

				if (state != SQLITE_OK)
				{
					fprintf(stderr, _("Was unable to insert id of list %d into table \"%s\".\nState: %d.\nMessage: %s\n"), i, Parser::getTableName(Parser::List(i)).c_str(), state, message);
					sqlite3_free(message);
				}
		
				sstream.str("");
				sstream.clear();

				//std::cout << "Before update of object " << (*iterator)->identifier() << std::endl;
				sstream << "UPDATE " << Parser::getTableName(Parser::List(i)).c_str() << " SET " << (*iterator)->sqlStatement() << " WHERE Id=" << (*iterator)->id();
				//std::cout << "After update" << std::endl;
				//std::cout << "Execution command: " << sstream.str().c_str() << std::endl; //NOTE debug


				state = sqlite3_exec(
						database, /* An open database */
						sstream.str().c_str(), /* SQL to be evaluated */ //FIXME
						0, //int (*callback)(void*,int,char**,char**), /* Callback function */
						0, //void *, /* 1st argument to callback */
						&message /* Error msg written here */
				);
				
				if (state != SQLITE_OK)
				{
					fprintf(stderr, _("Was unable to run execution \"%s\" of table \"%s\" from list %d.\nState: %d.\nMessage: %s\n"), sstream.str().c_str(), Parser::getTableName(Parser::List(i)).c_str(), i, state, message);
					sqlite3_free(message);
				}
			}
		}
		
		state = sqlite3_exec(database, "COMMIT", 0, 0, &message);
		
		if (state != SQLITE_OK)
		{
			fprintf(stderr, _("Was unable to commit.\nState: %d.\nMessage: %s\n"), state, message);
			sqlite3_free(message);
		}
	}
	else
		fprintf(stderr, _("Was unable to create database. State %d.\n"), state);
	
	sqlite3_close(database);
}
#endif

}

}
